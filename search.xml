<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo-主题美化]]></title>
    <url>%2F2018%2F05%2F08%2FHexo-%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[博客搭建已经好久了，这段时间对next主题也根据个人的意愿进行了一些美化，就在这里记载下来首页不显示全文 进入hexo博客项目的themes/next目录 打开_config.yml文件（主题配置文件） 搜索”auto_excerpt” 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 将enable的值从false改为true，再 hexo g hexo d就可以了 增添搜索功能 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑站点配置文件（hexo博客项目下的config_yml） 12345search: path: search.xml field: post format: html limit: 10000]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-多线程]]></title>
    <url>%2F2018%2F05%2F05%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述 进程：计算机中的程序关于某数据集合的一次运行活动，是系统进行资源分配和调度的基本单位。 线程：就是进程中的一个负责程序执行的控制单元（执行路径）。 一个进程中可以有多个执行路径，称之为多线程。 一个进程中至少要有一个线程 开启多个线程是为了同时运行多部分代码 每一个线程都有自己运行的内容，这个内容可以称为线程要执行的任务 利弊 多线程操作，可以让多个任务并行执行，a任务等待硬盘响应时，让b任务去用cpu，所以，多线程不能提高单任务的运行速度，但是可以提高多个可以并发的任务速度。 好处：解决多部分同时运行的问题 弊端：线程过多会导致效率的降低 JVM多线程分析 JVM启动时就启动了多个线程，至少有两个可以分析出来 1.执行main函数的线程 该线程的任务代码都定义在main函数中 2.负责垃圾回收的线程 创建线程创建方式一 继承 Thread 类 1、定义一个类继承 Thread 类 2、必须覆盖 Thread 类的 run 方法 3、直接创建 Thread 的子类对象创建线程 4、调用 start 方法开启线程并调用线程的任务 run 方法执行 12345678910111213141516171819202122232425262728293031323334/*创建线程的目的是开启一条执行路径，去运行指定的代码和其他代码同时运行而运行的代码就是这个执行路径的任务JVM创建的主线程的任务都定义在主函数中而自定义的线程，他的任务在哪儿？Thread类用于描述线程，线程是需要任务的，所以Thread类也对任务的描述这个任务就通过Thread类中的run方法来体现也就是说，run方法就是封装自定义线程运行任务的函数，run方法中定义就是线程要运行的任务代码*/public class Demo extends Thread&#123; private String name; public Demo(String name)&#123; this.name = name; &#125; public void run()&#123; show(); &#125; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.println(name+&quot;...i:&quot;+i); &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(&quot;小白&quot;); Demo b = new Demo(&quot;black&quot;); a.start(); b.start(); //a.run(); //b.run(); &#125;&#125; 在上述代码的结尾，调用run和start函数有什么区别？ 调用start函数是多线程的，调用run函数还是按顺序主线程进行的 线程名称 想要展示出当前运行对象线程名称需要使用Thread类的currentThread方法 123456789101112131415161718192021222324252627public class Demo extends Thread&#123; private String name; public Demo(String name)&#123; super(); this.name = name; //super(name); &#125; public void run()&#123; show(); &#125; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.print(name+&quot;...i:&quot;+i); System.out.println(&quot;ThreadName&quot;+Thread.currentThread().getName()); &#125; &#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(&quot;小白&quot;); Demo b = new Demo(&quot;black&quot;); a.start(); b.start(); System.out.println(&quot;here&quot;+&quot;...&quot;+Thread.currentThread().getName());// a.run();// b.run(); &#125;&#125; 运行后可以试着4.5行注释掉，6行解除注释试一下，发现可以自己给线程名称赋值了 图解 开启了多线程后，栈内存就和之前不一样了，以前面代码为示例 如果在上文倒数第三行加上一句代码“System.out.println(4/0);” 观察运行结果，发现main函数已经抛出异常终止了，其余两线程仍能正常进行 线程的状态 创建方式二 实现Runnable接口 1、定义类实现Runnable接口 2、覆盖接口中的run方法，将编程的任务代码封装到run方法中 3、通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递 4、调用线程对象的start方法开启线程 第三步的原因 因为线程的任务都封装在Runnable接口子类对象的run方法中，所以要在线程对象创建时就必须明确要运行的任务 123456789101112131415161718192021222324public class Demo implements Runnable&#123; //准备扩展Demo类的功能，让其中的内容可以作为多线程执行 //通过接口的方式完成 private String name; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.println(Thread.currentThread().getName()+&quot;...&quot;+i); &#125; @Override public void run() &#123; show(); &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(); Demo b = new Demo(); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); System.out.println(&quot;here&quot;+&quot;...&quot;+Thread.currentThread().getName()); &#125;&#125; 方式二细节方式二优点 实现Runnable接口的好处 1、将线程的任务从线程的子类中分离出来，进行了单独的封装，按照面向对象的思想将任务封装成了对象 2、避免了Java单继承的局限性 所以创建线程的第二种方式比较常用 卖票示例 在火车站一共有100张票，4个窗口同时卖票，用多线程来描述 运行图中左侧代码后发现，并不是想象中的卖100张，而是变成了4*100张，可以选择将ticket类中的num值变成静态变量，但这不是最好的选择。 另外还有人说可以不在堆中创建那么多的对象，只创建一个对象，进行4次线程开启，这是不可取的，多次启动一个线程是非法的。 12345678910111213141516171819202122 class Ticket implements Runnable&#123; private int num = 100; public void run()&#123; while(true)&#123; if(num&gt;0) System.out.println(num--); &#125; &#125; &#125; class TicketDemo&#123; public static void main(String[] args)&#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 通过继承的方式创建没有达到我们的目的，于是就采用上述代码中接口的方式创建 线程安全隐患 以车站卖票为示例，如果当车票只剩一张时，t1进入临时堵塞状态，有执行资格不具备执行权，推给t2执行，t2也临时堵塞一下，继续往后推，然后假设t3，t4也是临时堵塞，那他们现在都具备执行资格，没有执行权，然后t1卖出一张票，票数为0，但是t2.3.4都已经进入循环，可以卖票，于是分别卖出了第0.-1.-2张票。这对于铁路局来说是不允许的，有安全隐患。 有人说为什么我运行很多次都没有出现这种错误那，因为这只是有一定可能发生的，为了看起来更清晰，可以人为的方式，使产生安全隐患概率增加 12345678910111213141516class Ticket implements Runnable&#123; private int num = 100; public void run()&#123; while(true)&#123; if(num&gt;0)&#123; try&#123; Thread.sleep(10); &#125;catch(InterruptedException)&#123; //解决异常代码 &#125; System.out.println(num--); &#125; &#125; &#125;&#125; &#125; 将ticket类改成这样，在运行主类，发现会出现之前所说的安全隐患 线程安全问题产生原因 1、多个线程在操作共享数据 2、操作共享数据的线程代码有多条 当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算，就会导致线程安全问题的产生 解决思路（同步） 就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程不可以参与运算的，必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算 在Java中用同步代码块就可以解决这个问题 1234同步代码块格式：synchronized(对象)&#123; 需要被同步的代码；&#125; 所以更改代码后变为这样 123456789101112131415161718class Ticket implements Runnable&#123; private int num = 100; Object obj = new Object(); public void run()&#123; while(true)&#123; synchronized(obj)&#123; if(num&gt;0)&#123; try&#123; Thread.sleep(10); &#125;catch(InterruptedException)&#123; //解决异常代码 &#125; System.out.println(num--); &#125; &#125; &#125; &#125; &#125; 这次再去运行一下发现不会有问题 这很像锁，可以比喻成火车上的卫生间，一个人进去后，门锁上，门上有提示“有人”，别人就进不来，只有里面的人出去才可以。 同步的好处：解决了线程的安全问题 同步的弊端：相对降低了效率，因为同步外的线程都会判断同步锁同步前提 同步的前提：同步中必须有多个线程并使用同一个锁 1234567891011 private int num = 100; public void run()&#123; Object obj = new Object(); //注意：上面这句代码的位置和之前不同 while(true)&#123; synchronized(obj)&#123; //代码 &#125; &#125; &#125;&#125; 运行上面的代码后发现并没有解决安全问题，是因为这样写相当于有四个锁，把二三行代码换位置即可 同步函数 需求：两个储户去银行存款，每次100，存三次 1234567891011121314151617181920212223242526272829303132333435public class Bank &#123; private int sum; //private Object obj = new Object(); public synchronized void add(int num) &#123; //synchronized(obj)&#123; sum = sum + num; try &#123; //延时，增加出错可能性 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(sum); //&#125; &#125;&#125;public class Cus implements Runnable&#123; private String name; public Bank b = new Bank(); @Override public void run() &#123; for (int i=0; i&lt;3; i++) &#123; b.add(100); &#125; &#125;&#125;public class BankDemo &#123; public static void main(String[] args)&#123; Cus a = new Cus(); Thread t1 = new Thread(a); Thread t2 = new Thread(a); t1.start(); t2.start(); &#125;&#125; “多个线程在操作共享数据（sum），操作共享数据代码有多条（不算trycatch两条）”这两点都符合，所以有线程安全隐患 像上面这种情况，可以使用同步代码块，不过还有更简洁的方式就是在函数中加上同步关键字 验证同步函数锁 同步函数锁固定是this，同步代码块锁是任意的对象 开发中建议使用同步代码块 下面是验证时的代码（以双线程卖票为示例）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Ticket implements Runnable &#123; private int num = 100; boolean flag = true; public void run() &#123; if (flag) &#123; while (true) &#123; synchronized (this) &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;..emmm..&quot; + num--); &#125; &#125; &#125; &#125; else &#123; while (true) show(); &#125; &#125; public synchronized void show() &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;......&quot; + num--); &#125; &#125;&#125;public class SynFunctionLockDemo &#123; public static void main(String[] args)&#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t.flag = false; t2.start(); &#125;&#125; 验证静态同步函数锁 静态的同步函数使用的锁是 该函数所属的字节码文件对象 可以用getClass方法获取，也可以用 当前类名.class 表示 验证的代码和上面的大同小异，将this改为this.getClass或者Ticket.class再试试 单例模式涉及的多线程问题安全隐患分析 会出现安全隐患的是懒汉式，也就是延迟加载单例模式 123456789public class Single2 &#123; private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null) s = new Single2(); return s; &#125;&#125; 仔细想一下，他符合了会出现隐患的两个因素，线程0在进行（s==null）判断后，进入临时堵塞状态，然后线程1进行null的判断，进入临时堵塞状态。这时线程0创建了s对象，返回s，线程1又创建了一个对象，现在就有两个对象，不能保证唯一了，这就出现大问题了。 解决方法 加同步代码块解决安全问题，外面再加一次判断是解决效率问题 12345678910111213public class Single2 &#123; private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null)&#123; synchronized(Single2.class)&#123; if(s==null) s = new Single2(); &#125; &#125; return s; &#125; &#125; 死锁 常见情景之一：同步的嵌套 12 run函数里拿着obj的锁想进this的锁，show函数里拿着this锁想进obj 简单死锁代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MyLock &#123; //写两个锁 public static final Object MyLockA = new Object(); public static final Object MyLockB = new Object();&#125;import static bxdDay_13.MyLock.MyLockA;import static bxdDay_13.MyLock.MyLockB;public class DeadLock implements Runnable&#123; public boolean flag; //有参构造函数，创建对象时附带flag状态 public DeadLock(boolean flag)&#123; this.flag = flag; &#125; @Override public void run() &#123; if (flag)&#123; synchronized (MyLockA)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;if LockA&quot;); synchronized (MyLockB)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;if LockB&quot;); &#125; &#125; &#125;else &#123; synchronized (MyLockB)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;else LockB&quot;); synchronized (MyLockA)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;else LockA&quot;); &#125; &#125; &#125; &#125;&#125;public class DeadLockTest &#123; public static void main(String[] args)&#123; DeadLock a = new DeadLock(true); DeadLock b = new DeadLock(false); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); &#125;&#125; 运行上面的代码，观察结果,线程1拿到了B锁，线程2拿到了A锁，他们都想继续，可是互不相让，死锁了 12Thread-1 else LockBThread-0 if LockA 如果试了多次都是没有成功死锁，那就在 if语句 及 else语句 后面各加一句 while(true) 线程间通信 多个线程在处理资源，但是任务却不同 同步前提：多个线程使用同一个锁 接下来用一个例子演示一下 需求：有一个资源库存放数据，一条线程在向里面输入，还有一条在向外输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//资源类public class Resource &#123; public String name; public String sex;&#125;//输入类public class Input implements Runnable &#123; Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; synchronized (r) &#123; if (x == 0) &#123; r.name = &quot;小白&quot;; r.sex = &quot;女女女&quot;; &#125; else &#123; r.name = &quot;black&quot;; r.sex = &quot;malemale&quot;; &#125; x = (++x) % 2; &#125; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; synchronized (r) &#123; System.out.println(&quot;name:&quot; + r.name + &quot;...&quot; + &quot;sex:&quot; + r.sex); &#125; &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args)&#123; //创建资源 Resource r = new Resource(); //创建任务 Input in = new Input(r); Output out = new Output(r); //创建线程，执行路径 Thread t1 = new Thread(in); Thread t2 = new Thread(out); //开启线程 t1.start(); t2.start(); &#125;&#125; 上面的代码中输入设置的是输入两个人名，需要注意的地方是，输入和输出类中加的锁是一样的，都是r，这个在测试类中，创建in、out对象时，要给他们传一样的参数。否则同步锁无用！ 但是这样的代码运行后还是不太好，因为输出的都是大片相同的人名，想让他们输入一个就输出一个，就需要使用线程的等待唤醒机制了。 等待唤醒机制 涉及方法 wait()：让线程处于冻结状态，被wait的线程会被存储到线程池中 notify()：唤醒线程池中的一个线程（任意） nitifyAll()：唤醒线程池中的所有线程 这些方法都必须定义在同步中，因为这些方法是用于操作线程状态的方法，必须要明确到底操作的是哪个锁上的线程 观察api文档后，为什么操作线程的方法wait、notify、notifyAll定义在Object类中那？ 因为这些方法是监视器的方法，监视器其实就是锁，锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//资源类public class Resource &#123; public String name; public String sex; public boolean flag = false;&#125;//输入类public class Input implements Runnable &#123; Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; synchronized (r) &#123; if (r.flag) &#123; try &#123; r.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (x == 0) &#123; r.name = &quot;小白&quot;; r.sex = &quot;女女女&quot;; &#125; else &#123; r.name = &quot;black&quot;; r.sex = &quot;malemale&quot;; &#125; r.flag = true; r.notify(); &#125; x = (++x) % 2; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; synchronized (r) &#123; if (!r.flag) &#123; try &#123; r.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;name:&quot; + r.name + &quot;...&quot; + &quot;sex:&quot; + r.sex); r.flag = false; r.notify(); &#125; &#125; &#125;&#125; 思路：输入数据之前判断一下是否有数据，如果有数据，控制输入的线程等待，先让控制输出的线程输出，输出数据后，将flag更改为false，意味着资源中数据为空，可以继续输入，然后再将控制输入的线程唤醒,自己（控制输出的线程）等待。这样就可以实现输入一个数据再输出一个数据了。 注意：输入输出的锁都是 r，等待唤醒中的线程池都是基于这个锁（也就是 r） 代码优化 上面的代码虽然最后实现了功能，但是封装性差,我们可以把输入，输出的方法定义在资源类中，在输入输出类中调用输入输出的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//资源类public class Resource &#123; private String name; private String sex; private boolean flag = false; //输入方法 public synchronized void set(String name,String sex)&#123; if (this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name; this.sex = sex; this.flag = true; this.notify(); &#125; //输出方法 public synchronized void out()&#123; if (!this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;name:&quot; + name + &quot;...&quot; + &quot;sex:&quot; + sex); this.flag = false; this.notify(); &#125;&#125;//输入类public class Input implements Runnable &#123; private Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; if (x == 0) &#123; r.set(&quot;小白&quot;,&quot;女女女&quot; ); &#125; else &#123; r.set(&quot;black&quot;, &quot;malemale&quot;); &#125; x = (++x) % 2; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; private Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; r.out(); &#125; &#125;&#125; 对共享资源修改的语句都写在了资源类中，可以给他们加同步锁，但是还是在方法中加上同步关键字看上去更简洁，这样他们加的锁还是同一个锁—&gt; this 。 生产者消费者问题 假设生产者生产产品，消费者消费产品，和上面进出资源的问题差不多 问题一 这里直接开始4个线程的，两个生产者，两个消费者，运行一下，会发现有错误，比如一个生产者生产完一件产品，消费者连着两次消费这一件产品。这类问题产生的原因是什么那？ t0、t1是生产者 t2、t3是消费者，让我们按照代码的顺序走一遍。 t0进行判断，生产产品（1），t0等待，t1进行判断，t1等待。t2进行判断，消费产品（1），t2等待，t3进行判断，t3等待。唤醒t0，t0没有进行判断，生产产品（2），t0等待。然后需要唤醒一个线程，但是这时线程池中有三个在等待，如果唤醒的是t1，t1没有进行判断直接生产产品（3），t1等待，唤醒t2，t2消费了产品（3），如果再唤醒t3，t3没有进行判断，就会再消费产品（3） 问题1产生原因：if判断标记，只有一次，会导致不该运行的线程运行了，出现了数据错误的情况 解决方法：将资源类中的输入输出方法的 if 判断改为 while 循环，这样就不会唤醒后跳过判断了，不过这样又会产生一个新的问题 问题二 问题2：4个线程都处在等待状态，没人去唤醒他们 产生原因：notify只能唤醒一个线程，如果本方唤醒本方，无意义，而且while+notify会导致死锁 解决办法：将资源类中的输入输出方法的唤醒改为全部唤醒（notifyAll）1234567891011121314151617181920212223242526272829303132333435//这里就只贴上资源类的代码了，其他类代码的写法和上面差不多//还需要有生产者类，消费者类 实现Runnable接口，和Test类//资源类public class Resource &#123; private String name; private int count = 1; private boolean flag = false; public synchronized void set(String name)&#123; while (this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); this.flag = true; this.notifyAll(); &#125; public synchronized void out()&#123; while (!this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); this.flag = false; this.notifyAll(); &#125;&#125; 问题三 解决了第二个问题后，已经不会报错了，但是还有些小弊端，使用notifyAll方法的时候会唤醒所有等待线程，但是如果唤醒了本方等待线程会降低效率，能不能只唤醒对方线程那？ 解决方法：使用jdk1.5新特性中的Lock Condition，可以创建多个监视器，该问题中，创建两个即可。关于Lock，Condition可以看该文章偏靠后的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;//资源类public class Resource &#123; private String name; private int count = 1; private boolean flag = false; public Lock lock = new ReentrantLock(); //通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者 public Condition producer_con = lock.newCondition(); public Condition consumer_con = lock.newCondition(); public void set(String name)&#123; //生产者 t0 t1 lock.lock(); try &#123; while (flag) &#123; try &#123; //该生产者线程进入等待状态 producer_con.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); flag = true; //唤醒随机一个消费者 consumer_con.signal(); &#125;finally &#123; //如果抛出异常，必须将关锁写在finally中 lock.unlock(); &#125; &#125; public void out()&#123; //消费者 t2 t3 lock.lock(); try &#123; while (!flag) &#123; try &#123; //该消费者进入等待状态 consumer_con.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); flag = false; //唤醒随机一个生产者 producer_con.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; locks包Lock接口 java.util.concurrent.locks.Lock Lock替代了同步代码块或者同步函数，将同步的隐式锁操作变成显式锁操作，同时更为灵活，可以一个锁加上多个监视器。 方法： lock()：获取锁 unlock()：释放锁，通常需要定义在finally代码块中 1234567//同步代码块对于锁的操作是隐式的Object obj = new Object();void show()&#123; synchronized(obj)&#123; ...code... &#125;&#125; 12345678//同步和锁被封装成了对象，并将操作锁的隐式方式定义到了该对象中//将隐式动作变为了显式动作。Lock lock = new ReentrantLock();void show()&#123; lock.lock();//获取锁 ...code... lock.unlock();//释放锁&#125; 如果上面代码第六行位置会抛异常的话，一定要将释放锁写在finally里123456789Lock lock = new ReentrantLock(); void show()&#123; lock.lock();//获取锁 try&#123; ...code... &#125;finally&#123; lock.unlock();//释放锁 &#125; &#125; Condition接口 Condition接口出现替代Object中的wait notify notifyAll等方法，将他们单独进行了封装，变成了Condition监视器对象，可以与任意锁进行组合 方法： await()：等待 signal()：唤醒 signalAll()：全部唤醒 1234567891011121314151617//旧版功能演示//在没有Lock，Condition之前，生产消费者问题只能创建一个监视器Object obj = new Object();synchronzied(obj)&#123; obj.wait(); obj.notify(); obj.notifyAll();&#125;//新版功能演示Lock lock = new ReectrantLock();//生产者的锁Condition producter_con = lock.newCondition();//消费者的锁Condition consumer_con = lock.newCondition();producter_con.await();producter_con.signal();producter_con.signalAll(); 范例123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class BoundedBuffer &#123; final Lock lock = new ReentrantLock();//锁对象 final Condition notFull =lock.newCondition();//写线程条件 final Condition notEmpty = lock.newCondition();//读线程条件 final Object[] items = new Object[100];//缓存队列 //下面是操作上面数组的变量（前两个指针） int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/; public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length)//如果队列满了 notFull.await();//阻塞写线程 items[putptr] = x;//赋值 if (++putptr == items.length) putptr = 0;//如果写索引写到队列的最后一个位置了，那么置为0 ++count;//个数++ notEmpty.signal();//唤醒读线程 &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0)//如果队列为空 notEmpty.await();//阻塞读线程 Object x = items[takeptr];//取值 if (++takeptr == items.length) takeptr = 0;//如果读索引读到队列的最后一个位置了，那么置为0 --count;//个数-- notFull.signal();//唤醒写线程 return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 这是一个处于多线程工作环境下的缓存区，缓存区提供了两个方法，put和take，put是存数据，take是取数据，内部有个缓存队列，具体变量和方法说明见代码，这个缓存区类实现的功能：有多个线程往里面存数据和从里面取数据，其缓存队列(先进先出后进后出)能缓存的最大数值是100，多个线程间是互斥的，当缓存队列中存储的值达到100时，将写线程阻塞，并唤醒读线程，当缓存队列中存储的值为0时，将读线程阻塞，并唤醒写线程，这也是ArrayBlockingQueue的内部实现。 下面分析一下代码的执行过程： 1、一个写线程执行，调用put方法； 2、判断count是否为100，显然没有100； 3、继续执行，存入值； 4、判断当前写入的索引位置++后，是否和100相等，相等将写入索引值变为0，并将count+1； 5、仅唤醒读线程阻塞队列中的一个； 6、一个读线程执行，调用take方法； 7、…… 8、仅唤醒写线程阻塞队列中的一个 如果不用多个 Condition ，只有一个Condition或者使用的同步代码块的内容时，当存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。 线程终止wait和sleep区别 wait可指定也可不指定时间，sleep必须指定时间 同步中时，对cpu的执行权和锁的处理不同 wait：释放执行权，释放锁 sleep：释放执行权，不释放锁 终止线程方式 停止线程： stop方法：不推荐使用 run方法结束 怎么控制线程中的任务结束那？ 任务中都会有循环结构，只要控制住循环就可以结束任务，控制循环通常就用定义标记来完成 123456789101112//通过在主函数中调用setFlag方法，即可终止线程public class StopThread implements Runnable&#123; private boolean flag = true; public void run()&#123; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; public void setFlag()&#123; flag = false; &#125;&#125; 但是使用这种方法也有一定的弊端，如果线程处于冻结状态无法读取标记，程序就不能停下来了 1234567891011//这样的程序无法终止public synchronized void run()&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; 可以使用interrupt()方法将线程从冻结状态强制恢复到运行状态中来，让线程具备cpu的执行资格，但是强制动作会发生InterruptedException异常，记得要处理 123456789101112131415161718192021222324252627282930313233343536373839public class StopThread implements Runnable&#123; private boolean flag = true; public synchronized void run()&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); //也可以选择在这里更改标记 //flag = false; &#125; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; public void setFlag()&#123; flag = false; &#125;&#125;public class StopThreadDemo &#123; public static void main(String[] args)&#123; StopThread s = new StopThread(); Thread t1 = new Thread(s); Thread t2 = new Thread(s); t1.start(); t2.start(); int num = 1; for(;;)&#123; if(++num == 50)&#123; //这里加上了interrupt方法 t1.interrupt(); t2.interrupt(); s.setFlag(); break; &#125; System.out.println(Thread.currentThread().getName()); &#125; &#125;&#125; 守护线程 setDaemon可以将线程变为守护线程（后台线程） 后台线程在运行时与前台线程无差别，前台线程终止时必须手动终止，如果前台线程都终止了，后台线程自动终止线程小方法join join方法也会抛出中断异常1234567891011121314//有线程t0、t1t0.start();t0.join();t1.start();System.out.println(&quot; &quot;);//运行结果一定是t0线程运行完，//运行main线程，再运行t1线程//情况2t0.start();t1.start();t0.join();System.out.println(&quot; &quot;); //运行结果：t0，t1互相抢占cpu，main等t0执行完再执行 线程优先值 可以给线程分配不同优先级的值，会让他们在执行中被执行几率增加 123456//t0为线程名t0.setPriority(Thread.MAX_PROIORITY);//为了方便，设置三个final值//MAX_PROIORITY = 10//MIN_PROIORITY = 0;//NORM_PROIORITY = 5; 两道多线程面试题 判断下面的程序是否能成功运行，如果不能，报错在哪一行 123456public class Test implements Runnable&#123; public void run(Thread t)&#123;&#125;&#125;//最后报错在第一行，第二行是子类的特有方法//在这个接口的实现类中没有覆盖run方法//报错解决：使用abstract修饰类或者覆盖run方法 判断下面程序，运行结果是什么？123456789101112131415public class ThreadTest &#123; public static void main(String[] main)&#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;我是任务里面的 &quot;); &#125; &#125;)&#123; public void run() &#123; System.out.println(&quot;我是子类里面的 &quot;); &#125; &#125;.start(); &#125;&#125;//现在的运行结果是“我是子类里面的”//如果注释掉8.9.10行，结果是“我是任务里面的”]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-异常]]></title>
    <url>%2F2018%2F05%2F03%2FJava-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[概述 异常：运行时期发生的不正常情况 在java中用类的形式对不正常情况进行了描述和封装对象 描述不正常的情况的类，被称为异常类 以前正常流程代码和问题处理代码相结合，现在将正常流程代码、问题处理代码分离，提高阅读性 其实异常就是java通过面向对象的思想将问题封装为对象，用异常类对其描述 不同类用问题用不同的类进行具体的描述，比如角标越界，空指针等等。 体系 问题很多，意味着描述的类也很多，将其共性进行向上抽取，形成了异常体系 最终问题就分成了两大类 Throwable：（直译：可抛的）问题发生应该就可以抛出，让调用者知道并处理 1、一般不可处理的 Error 2、可以处理的 Exception 该体系的特点就在于 Throwable 及其所有的子类都具有可抛性 可抛性是怎么体现的那？ 通过throws throw 这两个关键字所操作的类和对象都具备可抛性 该体系特点： 子类的后缀名都是用其父类名作为后缀，阅读性很强 Error JVM抛出的严重性问题，这种问题发生一般不针对性处理，直接修改程序 123456public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[1024*1024*800]; //java.lang.OutOfMemoryError: Java heap space &#125;&#125; Exception 分为两种： 编译时受检测异常：Exception和其子类都是，除了特殊子类RuntimeExcetion 这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。 编译不检测异常（运行时异常）：RuntimeExcetion和其子类 这种问题的发生，让功能无法继续，运算也无法进行，更多是因为调用的原因导致的，或者引发程序内部状态改变，导致的异常。这种问题一般不处理，直接编译通过，在运行时，调用者调用时引发异常从而程序强制停止，此时调用者即可对异常进行修正。 过程 运到识别的问题，对象进行封装 把问题抛给调用者 123456789101112131415161718public class Demo &#123; public int method(int[] arr,int index)&#123; if(arr == null) throw new NullPointerException(&quot;你咋空指针了&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;兄台，数组越界了，角标是：&quot;+index); return arr[index]; &#125;&#125;public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[3]; Demo d = new Demo(); d.method(arr, 30); &#125;&#125; 自定义异常 对于角标是整数不存在，可以用角标越界表示，对于负数角标的情况，准备用负数角标异常表示，但是这在Java中没有定义过，那就按照Java异常的创建思想，面向对象，将负数角标进行自定义描述，并封装成对象，这种自定义问题描述称为自定义异常。 注意：如果让一个类称为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性。才可以被两个关键字所操作 throws throw 12345678910111213141516171819202122232425262728 class FuShuIndexException extends Exception&#123; FuShuIndexException()&#123;&#125; FuShuIndexException(String msg)&#123; Super(msg); &#125; &#125; class Demo&#123; public int method(int[] arr,int index) throws FuShuIndexException&#123; if(arr==null) throw new NullPointerException(&quot;数组的引用不能为空&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;数组角标越界=&quot; + index); if(index &lt; 0) throw new FuShuIndexException(); return arr[index]; &#125; &#125; public class ExceptionDemo &#123; public static void main(String[] args) throws FuShuIndexException &#123; int[] arr = new int[3]; Demo d = new Demo(); d.method(arr, -1); &#125; &#125; 自定义的异常，要么继承Exception,要么继承RuntimeException 抛出 throw throw和throws区别： throws使用在函数上，抛出的是异常类，可以跑出多个，用逗号隔开 throw使用在函数内，抛出的是异常对象 捕捉 catch 可以对异常进行针对性处理的方式 12345678具体格式： try&#123; //需要被检测异常的代码 &#125;catch(异常类 变量)&#123; //该变量用于接收发生的异常对象 //真正处理该异常的代码 &#125;finally&#123; //一定会被执行的代码 &#125; 下面是演示代码 12345678910111213141516171819202122232425262728public class Demo &#123; public int method(int[] arr,int index)&#123; if(arr == null) throw new NullPointerException(&quot;你咋空指针了&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;兄台，数组越界了，角标是：&quot;+index); return arr[index]; &#125;&#125;public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[3]; Demo d = new Demo(); try &#123; int num = d.method(null, 30); System.out.println(num); &#125;catch (NullPointerException e)&#123; System.out.println(e.toString()); &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;message:&quot;+e.getMessage()); System.out.println(&quot;String:&quot;+e.toString()); //e.printStackTrace();//Jvm默认处理机制就是调用异常这个方法 System.out.println(&quot;越界&quot;); &#125;/*catch (Exception e)&#123; //多catch，父类的catch放在最下面 &#125;*/ &#125;&#125; finally代码块 除了在catch中强制关闭JVM的情况下，finally中的语句都会被执行 123456789101112131415161718/* 情况1： 运行结果：finally*/try &#123; //需要被检测异常的代码&#125;catch (NullPointerException e)&#123; //处理异常的代码 return;&#125;finally&#123; //通常用于关闭（释放）资源 System.out.println(&quot;finally&quot;);&#125;System.out.println(&quot;Over&quot;);/* 情况2：去掉第9行的return后，运行 结果：finally Over*/ try catch finally 代码组合特点 1、try catch finally 2、try catch（多个） 没有必要资源需要释放时，可以不用定义finally 3、try finally 异常无法直接处理，但是资源需要关闭 123456try&#123; //开启资源 throw new Exception;&#125;finally&#123; //关闭资源&#125; 异常处理原则 1、函数内部如果抛出需要检测的异常，函数上必须要声明，否则必须在函数内用trycatch捕捉，否则编译失败 2、如果调用到了声明异常的函数，要么trycatch，要么throws，否则编译失败 3、什么时候catch，什么时候throws那？ 功能内容可以解决，用catch 解决不了，用throws告诉调用者，由调用者解决 4、一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理，内部有几个需要检测的异常，就抛几个异常，抛出几个，就catch几个 异常应用 用Java描述老师上课，需要电脑，电脑会出现蓝屏冒烟两种故障 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class LanPingException extends Exception &#123; LanPingException(String msg)&#123; super(msg); &#125;&#125;public class MaoYanException extends Exception &#123; MaoYanException(String msg)&#123; super(msg); &#125;&#125; public class Computer &#123; private int state = 0; public void run() throws LanPingException, MaoYanException &#123; if (state == 1) throw new LanPingException(&quot;蓝屏&quot;); if (state == 2) throw new MaoYanException(&quot;冒烟&quot;); System.out.println(&quot;computer run&quot;); &#125; public void reset()&#123; state = 0; System.out.println(&quot;电脑重启&quot;); &#125;&#125;public class Teacher &#123; private String name; private Computer comp; public Teacher(String name)&#123; this.name = name; comp = new Computer(); &#125; public void prolect() throws MaoYanException&#123; try &#123; comp.run(); System.out.println(name+&quot;讲课&quot;); &#125;catch (LanPingException e)&#123; e.getMessage(); comp.reset(); prolect(); &#125;catch (MaoYanException e)&#123; System.out.println(e.toString()); practice(); throw e; &#125; &#125; public void practice()&#123; System.out.println(&quot;电脑坏了，大家练习&quot;); &#125;&#125;public class Demo &#123; public static void main(String[] args)&#123; Teacher t = new Teacher(&quot;cheng&quot;); try &#123; t.prolect(); &#125; catch (MaoYanException e) &#123; System.out.println(&quot;......&quot;); &#125; &#125;&#125; 数据库连接出现异常怎么解决那 123456789101112131415class NoAddException extends Exception&#123;&#125;void addData(Data d) throws NoAddException&#123; 连接数据库 try&#123; 添加数据，出现异常 &#125;catch(NoAddException e)&#123; //处理代码 throw new NoAddException(); &#125;finally&#123; 关闭数据库 &#125;&#125; 注意事项 1、子类在覆盖父类方法的时候，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常，或者该异常的子类 2、如果父类抛出多个异常，子类只能抛出父类异常的子集 简而言之：子类覆盖父类方法时，只能抛出父类异常或异常子类或子集 注意：若父类方法没抛出异常，子类覆盖时绝对不能抛出异常，只能try]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-Object类]]></title>
    <url>%2F2018%2F05%2F03%2FJava-Object%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类 Object ：所有类的根类 Object 是抽取而来的，具备着所有对象都具备的共性内容 常用的共性内容： equals 方法 hashCode 方法 getClass 方法 toString 方法equals方法 equals 实现对象上差别可能性最大的相等关系，即，对于任何非空引用值 x 和 y ，当且仅当 x 和 y引用同一个对象时，此方法才返回 true （x==y 具有值 true） 12345678910111213141516public class Person &#123; private int age; public Person(int age)&#123; this.age = age; &#125;&#125;public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); Person p2 = new Person(20); Person p3 = p1; System.out.println(p1==p2); System.out.println(p1.equals(p2)); System.out.println(p1.equals(p3)); &#125;&#125; equals 方法重写，比较成员变量值 123456789101112131415161718public class Person &#123; private int age; public Person(int age)&#123; this.age = age; &#125; /* 一般都会覆盖此方法，根据对象的特有内容，建立判断对象是否相同的依据 */ public boolean equals(Object obj)&#123;//会将参数中的对象进行向上转型 //为了提高程序鲁棒性，进行判断 if (!(obj instanceof Person))&#123; throw new ClassCastException(&quot;类型错误&quot;); &#125; //为了使用子类的私有方法，进行向下转型 Person p = (Person) obj; return this.age == p.age; &#125;&#125; hashCode方法 先演示一下功能，发现运行后的结果很相似，发现hashCode的结果是16进制地址值的10进制数。 1234567891011public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); System.out.println(p1); System.out.println(p1.hashCode()); System.out.println(Integer.toHexString(p1.hashCode())); //Person@1540e19d //356573597 //1540e19d &#125;&#125; hashCode可以进行重写，在person类中加入如下的代码，ObjectDemo运行的结果会发生变化 123456public int hashCode()&#123; return age; &#125; //Person@14 //20 //14 getClass方法 字节码文件是经过编译器预处理过的一种文件，是JAVA的执行文件存在形式，它本身是二进制文件，但是不可以被系统直接执行，而是需要虚拟机解释执行，由于被预处理过，所以比一般的解释代码要快，但是仍然会比系统直接执行的慢 人中抽出Person，class抽取出Class（字节码文件类名）12345678910public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); Person p2 = new Person(40); Class claz1 = p1.getClass(); Class claz2 = p2.getClass(); System.out.println(claz1.equals(claz2)); //true &#125;&#125; toString方法 这是一个改写字符串方法 1234567public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); System.out.println(p1); System.out.println(p1.getClass().getName()+&quot;@&quot;+Integer.toHexString(p1.hashCode())); &#125;&#125; 运行结果：Person@1540e19d Person@1540e19d 其实这就是没改写前方法的功能，我们也可以自己进行改写 123public String toString()&#123; return &quot;Person:&quot;+age; &#125; 这样改写后输出 p1 的结果就是 Person:20]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类]]></title>
    <url>%2F2018%2F04%2F27%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类概述 内部类 如其名，就是类的内部定义的一个类 内部类访问特点 内部类可以直接访问外部类的成员 外部类要访问内部类，必须建立内部类的对象 一般用于类的设计 分析事物时，发现该事物描述中还有事物，而且这个事物还在访问被描述的事物，这时就把含有的事物定义成内部类来描述 修饰符 如何直接访问外部类中的内部类的成员1234567891011121314public class Outer &#123; private int num = 3; public class Inner &#123; void show()&#123; System.out.println(&quot;num = &quot;+num); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; Outer.Inner in = new Outer().new Inner(); in.show(); &#125;&#125; static 如果内部类是静态的，该如何访问内部类方法123456789101112131415161718192021public class Outer &#123; private int num = 3; public static class Inner &#123; void show()&#123; System.out.println(&quot;num = &quot;+num); &#125; //如果内部类中定义了静态成员，该内部类必须也是静态的 static void fun()&#123; System.out.println(&quot;fun&quot;); &#125; &#125; &#125; public class Test &#123; public static void main(String[] args)&#123; //如果内部类是静态的，相当于一个外部类 Outer.Inner in = new Outer.Inner(); in.show(); //如果内部类是静态的，成员是静态的 Outer.Inner.fun(); &#125; &#125; 细节 观察如下代码判断运行结果 123456789101112131415161718192021public class Outer &#123; private int num = 3; public class Inner &#123; int num = 4; public void show()&#123; int num = 5; System.out.println(num); System.out.println(this.num); System.out.println(Inner.this.num); System.out.println(Outer.this.num); &#125; &#125; public void method()&#123; new Inner().show(); &#125; &#125;public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125; &#125; 结果是：5 4 4 3 为什么内部类能直接访问外部类中成员那？ 那是因为内部类持有了外部类的引用。 外部类名.this 局部内部类 内部类可以存放在局部位置上 内部类在局部变量位置上只能访问局部中被final修饰的局部变量12345678910111213141516171819public class Outer &#123; private int num = 3; public void method()&#123; //如果不加final，会报错 final int x = 9; public class Inner &#123; public void show()&#123; System.out.println(x); &#125; &#125; Inner in = new Inner(); in.show(); &#125; &#125; public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125; &#125; 匿名内部类 匿名内部类，就是内部类的简写格式 前提：内部类必须继承或实现一个外部类或接口 匿名用户类：其实就是一个用户匿名子对象 格式：new 父类or接口 (){ 子类内容 通常使用场景之一： 当函数参数是接口类型时，而且接口中的方法不超过三个，可以用匿名内部类作为实际参数进行传递123456789101112131415161718192021222324interface inter&#123; public void show1(); public void show1();&#125;class Outer&#123; public void method()&#123; /*可以这么写 new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125;*/ //也可以这么写 inter in = new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125; /*居然还可以这么写 new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125;.show1(); */ &#125;&#125; 小细节静态问题 试试能不能编译如下代码 1234567891011public class InnerClassDemo &#123; class Inner&#123; &#125; public static void main(String[] args)&#123; new Inner(); &#125; public void method()&#123; new Inner(); &#125;&#125; ‘InnerClassDemo.this’ cannot be referenced from a static context 为什么 method 也写了同样的内容却没有报错？ 因为 main 是静态的，只能直接调用静态成员 转型问题 运行如下代码，将注释1取消注释，观察结果，再注释掉1，取消掉注释2，观察结果 123456789101112131415161718192021222324public class Outer &#123; public void method()&#123; /*注释1 new Object()&#123; public void show()&#123; System.out.println(&quot;i can run&quot;); &#125; &#125;.show(); */ /*注释2 Object obj = new Object()&#123; public void show()&#123; System.out.println(&quot;i can run&quot;); &#125; &#125;; obj.show(); */ &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125;&#125; 为什么第一次编译运行正确，第二次编译错误？ 因为匿名内部类这个子类对象被向上转型为 object 类型，这样就不能再使用子类特有的方法了]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多态]]></title>
    <url>%2F2018%2F04%2F27%2FJava%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[对象的多态性 以代码为示例 1234567891011121314151617public class Animals &#123; public void speak()&#123; System.out.println(&quot;i am animals&quot;); &#125;&#125;public class Cat extends Animals&#123; public void speak()&#123; System.out.println(&quot;i am cat&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; //一个对象，两种形态 Animals cat = new Cat(); cat.speak(); &#125;&#125; 运行后的结果为”i am cat” 猫这类事物既具备猫的形态，又具备动物形态，这就是对象的多样性，简单说，一个对象对应着多种类型 多态在代码中的体现 父类或者接口的引用指向了其子类的对象 多态的好处 提高了代码扩展性，前期定义的代码可以使用后期的内容。 123456789101112131415161718192021222324252627282930313233public abstract class Animals &#123; public abstract void eat();&#125;public class Cat extends Animals&#123; public void eat()&#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse()&#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125;public class Dog &#123; public void eat()&#123; System.out.println(&quot;啃骨头&quot;); &#125; public void guardDoor()&#123; System.out.println(&quot;看门&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; Cat c1 = new Cat(); Dog d1 = new Dog(); Dog d2 = new Dog(); method(c1); method(d1); method(d2); &#125; public static void method(Animals a)&#123; a.eat(); &#125;&#125; 如上图所示代码，如果很多只猫，很多只狗，为了代码复用性，需要在主类中定义一个方法，可是如果动物种类很多，是否要定义不同参数的许多方法那，答案是不用的，只需要定义个参数为Animals对象的即可 多态的局限性及前提 前期定义的内容，不能调用后期子类定义的特有内容 多态的前提 必须有关系，继承，实现 要有覆盖 多态转型 123456789101112131415//自动类型提升，猫对象提升了动物类型，但特有功能无法访问//作用就是限制对猫特有功能的访问//专业讲就是 向上转型，将子类型隐藏，就不用使用子类的特有方法Animals a = new Cat();a.eat();//如果还想访问具体动物的特有功能//可以进行向下转型Cat c = (Cat)a;//向下转型目的：为了使用子类中的特有方法c.eat();c.catchMouse();//错误示例Animals a1 = new Dog();Cat c1 = (Cat)a1; //ClassCastException类型转换异常 注意：对于转型来说，自始至终都是子类对象在做着类型的变化 类型判断 还是以之前的代码为示例，如果method方法内想进行输出猫，狗的特有功能该怎么做那？123456789101112public void method(Animals a)&#123; a.eat(); if(a instanceof Cat)&#123; //instanceof：用于判断对象的具体类型，只能用于引用数据类型判断 //通常在向下转型前用于健壮性的判断 Cat c = Cat(a); c.catchMouse(); &#125;else if(a instanceof dog)&#123; Dog d = Dog(a); d.guardDoor(); &#125;&#125; 多态时成员特点成员变量 编译时：参考引用型变量所属的类中是否有调用的成员变量，有则编译通过，没有则编译失败 运行时：参考引用型变量所属的类中是否有调用的成员变量，并运行该所属类中的成员变量 编译和运行都参考左边，如 animals a = new Cat(); 成员函数（非静态） 编译时：参考引用型变量所属的类中是否有调用的函数，有则编译通过，没有则编译失败 运行时：参考对象所属的类中是否有调用的函数， 简单说：编译看左边，运行看右边 1234567891011121314public class Father &#123; public void show()&#123; System.out.println(&quot;i am father&quot;); &#125;&#125;public class Son extends Father&#123; public void show() &#123; System.out.println(&quot;i am son&quot;); &#125;&#125;public class Test()&#123; Father f = new Son(); f.show();&#125; 运行后的结果 i am son 静态函数 编译时：参考引用型变量所属的类中是否有调用的静态方法，有则编译通过，没有则编译失败 运行时：参考对象所属的类中是否有调用的静态方法 简单说：编译和运行都看左边 其实对于静态方法，是不需要对象的，直接类名调用即可 1234567891011121314public class Father &#123; public static void show()&#123; System.out.println(&quot;i am father&quot;); &#125; &#125; public class Son extends Father&#123; public static void show() &#123; System.out.println(&quot;i am son&quot;); &#125; &#125; public class Test()&#123; Father f = new Son(); f.show(); &#125; 运行结果为 i am father]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承及接口]]></title>
    <url>%2F2018%2F04%2F21%2FJava%E7%BB%A7%E6%89%BF%E5%8F%8A%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[继承 什么时候继承？ 当类中存在所属关系时，就定义继承。狗和狼都是犬科，所以他们都可以继承犬科 所属关系：is a 关系 谁是谁中的一种 优点 提高代码复用性 让类与类之间产生了联系，为多态提供了前提 缺点 打破封装性 解决方法看下面的final关键字 注意 Java中支持单继承，不直接支持多继承，但对C++中多继承进行了改良 单继承：一个子类只能有一个父类 多继承：一个子类可以有多个父类（Java不直接支持，但是改良了） 因为如果多个父类中有相同成员，会产生调用的不确定性（Java中通过”多实现”的方式） Java支持多重继承 继承体系 C继承B，B继承A，就会出现继承体系 如何使用 创建该子类中的顶层类，了解该体系的基本使用功能 创建体系中的最子类对象，完成功能的使用 子父类中成员特点 子父类中，成员的特点体现 成员变量 成员函数 构造函数 成员变量 本类中成员和局部变量同名用this区分 子父类中的成员变量用super区分 this super 用法很相似 this 代表一个本类对象的引用 super 代表一个父类空间 子类不能直接访问父类中私有的内容 成员变量内存图解 以如下代码为例123456789101112131415public class Father&#123; int num = 4;&#125;public class extends Son&#123; int num = 5; void show()&#123; System.out.println(this.num+super.num); &#125;&#125;public class Demo&#123; public static void main(Sting[] args)&#123; Son s = new Son(); s.show(); &#125;&#125; 运行Demo类，main方法进栈，执行下一句话，创建一个子类对象，因为它是继承的父类，所以方法区需要先加载父类函数及构造方法，再加载子类构造方法。接下来在堆中开辟空间，给予地址，num值在父类子类中都有体现，所以存储时num值系统会通过关键字标注好。show方法入栈，this关键字指向son的num，super关键字指向father的num。 成员函数特点（覆盖） 当子父类中出现成员函数一模一样的情况，会运行子类的函数，这种现象就是覆盖操作，这是函数在子父类中的特性。 函数两个特性 重载：同一个类中 overload 覆盖：子类中，也成为重写，复写 override 注意事项： 子类方法覆盖父类方法时，子类权限必须大于等于父类权限才可以引发覆盖 静态只能覆盖静态，或被静态覆盖 什么时候使用覆盖操作？ 当对一个类进行子类的扩展时，子类需要保留父类的功能声明，但是要定义子类中该功能的特有内容时，就使用覆盖操作完成 成员函数特点应用 观察下面的代码，Phone类拥有两个方法，现在需要在他的基础上更改增加show方法的功能，就可以采用成员函数覆盖的方法 为什么不更改原代码的函数？为了安全起见，如果出错，那样很难复原。1234567891011121314151617181920212223public class Phone&#123; public void call()&#123;&#125; public void show()&#123; System.out.println(&quot;number&quot;); &#125;&#125;public class newPhone extends Phone&#123; public void call()&#123; super.call()； &#125; public void show()&#123; super.show(); System.out.println(&quot;name&quot;); System.out.println(&quot;picture&quot;); &#125;&#125;public class Demo&#123; public static void main()&#123; newPhone p = new newPhone(); p.call(); p.show(); &#125;&#125; 子父类中的构造函数子类的实例化过程 看下图代码，运行主函数后会是怎么样的结果 123456789101112131415public class Father &#123; Father()&#123; System.out.print(&quot;Father&quot;); &#125;&#125;public class Son extends Father &#123; public Son()&#123; System.out.print(&quot;Son&quot;); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; new Student(); &#125;&#125; 运行结果FatherSon，有Son我们理解，调用的是Son类，可是为什么有Father啊 特点 在子类构造对象时，发现访问子类构造参数时，父类也运行了，Why？ 在子类的构造函数第一行有一个默认的隐式语句。super(); 子类中所有的构造函数默认都会访问父类中的空参构造函数 细节 为什么子类实例化的时候，要访问父类中的构造函数那？ 那是因为子类继承了父类，获取到了父类中的内容（属性），所以在使用父类内容之前要先看父类是如何对自己的内容进行初始化的。所以子类在构造对象时，就必须访问父类中的构造函数。为了完成这个必须的动作，就在子类的构造函数中加入了super语句。如果父类中没有定义空参数构造函数，那么子类的构造函数必须用super明确要调用父类中的那个构造函数。 super语句必须要定义子类构造函数第一行。因为父类的初始化动作要先完成 如下面代码所示，子类构造函数中如果使用this调用了本类构造函数时，那么super没有了，因为super和this都只能定义在第一行，不过可以保证的是，子类中肯定会有其他构造函数访问父类的构造函数和数据 12345678910111213141516public class Father &#123; Father()&#123; System.out.print(&quot;F&quot;); &#125; &#125;public class Son extends Father &#123; Public Son()&#123; super(); System.out.print(&quot;Son1&quot;); &#125; public Son(int x)&#123; this(); //super(); System.out.print(&quot;Son2&quot;); &#125;&#125; 所有的类在创建时其实都是继承的object类,如下图的Demo类，注释掉的内容都是自动生成的隐式 123456789class Demo //extends object()&#123; /* Demo()&#123; super(); return; &#125; */&#125; 图解 以下面代码为示,123456789101112131415161718192021222324252627282930313233public class Father &#123; Father()&#123; //super(); show(); //return; &#125; public void show()&#123; System.out.println(&quot;Father show&quot;); &#125;&#125;public class Son extends Father&#123; int num = 8; public Son()&#123; super(); //-&gt;通过super初始化父类内容时，子类的成员变量并未显示初始化。 //等super()父类初始化结束后，才对子类成员变量初始化 return; &#125; public void show() &#123; System.out.println(&quot;Son show &quot;+num); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Son s = new Son(); s.show(); &#125;&#125;/*运行结果：Son show 0 Son show 8*/ 过程 一个对象的实例化过程 1、JVM会读取指定路径下的Person.class文件，并加载进内存，并会加载Person的父类（如果有直接父类的情况下） 2、在堆内存中开辟空间，分配地址 3、并在对象空间中，对对象中的属性进行默认初始化 4、调用相应的构造函数进行初始化 5、在构造函数中，第一行会先调用父类中构造函数进行初始化 6、父类在初始化完毕后，再对子类的属性进行显示初始化 7、再进行子类函数的构造初始化 8、初始化完毕后，将地址值赋给引用变量 final关键字 1、final是一个修饰符，可以修饰类，方法，变量 2、final修饰的类不可以被继承，该类为最终类 3、final修饰的方法不可以被覆盖 4、final修饰的变量是一个常量，只能赋值一次 为什么使用final修饰变量？ 其实在程序中如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差，所以应该给这个数据起个名称。而且这个变量名称的值不能变化，所以加上final固定 final应用 如下面的圆周率想定义后不被人修改，即可加上final修饰 注：被修饰后变量即是常量，表示方法为 “所有单词都大写，如果多个单词，中间用_连接” 注：final修饰的变量必须手动进行初始化，且前面一般加上static，方便调用123456class Circle&#123; static final double PI = 3.14; void method()&#123; System.out.println(PI); &#125; &#125; 抽象类 抽象：笼统，模糊，不具体 特点 1、方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰。抽象方法必须定义在抽象类中，该类也必须被abstract修饰 2、抽象类不可以被实例化，不可以被new 创建对象。因为调用抽象方法无意义 3、抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化，否则这个子类还是抽象类 细节 1、抽象类中有构造函数吗？ 有，用于给子类对象初始化 2、抽象类可以不定义抽象方法吗？ 可以，但是很少见，目的是不让该类创建对象。AWT的适配器对象就是这种类。通常这个类中的方法有方法体，但是没有内容 3、抽象关键字不可以和哪些关键字共存？ private 抽象方法需要被覆盖，加上私有不能覆盖 static 加上静态后可以用类调用方法，但是抽象方法运行无意义 final final修饰后不能被继承，抽象类或方法就没有用了 4、抽象类与一般类的异同点？ 抽象类和一般类都是用来描述事物的，都在内存定义了成员 一般类有足够信息描述事物，抽象类描述事物信息一般都不足 一般类中不能定义抽象方法，抽象类中可定义抽象方法或非抽象方法 一般类能被实例化，抽象类不可以被实例化 5、抽象类一定是父类吗？ 是的，因为需要子类覆盖其方法后，才可以对子类实例化 接口定义 当一个抽象类中的方法都是抽象类的时候，可以将该抽象类用另一种形式定义和表示，就是接口 interface。 定义接口使用的关键字不是class 是interface 接口当中常见的成员：（这些成员都有固定的修饰符，都是公共权限） 全局常量：public static final 抽象方法：public static 实现 类与类之间是继承方式，类与接口之间是实现方式 1234567891011121314151617181920public interface Demo&#123; public static final int NUM = 1; public static void show1(); public static void show2();&#125;public class DemoImpl implements Demo&#123; public void show1() &#123;&#125; public void show2() &#123;&#125;&#125;public class Test&#123; public static void main(String[] args)&#123; DemoImpl d = new DemoImpl(); //下面三行语句都正确 System.out.println(d.NUM); System.out.println(DemoImpl.NUM); System.out.println(Demo.NUM); &#125;&#125; 接口不可以实例化，只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化，否则，这个就是一个抽象类 多实现 Java中不直接支持多继承，因为会出现调用的不确定性，所以Java将多继承机制进行改良，在Java中变成了多实现 一个类支持多个接口 一个类在继承另一个类的同时，还可以实现多个接口 123456789101112131415161718public interface A&#123; public abstract void show1();&#125;public interface B&#123; public abstract void show2();&#125;public class Q&#123; public void method() &#123;&#125;&#125;//Test类继承Q类意味着他们属于一个体系//实现A,B接口是为了扩展功能class Test extends Q implements A,B&#123; public void show1() &#123;&#125; public void show2() &#123;&#125;&#125; 接口的出现避免了单继承的局限性，一个类 注意 接口与接口之间是继承关系，而且接口之间可以多继承 Java不能多继承的原因是因为方法体导致的运行不确定性，不过接口无方法体，所以接口可以多继承 接口类型的引用，都是指向自己类型子类的对象 特点 接口是对外暴露的规则 接口是程序的功能扩展 接口的出现降低耦合性 接口可以用来多实现 类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口 接口与接口之间可以有继承关系 接口抽象类区别 相同点：都是向上不断抽取而来 不同点： 抽象类： 抽象类需要被继承，且只能单继承 抽象类可以定义抽象方法和非抽象方法，子类继承后可以直接使用抽象方法 抽象类继承是 is a 关系，是在定义该体系的基本共性内容 接口： 接口需要被实现，可以多实现 接口只能定义抽象方法，必须由子类去实现 借口实现是 like a 关系，在定义体系的额外功能]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java单例模式]]></title>
    <url>%2F2018%2F04%2F21%2FJava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式 解决问题：可以保证一个类在对象中唯一性 必须对于多个实例使用同一个配置信息对象时，就需要保证该对象唯一性 如何保证对象唯一性？ 不允许其他程序使用new创建对象 在该类创建一个本地实例 对外提供一个方法让其他程序可以获取该对象 步骤： 私有化该类构造函数 通过new在本类中创建一个本类对象 定义一个公有的方法，将创建的对象返回 饿汉式 代码展示 12345678910111213141516//饿汉式public class Single &#123; //类加载进来时，对象就已经生成了 private static Single s = new Single(); private Single()&#123;&#125; public static Single getInstance()&#123; return s; &#125;&#125;public class Demo&#123; `public static void main(String[] args)&#123; Single s1 = Single.getInstance(); Single s2 = Single.getInstance(); System.out.println(s1 == s2); &#125;&#125; 工作中常常使用的一种单例模式，安全性好 懒汉式 代码展示 123456789101112// 懒汉式public class Single2 &#123; //类加载时没有对象生成，只有调用了getInstance方法后才会创建对象 //延迟加载程序 private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null) s = new Single2(); return s; &#125;&#125; 常见于面试中，涉及知识点较多 内存图示（饿汉式为例） main进栈，s1对象生成，方法区，single构造函数进入，静态区，single s getInstance进入，堆中开辟一块空间，赋予0x0045地址，静态区中s指向堆中地址。get方法进栈，s1地址指向0x0045，get出栈。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编写工具类及API文档]]></title>
    <url>%2F2018%2F04%2F18%2FJava%E7%BC%96%E5%86%99%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%8F%8AAPI%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[昨天学习了如何编写一个工具类，及如何给他注释再去生成专属于他的API文档。今天我将这个过程以及一些遇到的报错解决整理到博客中。 编写Java工具类（以数组工具类为例） 工具类中包含了一些简单的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** *这是一个可以对数组进行操作的工具类，该类中提供了如最值获取，排序等功能。 * @author Orange * @version 1.0 */ public class ArrayTool &#123; // private ArrayTool()&#123;&#125; /** *获取一个整型数组中的最大值 * @param arr 接收一个 int 类型的数组 * @return 会返回一个该数组中最大值 */ public static int getMax(int[] arr)&#123; selectSort(arr); int max = arr[0]; for(int i=0 ;i&lt;arr.length; i++)&#123; if(arr[i]&gt;max) max = arr[i]; &#125; return max; &#125; /** * 给int数组进行选择排序。 * @param arr 接收一个 int 类型的数组 */ public static void selectSort(int[] arr)&#123; for(int i=0 ;i&lt;arr.length-1; i++)&#123; int number = arr[i]; int index = i; for(int j=i+1;j&lt;arr.length;j++)&#123; if(number&gt;arr[j])&#123; number = arr[j]; index = j; &#125; &#125; if(index != i) swap(arr,i,index); &#125; &#125; //因为 swap 方法是 priavte ，所以只写普通注释就可以了 //给数组中元素进行位置的置换 private static void swap(int[] arr,int a,int b)&#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; /** * 将 int 形式的数组转换成字符串形式。打印形式是[s1,s2,s3,.....] * @param arr 接收一个 int 类型的数组 * @return 返回该 int 数组的字符串表现形式 */ public static String ArrayToString(int[] arr)&#123; String str = &quot;[&quot;; int point = 0; for(int i=0 ;i&lt;arr.length ;i++)&#123; if(i != arr.length-1) str = str + arr[i] + &quot;,&quot;; else str = str + arr[i] + &quot;]&quot;; &#125; return str; &#125; &#125; 注释的添加 Java文档注释|菜鸟教程 javadoc工具软件 javadoc 语法 javadoc [ options ] [ packagenames ] [ sourcefiles ] [ @files ] DOS界面使用javadoc编写API WIN-R 运行 cmd 进入 DOS 界面 通过使用CMD的命令进入包含该java工具类的文件夹 输入：javadoc -d myhelp -author -version ArrayTool.java 效果展示 报错编码GBK的不可映射字符 解决方法 关闭编译器要编写的那个工具类 用记事本打开 Java 源文件 另存为，选择 ANSI 编码 覆盖后，在DOS界面重试 成功后，将编码改回原格式 错误2 生成错误原因：改为ANSI编码后，打开了编译器，汉字都变成了乱码 切记，记事本改完编码后，不要。立即用编辑器打开该文件]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java构造函数及关键字]]></title>
    <url>%2F2018%2F04%2F15%2FJava%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[构造函数 简单说，构造函数就是构建创造对象时调用的函数 创建对象都必须要通过构造函数初始化，一个类如果没有定义过构造过程，会有一个默认空参构造函数。若定义了指定的构造函数，那么类中默认构造函数就会消失。 特点 函数名与类类名相同 不能返回值类型 没有具体返回值 区别 构造函数 对象创建时，会掉用与之相应的构造函数，对对象进行初始化 对象创建时，会调用且仅调用一次 一般函数 对象创建后，需要使用函数功能时才调用 对象创建后，可调用多次 重载 当一个类中出现多个构造函数时，必须以重载形式体现 内存图解 接下来用下面这段代码，来演示内存变化过程12345678910111213141516public class Person &#123; private String name; private int age; Person()&#123;&#125;; Person(String name,int age)&#123; this.name = name; this.age = age; &#125; public void speak()&#123; System.out.println(name+&quot;:&quot;+age); &#125; public static void main(String[] args)&#123; Person person = new Person(&quot;jack&quot;,20); person.speak(); &#125;&#125; 左面是栈内存，右面是堆内存。首先在栈内存运行main函数，创建名字为p的对象，然后栈内存调用了有参构造函数。在堆内存中开辟一片区域，给予其地址，将构造函数中的值寻址赋给堆中变量的值，然后将构造函数弹栈。将堆内存中的地址赋给p。 然后在栈中入栈speak方法，运行后寻址输出变量值this关键字 当成员变量和局部变量重名，可用关键字this区分 this代表对象，一般当前对象，this代表其所在函数所属对象的引用12345678class Person &#123; Person(String name)&#123; this.name = name; &#125; public static void main()&#123; Person p = new Person(name); &#125;&#125; 功能 this也可用于在构造函数中调用其他构造函数 注：只能定义在构造函数第一行，因为初始化动作要先执行 12345678910class Person &#123; Person()&#123;&#125; Person(String name)&#123; this.name = name; &#125; Person(String name,int age) &#123; this(name); this.age = age; &#125;&#125; 当执行主函数中的语句时，调用有参构造函数，此时this.name就是代指对象p 简单来说，哪个对象调用this所在的函数，this就代表哪个对象注意事项 运行下面的代码失败，死循环12345678910111213class Person &#123; Person()&#123; this(jack); &#125; Person(String name)&#123; this(); this.name = name; &#125; Person(String name,int age) &#123; this(name); this.age = age; &#125;&#125; 内存图解 接下来通过下面的代码来演示更加完整的过程12345678910111213141516171819public class Person &#123; private String name; private int age; Person(String name)&#123; this.name = name; &#125; public void speak()&#123; System.out.println(name+&quot;:&quot;+age); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Person p = new Person(&quot;rose&quot;); p.speak(); Person p1 = new Person(&quot;dell&quot;); p1.speak(); &#125;&#125; 首先在栈内存运行main函数，创建名字为p的对象，然后栈内存调用了有参构造函数。在堆内存中开辟一片区域，给予其地址后初始化数值，构造函数中的this起到了作用，指向p对象的地址，将 name=”jack” 传到堆中更改值，然后将构造函数弹栈。将堆内存中的地址赋给p。speak函数入栈也是通过this寻址堆中赋值。 小练习（双人年龄比较） 思路：在Person类中写一个boolean类型方法，巧妙地利用this就可以compare方法中只带一个参数。 123public boolean compare(Person p)&#123; return this.age == p.age ; &#125; 主类中如何使用？ 123Person p1 = new Person();Person p2 = new Person();p1.compare(p2); static关键字特点 static是一个修饰符，用来修饰成员 static修饰成员被所有对象共享 static优先于对象存在（static随类的加载就已经存在了） static修饰的成员多了一种调用格式，可以直接被类名调用。如：类名.静态成员 static修饰的是共享数据 对象中存储的是特有数据成员变量、静态变量区别 区别： 生命周期不同 调用方式不同 别名不同 数据存储位置不同 成员变量： 随对象创建存在，随其回收而释放 只能被对象调用 实例变量 存在堆内存的对象中，也叫对象的特有数据 静态变量： 随着类加载而存在，随着类消失而消失 可以对象调用，也可以类调用 类变量 存放在方法区（也叫共享数据区）的静态区中，也叫对象的共享数据 静态使用注意 静态方法只能调用静态成员（非静态都可以访问） 静态方法不可使用this 或者 super关键字 主函数静态的 内存图解 内存划分 寄存器 本地方法区 方法区 栈内存 堆内存 接下来用一段代码来演示内存变化过程123456789101112131415161718192021222324public class Person &#123; private String name; private int age; static String country = &quot;CN&quot;; Person()&#123;&#125;; Person(String name,int age)&#123; this.name = name; this.age = age ; &#125; public void show()&#123; System.out.println(Person.country+&quot;:&quot;+this.name+&quot;:&quot;+this.age); &#125; public static void method()&#123; System.out.println(Person.country); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Person.method(); Person p = new Person(&quot;jack&quot;,20); p.show(); &#125;&#125; 运行程序的时候，读取StaticDemo类，在方法区存放他的名字，注意还有他的自带的构造函数，然后在他的静态区粘贴上类的名字和代码，栈内存中压栈main，根据上面代码需要调用Person类，将Person类的构造函数show方法粘在方法区，在静态区添加入静态变量和静态方法。栈内存中压栈method，弹栈。继续执行主函数的语句，创建对象在堆内存开辟空间，压栈Person的构造函数，用this指向堆中的地址，赋值给堆内存。Person构造函数弹栈，将堆中地址赋值给p对象，show方法压栈，this指向堆中的地址，弹栈 静态什么时候用静态变量 当分析对象中所具备的成员变量的值都是相同的，这是这个成员就可以被静态修饰。只要数据在对象中都不同的，就是对象的特有数据，必须存在对象中。非静态的若是有相同数据，且对象不需做修改只需要使用，，那么就不需要存储在对象中，定义成静态的就可以了 静态函数 参考一点，该函数功能是否有访问到对象中的特有数据 简单来说，从源代码看该函数功能是否需要访问非静态的成员变量，如果需要，该方法就是非静态的，如果不需要，该方法就可以定义成静态的 非静态需要被对象调用，而仅创建调用非静态但没有访问特有数据的方法，那么该对象的创建是没有意义的。 静态代码块 随类的加载而执行，且只执行一次 作用：给类初始化 构造代码块：给所有对象初始化 构造函数：给对应对象针对性初始化 执行顺序，谁先执行 有对象：静态代码块 &gt; 构造代码块 &gt; 构造函数 无对象：静态代码块 &gt; 构造函数 &gt; 构造代码块 主函数特殊处 格式固定 被JVM所识别，所调用 分析： public 权限最大 static 不需要对象，直接用主函数所属类名调用 void 没有具体返回值 main 不是关键字，只是被JVM所识别固定的名字 String[] args 主函数参数列表，一个数组类型参数，元素都是字符串 接下来我们输出代码测试一下 1234public static void main(String[] args)&#123; System.out.println(args); System.out.println(args.length);&#125; 结果：[Ljava.lang.String;@1540e19d 0]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象总结]]></title>
    <url>%2F2018%2F04%2F12%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[面向对象面向对象的特点 1.符合人们的思想习惯 2.将复杂事情简单化 3.让曾经在过程中的执行者变成指挥者举例 比如说，公司中刚刚接取了一个项目，如果这个事情全部都交给老总做的话，可能会耗时很久很久，所以他就需要去找别人来帮他做。需要去面试选人，也就是寻找几个对象替他去完成工作。这就是面向对象的一种体现。 哪个对象对动作最清楚，定义在哪里成员变量、局部变量的区别 成员变量 成员变量定义在类中，整个类都可以访问 成员变量存在于堆内存的对象中 成员变量随着对象创建而生，随对象消失而亡 成员变量都有默认初始值 局部变量 局部变量定义在函数、语句、局部代码块中，只在所属区域有效 局部变量存在于栈内存的方法中 局部变量随着所属区域的执行而存在，随着所属区域结束而释放 局部变量没有默认初始值（使用前必须进行初始化）匿名对象 1.当对象对方法仅进行一次调用的时候，就可以简化成匿名对象 2.匿名对象可以作为实际参数进行传递对象的内存体现 以下面这段代码为例 123456Car c1 = new Car();Car c2 = new Car();c1.num = 4;c1.color = red;c2.num = 5;c2.color = blue; 栈中运行主函数，创建c1对象，在堆中开辟一个新的区域，将他的地址值传回栈中，他的num初始值为0，color初始值为null 下面这段代码和上面又有什么不同那1234Car c1 = new Car();Car c2 = c1；c1.num = 4;c2.color = blue; 这里将c1赋值给c2，就是将c1地址给c2，所以c2.color = blue，通过寻址找到并更改的color值就是c1地址下的匿名对象 以下面代码，作图演示123new Car().num = 4;new Car().color = red;new Car().show(); 基本数据类型参数传递12345678910class demo&#123; public static void main(String[] args)&#123; int x; show(x); System.out.println(&quot;x=&quot;+x); &#125; public static void show(int x)&#123; x = 4; &#125;&#125; 引用数据类型参数传递123456789101112class demo&#123; int x; public static void main(String[] args)&#123; demo d = new demo(); d.x = 9; show(d); System.out.println(d.x); &#125; public static void show(demo d)&#123; d.x = 4; &#125;&#125; 封装 好处： 将变化隔离 便于使用 提高重用性 提高安全性 封装原则 将不需要对外提供的原则都隐藏起来 把属性都隐藏，提供公共方法对其访问 封装思想 封装：指隐藏对象的属性和实现细节，仅对外提供公共访问方式 private权限修饰符 私有仅仅是封装的一种体现而已，封装不仅仅有私有一种方式]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2F2018%2F04%2F10%2FJava-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E6%9F%A5%E8%A1%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天写一下二进制转换十六进制的程序,改良程序的过程进制转换（以10转16为例） 首先想一下十六进制是多少个二进制位，4个。那么int是多少个字节？多少个二进制位？4个字节，32个二进制位 123456789public void toHex(int num)&#123; int temp; for (int i = 0;i&lt;8 ;i++) &#123; temp = num &amp; 15; System.out.print(temp+&quot; &quot;); num = num &gt;&gt;&gt; 4; &#125; &#125; 上图的结果是12 3 0 0 0 0 0 0，先来讲讲原理，再改良 1234567891011 以 num = 60 为例 0000-0000 0000-0000 0000-0000 0011-1100&amp; 0000-0000 0000-0000 0000-0000 0000-1111------------------------------------------ 0000-0000 0000-0000 0000-0000 0000-1100 0000 0000-0000 0000-0000 0000-0000 0011 ( 1100 ）&amp; 0000-0000 0000-0000 0000-0000 0000-1111------------------------------------------ 0000-0000 0000-0000 0000-0000 0000-0011 结果分别是12 3 0 0 0 0 0 0 先和15（4个低位都是1，其余是0）进行&amp;运算，得到值后，再进行&gt;&gt;&gt;3的运算。这样得到的结果还有12的存在，应该是英文字母的，继续改进 1234567891011public void toHex2(int num)&#123; int temp; for (int i = 0;i&lt;8 ;i++) &#123; temp = num &amp; 15; if (temp&gt;=10) System.out.print((char)(temp-10+&apos;A&apos;)+&quot; &quot;); else System.out.print(temp+&quot; &quot;); num = num &gt;&gt;&gt; 4; &#125; &#125; 在中间的地方加了一个判断，使用了ASCII的知识，temp-10+’A’ 得到的不是字母，所以在前面还要加上char的强制转换 继续改进，现在这些数还是倒序，而且有许多无用位。 1234567891011121314public void toHex3(int num)&#123; char[] chars = new char[]&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;, &apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;; char[] arr = new char[8]; int point = arr.length - 1 ; int temp; while (num!=0)&#123; temp = num &amp; 15; arr[point] = chars[temp]; num = num &gt;&gt;&gt; 4; point --; &#125; System.out.print(arr); &#125; 这里使用了数组的查表法，创建两个char的数组，第一个数组是用来将所获取到的0到15的数字转换为十六进制中的字符，第二个数组用来存储最后16进制的结果 在之前的两个程序中，最后输出的值都是反向的，于是我在这里创建了一个指针point，让他的初始值指向数组最后端的角标，每次输入进一个数后，指针前移一位，这样最后输出的时候直接输出数组就可以输出一个转换正确的16进制值。 进制转换整合 上面的的程序还只能对10-&gt;16转换，可以对其略作修改，使其可以灵活转换各种进制 1234567891011121314public char[] trans(int num,int base,int offse)&#123; char[] chars = new char[]&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;, &apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;; char[] arr = new char[32]; int point = arr.length - 1 ; int temp; while (num!=0)&#123; temp = num &amp; base; arr[point] = chars[temp]; num = num &gt;&gt;&gt; offse; point --; &#125; return arr; &#125; 添加单独方法 1234567891011public char[] toBinary(int num)&#123; //十进制转换二进制 return trans(num,1,1);&#125;public char[] toHexa(int num)&#123; //十进制转换十六进制 return trans(num,15,4);&#125;public char[] toOctal(int num)&#123; //十进制转换八进制 return trans(num,7,3);&#125; 主类测试 12345678910public class tranSystem &#123; public static void main(String[] args)&#123; int num = 854796; tranSystem tra = new tranSystem(); System.out.println(tra.toHexa(num)); System.out.println(tra.toOctal(num)); System.out.println(tra.toBinary(num)); &#125; //上面写的方法添加在这里&#125; Integer.toBinaryString()是java系统自带的转换二进制 查表法 查表法在日常学习中可以有很多应用，如输入数字，输出星期几等等]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 数组常见操作]]></title>
    <url>%2F2018%2F04%2F09%2FJava-%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[今天整理了一些常用的数组操作，如最大值，查找，排序等等 数组最大值值判断12345678public int maxValue(int[] a)&#123; int max = a[0]; for(int i=0;i&lt;a.length;i++)&#123; if(a[i]&gt;max) max = a[i]; &#125; return max; &#125; 下标判断12345678public int maxIndex(int[] a)&#123; int max = 0; for(int i=0; i&lt;a.length;i++)&#123; if(a[i]&gt;a[max]) max = i; &#125; return a[max]; &#125; 数组操作辅助方法交换值123456public void swap(int[] arr,int a,int b)&#123; int temp = 0; temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; 输出链表12345public void printList(int[] arr)&#123; for(int i = 0;i&lt;arr.length;i++) System.out.print(arr[i]+&quot; &quot;); System.out.println(); &#125; 数组选择排序12345678910111213public void chooseSort(int[] arr)&#123; //选择排序 int temp = 0; for(int i=0;i&lt;arr.length-1;i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if(arr[j]&gt;arr[i])&#123; //swap(arr,i,j); temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; 选择排序改进版 改进版的选择排序，设置了角标值和数组值1234567891011121314public void chooseSort2(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++) &#123; int number = arr[i]; int index = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (number &gt; arr[j]) &#123; number = arr[j]; index = j; &#125; &#125; if (index!=i) swap(arr,i,index); &#125; &#125; 数组冒泡排序 冒泡排序，五个数为例，共进行4+3+2+1 10次比较123456789101112public void ppSort(int[] arr)&#123; //便于理解 int temp = 0; for(int i = 0;i&lt;arr.length-1;i++) for (int j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; //swap(arr,j,j+1); temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] =temp; &#125; &#125; &#125; 冒泡排序改进版123456789101112public void ppsort2(int[] arr)&#123; //改进版冒泡 int temp = 0; for (int i = arr.length-1;i&gt;0;i--) for(int j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; //swap(arr,j,j+1); temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] =temp; &#125; &#125; &#125; 查找通过值查找12345678public int findByValue(int[] arr,int key)&#123; //通过值查找 int index = -1; for (int i = 0;i&lt;arr.length;i++)&#123; if(key == arr[i]) index = i + 1; &#125; return index; &#125; 二分查找1234567891011121314151617public int findHalf(int[] arr,int key)&#123; //二分查找 list list = new list(); list.chooseSort2(arr); int max = arr.length-1; int min = 0; int mid ; while(min&lt;=max)&#123; mid = (max + min)&gt;&gt;1; if(key&gt;arr[mid]) min = mid + 1; else if(key&lt;arr[mid]) max = mid - 1; else return mid; &#125; return -1; &#125; 练习题 给定一个有序的数组，如果往该数组中存储一个元素，并保证这个数组还是有序的，那么这个元素的存储的角标该如何获取？ 1234567891011121314151617public int getJiaoBiao(int[] arr,int key)&#123; / list list = new list(); list.chooseSort2(arr); int min =0; int max =arr.length-1; int mid; while(min&lt;=max)&#123; mid = (min+max)&gt;&gt;1; if(key&gt;arr[mid]) min = mid + 1; else if (key&lt;arr[mid]) max = mid - 1; else return mid; &#125; return min; &#125; 在系统自带的Arrays类中，有这个方法，不过和我这个写的不一样，比我的更好一些，我把源码粘贴上来 123456789101112131415161718private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) &#123; int low = fromIndex; int high = toIndex - 1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;&gt; 1; int midVal = a[mid]; if (midVal &lt; key) low = mid + 1; else if (midVal &gt; key) high = mid - 1; else return mid; // key found &#125; return -(low + 1); // key not found. &#125; 不同的是返回值 比如我的答案如果是6，那么他的答案就会是-7，为什么那？ 因为要插入的这个数是不存在于数组中的，所以给他一个负数的位置，那么-7怎么来的？-6-1，因为还有1个值，就是用我的方法得到0的那个值，取了负数还是0，不好分辨，所以就整体取负后再减一 总结说：存在，返回具体的角标位置，不存在的话 返回 -插入点-1]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数组及内存图解]]></title>
    <url>%2F2018%2F04%2F08%2FJava%E5%87%BD%E6%95%B0%E5%8F%8A%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天整理了Java函数，数组，内存加载使用的问题，在这之前我先把昨天剩下的for语句写下来。 for语句 Java for语句基础 \n 回车\t 制表符\b 退格\r 按下回车键 windows系统中回车符其实是由两个符号组成 \r \nlinux 回车符只是 \n 1System.out.println(&quot;\&quot;hello world\&quot;&quot;); 上段代码最后输出结果是 “hello world” 有引号的，\会将他下一个字符转义 break 跳出 作用范围：swich语句 or 循环语句 当break语句单独存在时，下面不要定义其他语句，因为执行不到 123456A:for(int x=0; x&lt;3; x++)&#123; B:for(int y=0; y&lt;6; y++)&#123; System.out.println(x); break A; &#125;&#125; 大家观察一下上面的语句，这就是break的特殊用法，可以将for循环定义名字，break选择性的使用。 continue 继续 作用范围：循环结构 结束本次循环，继续下次循环 continue语句单独存在时，下面不要定义其他语句，因为执行不到 12345for(int x=0; x&lt;9; x++)&#123; if(x%2 == 0) continue; System.out.println(x);&#125; 函数 函数：定义在类中具有特定功能的一段小程序，也称方法。 定义及格式 定义函数格式： 1234修饰符 返回值类型 函数（参数类型 形参1, ... ... ,）&#123; 执行语句; return 返回值;&#125; 无具体返回值时，返回值类型用void，return可以忽略不写 功能 1 定义函数可将代码封装 2 便于对该功能复用 3 函数只有被调用才能执行 两个明确 1 函数功能结果是什么？ 2 实现过程中是否需要未知内容参与运算？ 函数重载 1 同一个类中的同名函数 2 参数个数不同或者是参数类型不同 3 函数重载与返回值无关 4 Java严谨性语言，如果函数出现调用不确定性，会编译失败（比如int返回值却是double参数类型） 数组 Java数组基础 内存 内存的划分 寄存器 本地方法区 方法区 栈内存 堆内存 栈内存 存储的都是局部变量，变量所属作用域一旦结束，该变量就自动释放 堆内存 储存数组和对象（数组就是对象），new 建立的都在堆上 特点： 每个实体都有首地址值 堆内存中每个变量都有默认内存初始值，根据类型不同而不同（int -&gt; 0,double -&gt; 0.0,float -&gt; 0.0f,boolean -&gt; false,char -&gt; ‘\u0000’） 垃圾回收机制 数组运行内存图解一维数组 接下来我就通过这段代码来演示运行时的内存变化 1234567int[] x = new int[3];int[] y = new int[3];x[0] = 9;y[0] = 34;x = y;System.out.println(x[0]);y = null; 栈中运行main然后存入x数组名，堆中分配地址（16进制），找到这个地址，开辟数组大小的空间，并给予其初始值。然后将数组地址传回栈中。 给x[0],y[0]赋值时，就是直接在堆内存中更改数据 x=y 语句的执行实质上就是将y的地址赋给x，下次再调用x的时候，即直接找到y的地址 当y = null; 就是将堆内存 和栈内存的指向关系删去， 12int[] x = new int[3];System.out.println(x[]); 如果直接运行上段代码，所得到的结果是一串字符 [I@1540e19d （我运行后的值） [: 代表数组I：int 实体类型1540e19d：16进制的哈希值（地址） 二维数组 直接来是二维数组的图解123int[][] arr = new int[3][2];arr[1][1] = 89;arr[2][2] = 89; //error 大家看下图，以上图为例，所谓二维数组就是栈内存中存下指向堆内存的地址，这个地址是大小为3的数组，初始值为空，然后再创建3个小的数组，每个小数组还有一个地址，将这些地址对应存到之前大小为3的数组中。 1234int[][] arr = new int[3][2];System.out.println(arr);System.out.println(arr[0]);System.out.println(arr[0][0]); 输出的结果 123[[I@1540e19d[I@677327b60 再来看看另一种定义下的情况 1234int[][] arr = new int[3][];System.out.println(arr);System.out.println(arr[0]);System.out.println(arr[0][0]); 结果如下 123[[I@1540e19dnullException in thread &quot;main&quot; java.lang.NullPointerException]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运算符基础]]></title>
    <url>%2F2018%2F04%2F07%2FJava%E8%BF%90%E7%AE%97%E7%AC%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[今天重温的主要是Java运算符，在这里我把之前已经遗忘的一些点记录下来，以后回顾的时候可以翻阅。 比较运算符^异或： 符号两边的结果相同为False，不同则为True1234True ^ True = False ;False ^ True = True ;True ^ False = True ;False ^ False = False ; ！非： 两次非运算就是原数12!true = false ;!!true = true ; 逻辑运算符&amp;和&amp;&amp;的区别： 让我们先来看一段代码 123int x = 1;if(x&gt;2 &amp;&amp; x&lt;5) System.out.println(); 在上面的情况中，在对 &amp;&amp; 左边的式子进行判断后，得出左边的式子值是false，因为两数相与，只要有一个flase，整体式子的结果就是false。所以停止运算右侧式子，直接给出false的结果。 但是使用 &amp; 运算符的时候，无论左边式子是什么，右边都参与运算。 &amp;&amp; 和 &amp; 运算结果一样，过程有一些小区别&amp; ：无论左边式子是什么，右边都参与运算&amp;&amp; ：当式子左边为false时，右边不参与运算，结果为false |和||的区别 上面我们说了 &amp; 和 &amp;&amp; 的区别，其实原理是一样的 || 和 | 运算结果一样，过程有一些小区别| ：无论左边式子是什么，右边都参与运算|| ：当式子左边为true时，右边不参与运算，结果为true 位运算&amp; 位运算 下面我用一个小例子来演示 12345676 &amp; 3 = ?内存中 0000-0000 0000-0000 0000-0000 0000-0110&amp; 0000-0000 0000-0000 0000-0000 0000-0011----------------------------------------- 0000-0000 0000-0000 0000-0000 0000-0010∴ 6 &amp; 3 = 2 6 &amp; 3 在内存中变化的实质是，转换为2进制，各位相对应的进行 &amp; 运算 应用场景： 取0100 0000 1100 0101的后四位，如何进行操作？ 答 ：用0000 0000 0000 1111与其进行 &amp; 运算。 | 位运算 原理同上 例如 6 | 3 = 7 ^ 位运算 原理同上 1234567891011126 ^ 3 = ?内存中(简化) 0110 ^ 0011 ------ 0101∴ 6 ^ 3 = 5继续 ^ 35 ^ 3 = ?演算后 5 ^ 3 = 6 不知道大家发没发现这个运算的一些小秘密，那就是一个数连续两次与相同的数进行异或运算后，结果会是最初的数。用公式写就是： a ^ b ^ b = a 那么这个究竟可以用作干什么那？可以用于文件的加密！ ~ 反码 大家可以在自己的电脑上试一下下面的代码，看看是不是自己猜测的值 12int a = 2;System.out.println(~a); 结果是 -3 ，很多人可能都以为反码的意思就是将a的二进制10取反为01，猜测结果是1 为什么不是这样的运算过程那？ 原理这就要从计算机常用的几个码说起了。首先，java存储的是有符号数，在计算机中，有符号数通常是使用补码存储的，java也不例外。先来看看什么叫原码，反码，补码。 原码原码就是符号位加上真值的绝对值,即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:1[+1]原 = 0000 0001 反码正数的反码是其本身负数的反码是在其原码的基础上,符号位不变，其余各个位取反.例如：1[+1] = [00000001]原 = [00000001]反 补码正数的补码就是其本身负数的补码是在反码的基础上+1。例如:1[+1] = [00000001]原 = [00000001]反 = [00000001]补 分析所以回到一开始的问题，int a = 2 a在计算机中是以补码存储的。 对于2这个正数来说，补码、反码、原码都是相同的，又由于是数值型，在这里我先用八位bit来表示一下：12原码:0000 0010反码:0000 0010 补码:0000 0010 取反取反过程是在补码的基础上进行的，由于是按位取反，无论符号位还是数值位都要取反，所以结果如下: 1取反后的补码: 1111 1101 换算为值那么取反后的补码的实际值是多少呢？我们需要先把他转化为原码，过程如下: 1反码 = 1111 1101 - 1 = 1111 1100 原码 = 反码符号位不变，其余取反 = 1000 0011 所以，最后的值-3 &lt;&lt; 左移 这个符号之前并没有听说过，在这次学习中进行了掌握（开始我还以为是C++的cout那） 1234563 &lt;&lt; 2 = ?内存中0000-0000 0000-0000 0000-0000 0000-0011结果0000-0000 0000-0000 0000-0000 0000-1100∴ 3 &lt;&lt; 2 = 12 上面的运算实质是 3的2进制 整题左移两位，多余的舍弃，空位用0补 一个数进行左移运算时，左移n位，即是该数乘以2的n次幂 &gt;&gt; 右移 原理几乎一样，只有略微的不同原来最高位是什么，用什么补空位（因为最高位为1时是负数） 右移n位，即是该数除以2的n次幂1234-12 &gt;&gt; 2 = ?答： -3 12 &gt;&gt; 2 = ?答： 3 &gt;&gt;&gt; 无符号右移 高位空位，全部填0，用0补位1234-12 &gt;&gt;&gt; 2 = ?答： 3 12 &gt;&gt;&gt; 2 = ?答： 3 应用 请用效率最高的方法求出 2*8 的值。 1System.out.println(2&lt;&lt;3); 两个整数值互换（不使用第三方变量） 1234567891011方法1：（不建议使用，如果数值过大，可能丢失精度）int a = 3, b = 5;a = a + b;b = a - b;a = a - b方法2：（利用异或位运算）int a = 3, b = 5;a = a ^ b;b = a ^ b;a = a ^ b; 三元运算符 （条件表达式）？表达式1：表达式2 若条件为true ，结果为表达式1若条件为false，结果为表达式21234练习：在x , y中取 值较大的整数int x = 3, y = 4;int max = ( x&gt;y )? x : y;System.out.println(max); swich 和 if else 与 三元运算符 三元运算符必须有结果，if else可有，可不有结果。当if else有具体运算结果时，可以使用三元运算符。 1234567891011121314151617swich使用示范： int x = 3; swich(x) &#123; case 1: System.out.println(x); break; case 2: System.out.println(x); break; case 3: System.out.println(x); break; case default: System.out.println(x); break; &#125; if： 对几个具体值进行判断 对区间判断 对运算结果boolean类型表达式判断 swich： 对几个具体值进行判断 值的个数通常是固定的 对几个固定值判断，建议使用swich，swich将答案存在内存中，效率高]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 链表实现]]></title>
    <url>%2F2018%2F04%2F06%2FJava-%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[分享一下我用java实现的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public class LinkList&lt;T&gt; &#123; private Node&lt;T&gt; head; //头节点 private Node&lt;T&gt; tail; //尾节点 /** * 构造空链表 */ public LinkList()&#123; head = tail = null; &#125; /** * 链表内部的节点类 */ private static class Node&lt;T&gt;&#123; T data; //节点的数据 Node&lt;T&gt; next; //该节点指向下一个节点的指针 Node(T data)&#123; this.data = data; this.next = null; &#125; &#125; /** * 为空链表增加头节点 */ public void addHead(T point)&#123; this.head = new Node&lt;T&gt;(point); if(tail == null)&#123; tail = head; &#125; &#125; /** * 为链表增加尾节点 */ public void addTail(T point)&#123; tail = new Node&lt;T&gt;(point); head.next = tail; &#125; /** * 插入节点（头插法） */ public void addNode(T point)&#123; if(this.head==null) //添加头节点 addHead(point); else if(this.tail==this.head) //在头节点后添加尾节点 addTail(point); else&#123; Node&lt;T&gt; newNode = new Node&lt;T&gt;(point); newNode.next = head.next; head.next = newNode; &#125; &#125; /** * 删除节点（通过数据值） */ public void deleteNode(T data)&#123; Node&lt;T&gt; curr = head ,pre = null; boolean flag = false; //判断要删除的节点是否存在 while(curr != null)&#123; if(curr.data.equals(data))&#123; if (curr==head)&#123; //删除头节点 System.out.println(&quot;delete the head Node&quot;); head = curr.next; flag = true; &#125;else if (curr==tail)&#123; //删除尾节点 System.out.println(&quot;delete the tail Node&quot;); tail = pre; pre.next = null; flag = true; &#125;else &#123; //删除中间节点 System.out.println(&quot;delete the center Node&quot;); pre.next = curr.next; flag = true; &#125; &#125; pre = curr; curr = curr.next; &#125; if (flag == false) System.out.println(&quot;链表中不存在该数据&quot;); &#125; /** * 查找链表中的元素（通过位置） */ public void findKth(T point)&#123; Node&lt;T&gt; curr = head , pre = null; int k = 1; boolean flag = false; while (curr != null)&#123; if(point.equals(k))&#123; System.out.println(&quot;第&quot;+k+&quot;位的值是&quot;+curr.data); flag = true; &#125; pre = curr; curr = curr.next; k++; &#125; if(flag==false) System.out.println(&quot;查找的位置在链表中不存在&quot;); &#125; /** * 查找链表中的元素（通过值） */ public void findByValue(T data)&#123; Node&lt;T&gt; curr = head ; int k = 1; boolean flag = false; while(curr!=null)&#123; if(curr.data==data)&#123; System.out.println(&quot;查找的值在链表中的第&quot;+k+&quot;位&quot;); flag = true; &#125; curr = curr.next; k++; &#125; if(flag==false) System.out.println(&quot;查找的值在链表中不存在&quot;); &#125; /** * 输出链表 */ public void printlnLink()&#123; Node&lt;T&gt; curr = this.head; if(curr==null)&#123; System.out.println(&quot;linklist is null&quot;); &#125;else&#123; while(curr!=null)&#123; System.out.print(curr.data+&quot; &quot;); curr = curr.next; &#125;System.out.println(); &#125; &#125; public static void main(String[] args)&#123; LinkList linkList = new LinkList&lt;Integer&gt;(); linkList.addNode(5); linkList.addNode(8); linkList.addNode(10); linkList.addNode(6); linkList.addNode(9); System.out.println(&quot;TailNode: &quot;+linkList.tail.data); linkList.deleteNode(8); linkList.printlnLink(); linkList.findByValue(5); linkList.findKth(10); System.out.print(&quot;&quot;); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java易错知识点]]></title>
    <url>%2F2018%2F04%2F06%2FJava%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[最近在看Java基础知识的视频，因为距离大二学习基础知识的时光有些久远了，并且当时也并没有进行总结，所以写下这个博客权当做笔记，方便温故而知新。 强制转换1234567891011第一种情况 byte a = 1; a = 3 + 4; System.out.println(a); 第二种情况 byte a = 1; byte b = 3; byte c = 4; a = b + c; System.out.println(a); 在这两种情况下，最后运行的值有什么不同那？ 第一个的值最后为7；第二个运行后运行错误，显示可能损失精度。 第一种情况下，因为3和4是int值，a是byte值，当a=3+4时，运算符对左右两边进行了一个判断，如果右边的数在byte的范围内，则自动将其强制转换，赋值给a。 第二种情况下，b、c都是变量，系统不可以自动将其强制转换，因为他们可能是一个大于byte范围的数。 算数运算符12345678910111213141516第一种情况 int x = 3, y; y = x++; System.out.println(x); System.out.println(y); 第二种情况 int x = 3, y; y = ++x; System.out.println(x); System.out.println(y); 第三种情况 int a = 3; a = a++; System.out.println(a); 运行结果分别是什么？ 123x = 4 y = 3x = 4 y = 4a = 3 第一种情况涉及到了运算符的原理，系统是如何对 y=x++ 这个式子进行处理的那，先将 x 原先的值3存储起来，再对x进行++运算，最后进行=运算的时候将预存的x的值赋给y。 第二种情况主要式子是 y=++x ，这次是直接进行 ++x 的运算，再将他赋给y。 第三种情况和第一种情况大致相同，为了方便理解，我将 a = a++ 在内存中的处理过程写成程序。通过下面的代码就能够了解为什么最后的结果是3了。 1234int a = 3;temp = a;a++;a = temp; +=运算问题123short s = 3;s += 4;s = s + 4; 第二个式子和第三个式子有什么不同？ 第二个式子可以运行成功，第三个式子不可以。在这里4是int值，+=是一个运算符，他会对右边的数进行判断，是否在short的范围内再自动进行强制转换，赋值给s。而第三个式子=的右面面对的是变量s，必须手动进行强制转换。 %运算问题12a = -5 % 2;b = 5 % -2; a和b的值分别是多少？ a = -1，b = 1 取模运算只有 %左边是负数的情况下对结果有影响]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo博客]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[经过了好一段时间的折腾，终于成功搭建好了博客。我就在这里分享一些使用Hexo+Github搭建的心得。既是为了分享，也是为了防止自己遗忘，备份之用。 搭建前准备工作 1.安装node.js 2.安装git 3.安装hexo （右键git bash 运行$ npm install -g hexo） 本地搭建静态博客 1.新建一个文件夹 如MyBlog 2.生成git模板 在MyBlog文件夹内，右键git bash输入$ hexo init 3.运行npm install 4.运行npm server 5.http://localhost:4000 可以看到本地搭建的博客 将博客关联github 在github上创建名字为XXX.github.io项目(XXX为用户名) 打开本地MyBlog文件夹内的_config.yml配置文件 ,拉到最底下，更改为 1234deploy: type: git repository: https://github.com/OrangeTop/OrangeTop.github.io.git branch: master 第一次使用git需要配置ssh,引号处填写自己的邮箱 1git bash $ ssh-keygen -t rsa -C "your_email@youremail.com" 然后一路回车即可成功生成.ssh文件 在C:\users\用户名.ssh文件夹中，打开id_rsa.pub，全部复制。然后回到github网站，进入setting选择SSH and GPG–&gt;New SSh Keytitle随意填，Key粘贴 1验证:git bash $ ssh -T git@github.com 上传本地仓库， 右键git bash。 (引号处注意填写自己的信息) 12$ git config --global user.name &quot;your name&quot; $ git config --global user.email &quot;your_email@youremail.com&quot; 继续部署，中途需要输入用户名密码 123$ npm install hexo-deployer-git --save$ hexo g$ hexo d 最后在浏览器输入OrangeTop.github.io 即可看见博客 The First Blog 进入MyBlog文件夹右键git bash123456789101112//创建新的博客，文件在source-&gt;_posts文件夹下hexo new &quot;新的文件名&quot;//运行hexo，访问本地localhost:4000可预览hexo s//进入MyBlog文件夹下的public文件夹cd public//本地生成静态文件hexo g//返回MyBlog文件夹cd ..//将本地静态文件推送至githubhexo d 报错解决 下载hexo报错 12345$ npm install -g hexonpm ERR! Unexpected end of JSON input while parsing near &apos;...&quot;commander&quot;:&quot;*&quot;&#125;,&quot;opt&apos;npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\75173\AppData\Roaming\npm-cache\_logs\2018-03-27T13_25_30_385Z-debug.log 解决方法 1234更换为淘宝镜像npm --registry https://registry.npm.taobao.org install express 检验是否更换成功npm config get registry 若不成功，继续 1234清理缓存npm cache clean –force重新安装npm install -g hexo 使用一段时间后，hexo d上传失败，ssh连接github失败 1234打开C:\Windows\System32\drivers\etc目录下的hosts文件再最后面加上下面两行192.30.253.112 github.com192.30.253.113 github.com 参考文章 教你搭一个博客 Hexo博客搭建教程]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2F2018%2F03%2F28%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[尼采说： Was mich nicht umbringt, macht mich stärker.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
