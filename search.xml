<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[回溯算法]]></title>
    <url>%2F2018%2F06%2F28%2F%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[回溯的算法题，之前也遇到过，但是每次都没有仔细研究，这几天做 剑指offer 的题中，又再次遇到了回溯，于是打算这一次能够将他弄明白 概述常用解释回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就回溯返回，尝试别的路径 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为回溯点 许多复杂的，规模较大的问题都可以使用回溯法，有通用解题方法的美称 基本思想在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法） 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束 题目请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子 举例如在下图矩阵中包含一条字符串 bcced 的路径，但是矩阵中不包含 abcb 路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子 123a b c es f c sa d e e 思路这道题可以采用回溯算法来做，我们可以以矩阵中每一个点为起始点，当有一个点与字符串中第一个字符相等，即可继续前进，接下来去搜索该节点的上下左右节点，如果有任意一个节点和字符串中接下来的字符相等时，即继续前进；否则返回到之前的节点，再重新搜索。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class BackTracking &#123; /** * @param matrix 输入的矩阵 * @param rows 矩阵行数 * @param cols 矩阵列数 * @param str 将要搜索的字符串 * @return 是否找到 是：true 否：false */ public static boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; //参数校验 if (matrix == null || matrix.length != rows * cols || rows &lt; 1 || cols &lt; 1 || str.length &lt; 1 || str == null) &#123; return false; &#125; //定义boolean型矩阵，用来标识路径是否进入某个格子 boolean[] visited = new boolean[rows * cols]; //记录结果，作为str字符串的角标 int pathLength = 0; //以每一个点为起始进行搜索 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; //给每个格子初始值赋为负值 memset(visited, false); if (hasPathCore(matrix, rows, cols, str, i, j, visited, pathLength)) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * @param matrix 输入的矩阵 * @param rows 矩阵总行数 * @param cols 矩阵总列数 * @param str 需要查找的str字符串 * @param row 当前处理的矩阵行号 * @param col 当前处理的矩阵列号 * @param visited 访问标记数组 * @param pathLength 已经处理str字符串的个数 * @return 是否找到 是：true 否：false */ private static boolean hasPathCore(char[] matrix, int rows, int cols, char[] str, int row, int col, boolean[] visited, int pathLength) &#123; //判断：如果检测到了数组的最后一位，可以直接返回true if(pathLength == str.length) return true; boolean hasPath = false; if (row &lt; rows &amp;&amp; col &lt; cols &amp;&amp; col &gt;= 0 &amp;&amp; row &gt;= 0 &amp;&amp; matrix[row * cols + col] == str[pathLength] &amp;&amp; !visited[row * cols + col]) &#123; visited[row * cols + col] = true; pathLength++; // 按照上下左右回溯 hasPath = hasPathCore(matrix, rows, cols, str, row, col - 1, visited, pathLength) || hasPathCore(matrix, rows, cols, str, row - 1, col, visited, pathLength) || hasPathCore(matrix, rows, cols, str, row, col + 1, visited, pathLength) || hasPathCore(matrix, rows, cols, str, row + 1, col, visited, pathLength); if (!hasPath) &#123; --pathLength; visited[row * cols + col] = false; &#125; &#125; return hasPath; &#125; /** * 给boolean型数组赋值 * * @param booleans 数组 * @param bool 赋值 */ private static void memset(boolean[] booleans, boolean bool) &#123; for (int i = 0; i &lt; booleans.length; i++) &#123; booleans[i] = bool; &#125; &#125;&#125; 测试为了方便测试，使用了 Junit 来进行测试，不得不说，真好用啊！！ 12345678910111213141516171819202122232425262728293031323334353637383940import org.junit.Test;public class BackTrackingTest &#123; @Test public void test1() &#123; char[] matrix = new char[]&#123;'a', 'b', 'c', 'e', 's', 'f', 'c', 's', 'a', 'd', 'e', 'e'&#125;; char[] str = new char[]&#123;'b', 'f', 'c', 'e'&#125;; boolean bool = BackTracking.hasPath(matrix, 3, 4, str); System.out.println(bool); &#125; @Test public void test2()&#123; String matrix = "asdfzxcvqwer"; String str = "sxzq"; boolean bool = BackTracking.hasPath(matrix.toCharArray(), 3, 4, str.toCharArray()); System.out.println(bool); &#125; @Test public void test3()&#123; String matrix = ""; String str = "sxzq"; boolean bool = BackTracking.hasPath(matrix.toCharArray(), 0, 0, str.toCharArray()); System.out.println(bool); &#125; @Test public void test4()&#123; String matrix = "qwerasdfzxcv"; String str = "qwsw"; boolean bool = BackTracking.hasPath(matrix.toCharArray(), 0, 0, str.toCharArray()); System.out.println(bool); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>回溯</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL8.0连接中的几个问题]]></title>
    <url>%2F2018%2F06%2F17%2FMySQL8-0%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题汇总JDBC 驱动最新版问题报错原因 使用了MySQL的最新版 JDBC 连接驱动 报错提示1java.sql.SQLException: The server time zone value '???ú±ê×??±??' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 解决方案在 1jdbcUrl=jdbc:mysql://localhost:3306/person 后面加上： 1jdbcUrl=jdbc:mysql://localhost:3306/person?serverTimezone=UTC 但如果你的 jdbcUrl 类似下面： 1jdbcUrl=jdbc:mysql://localhost:3306/person?serverTimezone=UTC&amp;characterEncoding=utf-8 就是有多个params的时候需要以&amp;分开，但 &amp;要改为 &amp;amp; 如下： 1jdbcUrl=jdbc:mysql://localhost:3306/spring?serverTimezone=UTC&amp;ampcharacterEncoding=utf-8 注意 在使用配置文件或c3p0-xml配置的情况下 多个params间以 &amp;amp; 分割 在 JDBCUtils 老版方法中 多个params中用 &amp;amp 分割]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-C3P0连接池]]></title>
    <url>%2F2018%2F06%2F17%2FJava-C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[概述分析实际开发中“获得连接”或“释放资源”是非常消耗系统资源的两个过程，为了解决此类性能问题，通常情况我们采用连接池技术，来共享连接Connection 概念用池来管理Connection，这样可以重复使用Connection。有了池，所以我们就不用自己来创建 Connection’而是通过池来获取Connection对象。当使用完Connection后，调用Connection的close() 方法也不会真的关闭Connection，而是把Connection “归还”给池。池就可以再利用这个Connection 对象了。 规范Java为数据库连接池提供了公共的接口：javax.sqI.DataSource,各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池！ 常见的连接池：DBCP、C3POO 自定义连接池分析根据我们对连接池简单的理解，如果我们要编写自定义连接池，需要完成以下步骤 创建连接池实现（数据源），并实现接口 javax.sqI.DataSource 。因为我们只使用该接口中getConnection()方法，简化本案例，我们将自己提供方法，而没有实现接口 提供一个集合，用于存放连接，因为移除/添加操作过多，所以选择LinkedList 本案例在静态代码块中，为连接池初始化3个连接 之后程序如果需要连接，调用实现类的getConnection(),本方法将从连接池（容器List)获得连接。为了保证当前连接只能提供给一个线程使用，所以我们需要将连接先从连接池中移除 当用户使用完连接，释放资源时，不执行close()方法，而是将连接添加到连接池中 准备 写好配置文件后，通过静态代码块加载配置文件信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class JDBCUtils_V3 &#123; private static String driver; private static String url; private static String username; private static String password; static &#123; try &#123; // 1.通过当前类获取类加载器 ClassLoader classLoader = JDBCUtils_V3.class.getClassLoader(); // 2.通过类加载器的方法获得一个输入流 InputStream is = classLoader.getResourceAsStream("db.properties"); // 3.创建一个properties对象 Properties props = new Properties(); // 4.加载输入流 props.load(is); // 5.获取相关参数的值 driver = props.getProperty("driver"); url = props.getProperty("url"); username = props.getProperty("username"); password = props.getProperty("password"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; Connection conn = null; try &#123; Class.forName(driver); conn = DriverManager.getConnection(url, username, password); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn; &#125; public static void release(Connection conn, PreparedStatement pstmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (pstmt != null)&#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 实现123456789101112131415161718192021222324252627282930313233343536373839public class MyDataSource implements DataSource&#123; //1.创建1个容器用于存储Connection对象 private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;(); //2.创建5个连接放到容器中去 static&#123; for (int i = 0; i &lt; 5; i++) &#123; Connection conn = JDBCUtils.getConnection(); pool.add(conn); &#125; &#125; /** * 重写获取连接的方法 */ @Override public Connection getConnection() throws SQLException &#123; Connection conn = null; //3.使用前先判断 if(pool.size()==0)&#123; //4.池子里面没有，我们再创建一些 for (int i = 0; i &lt; 5; i++) &#123; conn = JDBCUtils.getConnection(); pool.add(conn); &#125; &#125; //5.从池子里面获取一个连接对象Connection conn = pool.remove(0); return conn; &#125; /** * 归还连接对象到连接池中去 */ public void backConnection(Connection conn)&#123; pool.add(conn); &#125;&#125; 自定义连接池：方法增强自定义连接池中存在严重问题，用户调用getConnection()获得连接后，必须使用release()方法进行连接的归还，如果用户调用conn.close()将连接真正的释放，连接池中将出现无连接可用。 此时我们希望，即使用户调用了close()方法，连接仍归还给连接池。close()方法原有功能时释放资源，期望功能：将当前连接归还连接池。说明se()方法没有我们希望的功能，我们将对close() 方法进行增强，从而实现将连接归还给连接池的功能 方法增强总结 继承：子类继承父类，将父类的方法进行复写，从而进行增强。 使用前提：必须有父类，且存在继承关系 装饰者设计模式：此设计模式专门用于增强方法。 使用前提：必须有接口 缺点：需要将接口的所有方法都实现 动态代理：在运行时动态的创建代理类，完成增强操作。 与装饰者相似使用前提：必须有接口 难点：需要反射技术 字节码增强：运行时创建目标类子类，从而进行增强常见 第三方框架：cglib、javassist等 装饰者设计模式设计模式：专门为解决某一类问题，而编写的固定格式的代码。 装饰者固定结构：接口A，己知实现类c，需要装饰者创建代理类B 创建类B，并实现接口A 提供类B的构造方法，参数类型为A，用于接收A接口的其他实现类(c) 给类B添加类型为A成员变量，用于存放A接口的其他实现类 增强需要的方法 实现不需要增强的方法，方法体重调用成员变量存放的其他实现类对应的方法 实现123456789101112131415161718192021222324252627282930//1.实现同一个接口Connectionpublic class MyConnection implements Connection &#123; //3.定义一个变量 private Connection conn; private LinkedList&lt;Connection&gt; pool; // 2.编写一个构造方法(参数使用了面相对象的多态特性) public MyConnection(Connection conn,LinkedList&lt;Connection&gt; pool) &#123; this.conn=conn; this.pool=pool; &#125; //4.书写需要增强的方法 @Override public void close() throws SQLException &#123; pool.add(conn); &#125; /** * 此方法必须覆盖！否则会出现空指针异常！！！ */ @Override public PreparedStatement prepareStatement(String sql) throws SQLException &#123; return conn.prepareStatement(sql); &#125; /*下面为不需要增强的方法*/ &#125; 使用装饰类 C3P0连接池导入Jar包C3P0-0.9.1.2.jar mchange-commons-java-0.2.3.4.jar 配置文件 配置文件名称：c3p0-config.xml (固定) 配置文件位置：src（类路径） 配置文件内容：命名配置 c3p0-config.xml-基本配置 常见配置项 编写工具类 未抽取工具类之前 1234567891011121314151617181920212223242526public class TestC3P0 &#123; @Test public void testAddUser()&#123; Connection conn = null; PreparedStatement pstmt = null; ComboPooledDataSource dataSource = new ComboPooledDataSource(); try &#123; conn = dataSource.getConnection(); String sql = "insert into tbl_user value(null,?,?)"; pstmt = conn.prepareStatement(sql); pstmt.setString(1, "xiaomingming"); pstmt.setString(2, "小白"); int rows = pstmt.executeUpdate(); if(rows&gt;0)&#123; System.out.println("添加成功"); &#125;else &#123; System.out.println("添加失败"); &#125; &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125;finally &#123; JDBCUtils_V3.release(conn, pstmt, null); &#125; &#125;&#125; 抽取工具类 123456789101112131415public class C3P0Utils &#123; private static ComboPooledDataSource dataSource = new ComboPooledDataSource(); public static DataSource getDataSource()&#123; return dataSource; &#125; public static Connection getConnection()&#123; try &#123; return dataSource.getConnection(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 抽取工具类后的测试类可以这样写 12345678910111213141516171819202122232425public class TestC3P0 &#123; @Test public void testAddUser1()&#123; Connection conn = null; PreparedStatement pstmt = null; try &#123; conn = C3P0Utils.getConnection(); String sql = "insert into tbl_user value(null,?,?)"; pstmt = conn.prepareStatement(sql); pstmt.setString(1, "xiaowang"); pstmt.setString(2, "小白"); int rows = pstmt.executeUpdate(); if(rows&gt;0)&#123; System.out.println("添加成功"); &#125;else &#123; System.out.println("添加失败"); &#125; &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125;finally &#123; JDBCUtils_V3.release(conn, pstmt, null); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C3P0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快排的算法在平均状况下，排序效率为 O（N*LogN），运算效率是最高的，所以最受欢迎。而且在快速排序的算法中还体现着 分冶 思想，这几天我学习了一下这个算法，整理一下他的算法思路。 快速排序算法-维基百科 算法原理快速排序算法使用分冶法来把一个序列分为两个序列 从数列中挑出一个元素，称为“基准”（pivot） 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面 在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作 递归地把 小于基准值元素的子数列 和 大于基准值元素的子数列 排序 下面的图片来自于维基百科，通过看这张图可以观察到使用该算法后数据的变化 代码示例 在这个类中，为了方便理解，我创建了多个方法互相调用，并在函数上面加上了注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class QuickSort &#123; //判断数组是否为空 private static boolean isEmpty(int[] arr) &#123; return arr == null || arr.length == 0; &#125; //在主类中调用该方法，对数组进行排序 public static void quickSort(int[] arr) &#123; if (isEmpty(arr)) System.out.println("数组为空，请输入数据后再排序！！！"); quickSort(arr, 0, arr.length - 1); &#125; //也可以选择在主类中调用该方法，对数组指定位置进行排序 public static void quickSort(int[] arr, int low, int high) &#123; if (isEmpty(arr)) return; if (low &lt; high) &#123; //基准数据在数组中所在的角标 int pivotKey = partion(arr, low, high); //将基准左部递归排序 quickSort(arr, low, pivotKey - 1); //将基准右部递归排序 quickSort(arr, pivotKey + 1, high); &#125; &#125; private static int partion(int[] arr, int start, int end) &#123; //以第一个数据为基准 int pivot = arr[start]; while (start &lt; end) &#123; //从数组右端开始，若数据大于基准值，end指针-1 //反之则交换该数据值和基准值，并且将start++ while (arr[end] &gt;= pivot &amp;&amp; start &lt; end) end--; if (start &lt; end) &#123; swap(arr, start, end); start++; &#125; //从数组左端开始，若数据小于基准值，start指针+1 //反之则交换该数据值和基准值，并且将end-- while (arr[start] &lt; pivot &amp;&amp; start &lt; end) start++; if (start &lt; end) &#123; swap(arr, end, start); end--; &#125; &#125; //返回基准值在数组中的角标 return start; &#125; //函数功能：交换数组中两个数据值 private static void swap(int[] arr,int i,int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 优化 在上面可以发现，代码的基准一直选取的是第一个数，在某些糟糕的情况下，该算法效率并不佳 过段时间，我会再补上优化的部分]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-DOM]]></title>
    <url>%2F2018%2F05%2F31%2FJava-DOM%2F</url>
    <content type="text"><![CDATA[概述DOM：Document Object Model(文档对象模型) 用来将标记型文档封装成对象，并将标记型文档中的所有的内容(标签，文本，属性等)都封装成对象。 封装成对象的目的是为了更为方便的操作这些文档以及文档中的所有内容。 因为对象的出现就可以有属性和行为被调用。 文档对象模型 文档：标记型文档 对象：封装了属性和行为的实例，可以被直接调用 模型：所有标记型文档都具备一些共性特征的一个体现 标记型文档(标签，属性，标签中封装的数据) 只要是标记型文档，DOM这种技术都可以对其进行操作 常见的标记型文档：html xml DOM这种技术是如何对标记型文档机型操作的呢？ 要操作标记型文档必须对其进行解析 解析方式DOM DOM技术的解析方式： 将标记型文档解析一棵DOM树，并将树中的内容都封装成节点对象 DOM解析方式 好处：可以对树中的节点进行任意操作，比如：增删改查 弊端：这种解析需要将整个标记型文档加载进内存。 意味着如果标记型文档的体积很大，较为浪费内存空间 SAX SAX：是由一些组织定义的一种民间常用的解析方式，并不是w3c标准，而DOM是W3C的标准 SAX解析的方式：基于事件驱动的解析。获取数据的速度很快，但是不能对标记进行增删改 DOM三级模型 DOM level 1：将html文档封装成对象 DOM level 2：在level 1基础上加入了新功能，比如解析名称空间 DOM level 3：将xml文档封装成了对象 DHTML动态的HTML，不是一门语言，是多项技术综合体的简称 其中包含了HTML，CSS，DOM，JavaScript 这四个技术在动态html页面效果定义时，都处于什么样角色呢？负责什么样的职责呢？ HTML： 负责提供标签，对数据进行封装，目的是便于对该标签中的数据进行操作 简单说：用标签封装数据 CSS： 负责提供样式属性，对标签中的数据进行样式的定义 简单说：对数据进行样式定义 DOM： 负责将标签型文档以及文档中的所有内容进行解析，并封装成对象， 在对象中定义了更多的属性和行为，便于对对象操作 简单说：将文档和标签以及其他内容变成对象 J s： 负责提供程序设计语言，对页面中的对象进行逻辑操作 简单说：负责页面的行为定义，就是页面的动态效果 所以 JavaScript是动态效果的主力编程语言 DHTML+XMLhttpRequest = AJAX BOMBrowser Object Model 浏览器对象模型 ，这个模型方便于操作浏览器 浏览器对应的对象就是window对象，这个可以通过查阅DHTML API获得 定义一个事件源，通过对事件源的触发，获取想要的结果 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;script type="text/javascript" src="out.js"&gt;&lt;/script&gt; //定义按钮 onclick事件的处理方式 &lt;script type="text/javascript"&gt; //定义一函数 function windowObjDemo()&#123; //想要知道这个浏览器的信息。 就需要使用window对象中的navigator var name = navigator.appName; var version = navigator.appVersion; println(name+":"+version); &#125; //演示location function windowObjDemo2()&#123; var pro = location.protocol; var text = location.href; alert(text); //给location的href属性设置一个值 //改变了地址栏的值，并对其值进行了解析如果是http，还进行连接访问 location.href = "https://orangetop.github.io"; &#125; &lt;/script&gt; &lt;!--定义事件源,注册事件关联的动作--&gt; &lt;input type="button" value="演示window中的对象" onclick="windowObjDemo2()" /&gt;&lt;/body&gt; window对象 演示window中的常见方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;script type="text/javascript" src="out.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var timeid; function windowMethodDemo()&#123; var b = confirm("你真的确定要点击吗？"); alert("b="+b); //延迟4秒，弹窗 setTimeout("alert('time out run')",4000); //每隔3秒弹窗 timeid = setInterval("alert('interval run')",3000); &#125; function stopTime()&#123; //取消之前设置的间隔事件 clearInterval(timeid); &#125; function windowMove()&#123; // moveBy(10,10); // moveTo(40,40); for (var x = 0; x &lt; 700; x++)&#123; //窗口抖动 moveBy(20, 0); moveBy(0, 20); moveBy(-20,0); moveBy(0,-20); &#125; &#125; function windowOpen()&#123; //可以作为广告，会弹出 ad.htmlopen("ad.html","_blank","height=400,width=400,status=no,toolbar=no,menubar=no,location=no"); c8lose(); &#125; &lt;/script&gt; &lt;input type="button" value="演示window对象的方法" onclick="windowOpen()"/&gt; &lt;input type="button" value="停止" onclick="stopTime()"/&gt;&lt;/body&gt; window常见事项 12345678910111213141516171819202122&lt;script type="text/javascript"&gt; onunload = function()&#123; //在对象被卸载前触发 alert("onunload run"); &#125; onload = function()&#123; //浏览器完成对象装载后触发 alert("onload run"); &#125; onbeforeunload = function()&#123; //在对象将要被卸载前触发 alert("onbeforeunload run"); &#125; onload = function()&#123; window.status = "啊！，加载完毕啦"; &#125;&lt;/script&gt; DOMdocument对象该对象将标记型文档进行封装，作用是可以对标记型文档进行操作 若是想要实现动态效果，就需要对节点操作，那么要先获取到这个节点 要想获取节点，必须要先获取到节点所属的文档对象document document对象最常见的操作就是获取页面中的节点 获取节点的方法体现： 1、getElementById()： 通过标签的id属性值获取该标签节点，返回该标签节点 2、getElementsByName()： 通过标签的name属性获取节点，因为name有相同，所以返回的一个数组 3、getElementsByTagName(): 通过标签名获取节点。因为标签名会重复，所以返回的是一个数组 凡是带s返回的都是数组 获取节点 节点都有三个必备的属性： 节点名称，节点类型，节点值 常见节点有三种： 1、标签型节点：类型 1 2、属性节点： 类型 2 3、文本节点： 类型 3 标签型节点是没有值的，属性和文本节点是可以有值的 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt;&lt;script type="text/javascript"&gt; function getNodeDemo()&#123; var divNode = document.getElementById("divid"); //获取div节点中的文本。 var text = divNode.innerHTML; alert(text); //改变div中的文本。 divNode.innerHTML = "文本被改了".fontcolor("red"); &#125; //获取文本框节点演示getElementsByName方法 function getNodeDemo2()&#123; var userNode = document.getElementsByName("user")[0]; alert(userNode.value); &#125; //获取超链接节点对象。演示getElementsByTagName方法。 function getNodeDemo3()&#123; //直接用标签名获取。 var nodes = document.getElementsByTagName("a"); for(var x=0; x&lt;nodes.length; x++)&#123; //新窗口打开 nodes[x].target = "_blank"; &#125; &#125; &lt;/script&gt; &lt;input type="button" value="演示document对象获取节点" onclick="getNodeDemo4()" /&gt; &lt;div id="divid"&gt;这是一个div区域&lt;/div&gt; &lt;input type="text" name="user" /&gt; &lt;a href="http://www.sina.com.cn"&gt;网站1&lt;/a&gt; &lt;a href="http://www.SOHU.com.cn"&gt;网站2&lt;/a&gt; &lt;div id="newslink"&gt; &lt;a href="http://www.163.com.cn"&gt;新闻链接1&lt;/a&gt; &lt;a href="http://www.164.com.cn"&gt;新闻链接2&lt;/a&gt; &lt;a href="http://www.itcast.com.cn"&gt;新闻链接3&lt;/a&gt; &lt;/div&gt;&lt;/body&gt; 对于页面中的超链接，新闻链接通过新窗口打开，门户网站链接在当前页面打开 要获取其中被操作的超链接对象，可是通过document获取超链接，拿到的是页面中所有的超链接节点。 只想获取一部分该如何办呢？ 只要获取到被操作的超链接所属的节点即可，再通过这个节点获取到它里面所有的超链接节点 123456789101112function getNodeDemo4()&#123; //获取超链接所属的div节点 var divNode = document.getElementById("newslink"); //通过对div对象方法的查找发现它也具备getElementsByTagName方法。 //记住：所有的容器型标签都具备这个方法。在该标签范围内获取指定名称的标签。 var aNodes = divNode.getElementsByTagName("a"); for(var x=0;x&lt;aNodes.length; x++)&#123; aNodes[x].target = "_blank"; &#125;&#125; 节点层次 通过节点的层次关系获取节点对象 关系： 1、父节点: parentNode:对应一个节点对象 2、子节点：childNodes:对应一个节点集合 3、兄弟节点： 上一个兄弟节点：previousSibling 下一个兄弟节点：nextSibling 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;html&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; function getNodeByLevel()&#123; //获取页面中的表格节点。 var tabNode = document.getElementById("tabid"); //获取父节点 parentNode var node = tabNode.parentNode; alert(node.nodeName);//body //获取子节点 childNodes var nodes = tabNode.childNodes; alert(nodes[0].childNodes[0].nodeName); //获取兄弟节点 //上一个 var node = tabNode.previousSibling; alert(node.nodeName); var node = tabNode.nextSibling.nextSibling; alert(node.nodeName); //尽量少用兄弟节点，因为在解析的时候会出现浏览器不同解析不一致， //会解析出标签间的空白文本节点 &#125;&lt;/script&gt; &lt;input type="button" value="通过节点层次关系获取节点" onclick="getNodeByLevel()" /&gt; &lt;div&gt;div区域&lt;/div&gt; &lt;span&gt;span区域&lt;/span&gt; &lt;table id="tabid"&gt; &lt;tr&gt; &lt;td&gt;单元格一&lt;/td&gt; &lt;td&gt;单元格二&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;span&gt;span区域11&lt;/span&gt; &lt;dl&gt; &lt;dt&gt;上层项目&lt;/dt&gt; &lt;dd&gt;下层项目&lt;/dd&gt; &lt;/dl&gt; &lt;a href=''&gt;一个超链接&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 创建添加节点 需求：在div_1中添加节点 有两种方法： 第一种： 创建节点，使用document中的createTextNode方法 通过getElementById方法，获取div_1节点 将文本节点添加到div_1节点中 第二种： 使用了容器型标签中的一个属性，innerHTML 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=GBK"&gt; &lt;title&gt;Untitled Document&lt;/title&gt;&lt;style type="text/css"&gt; div&#123; border:#00ccff 1px solid; width:200px; padding:30px; margin:10px; &#125; #div_1&#123; background-color:#00ccff; &#125; #div_2&#123; background-color:#FFccff; &#125; #div_3&#123; background-color:#cc00ff; &#125; #div_4&#123; background-color:#00FF00; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; //创建并添加节点。 //需求：在div_1节点中添加一个文本节点。 function crtAndAdd()&#123; //1, 创建节点。使用document中的createTextNode方法。 var oTextNode = document.createTextNode("这是一个新的文本 "); //2，获取div_1节点。 var oDivNode = document.getElementById("div_1"); //3，将文本节点添加到div_1节点中。 oDivNode.appendChild(oTextNode); &#125; //需求：在div_1中创建并添加一个按钮节点。 function crtAndAdd2()&#123; //1,创建一个按钮节点。 var oButNode = document.createElement("input"); oButNode.type = "button"; oButNode.value = "一个新按钮"; //2，获取div_1节点。 var oDivNode = document.getElementById("div_1"); //3，将按钮节点添加到div_1节点中。 oDivNode.appendChild(oButNode); &#125; //通过另一种方式完成添加节点。 function crtAndAdd3()&#123; //1，获取div_1节点。 var oDivNode = document.getElementById("div_1"); //oDivNode.innerHTML = "&lt;input type='button' value='有个按钮'/&gt;"; oDivNode.innerHTML = "&lt;a href='http://www.163.com'&gt;有个超链接&lt;/a&gt;"; &#125;&lt;/script&gt; &lt;input type="button" value="创建并添加节点" onclick="crtAndAdd3()"/&gt; &lt;input type="button" value="删除节点" onclick="delNode()"/&gt; &lt;input type="button" value="修改节点" onclick="updateNode()"/&gt; &lt;input type="button" value="克隆节点" onclick="cloneDemo()"/&gt; &lt;hr/&gt; &lt;div id="div_1"&gt; &lt;/div&gt; &lt;div id="div_2"&gt; 加油，年薪百万在招手！ &lt;/div&gt; &lt;div id="div_3"&gt; div区域演示文字 &lt;/div&gt; &lt;div id="div_4"&gt; 节点的增删改查 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 删除节点 一般用removeChild，获取父节点，删除父的子节点 123456789101112131415//需求将div_2节点删除。 function delNode()&#123; //1,获取div_2节点。 var oDivNode = document.getElementById("div_2"); //2,使用div节点的remvoeNode方法删除 //false 自杀，true 诛九族 //建议试一下false，true看看区别 //oDivNode.removeNode(true);较少用 //一般使用removeChild方法。 删除子节点。 //获取div_2的父节点，然后在用父节点的removeChild，将div_2删除。 oDivNode.parentNode.removeChild(oDivNode);&#125; 替换克隆节点1234567891011121314151617181920212223242526272829303132//需求：用div_3节点替换div_1节点。function updateNode()&#123; //获取div-3和div-1. //使用replaceNode进行替换。 var oDivNode_1 = document.getElementById("div_1"); var oDivNode_3 = document.getElementById("div_3"); //oDivNode_1.replaceNode(oDivNode_3); // 建议使用replaceChild方法。 oDivNode_1.parentNode.replaceChild(oDivNode_3,oDivNode_1);&#125;//需求：希望用div_3替换div-1，并保留div-3节点。//其实就是对div_3进行克隆function cloneDemo()&#123; var oDivNode_1 = document.getElementById("div_1"); var oDivNode_3 = document.getElementById("div_3"); //true 全部克隆，false 自己克隆 var oCopyDiv_3 = oDivNode_3.cloneNode(true); //oDivNode_1.replaceNode(oDivNode_3); // 建议使用replaceChild方法。 oDivNode_1.parentNode.replaceChild(oCopyDiv_3,oDivNode_1);&#125; 练习新闻字体（大中小）需求：新闻字体的大中小样式改变 思路： 1、先有新闻数据，并用标签封装。 2、定义一些页面样式。静态的样式和预定义的样式(用于动态效果，方便于事件处理时的样式加载。) 3、确定事件源和事件，以及处理方式中被处理的节点。 事件源：a标签，事件：onclick，被处理的节点：div-newstext 4、用 Js处理页面的行为 然要给超链接加入自定义的事件处理，就要先取消超链接的默认点击效果 可以使用给 href 设置：javascript:void(0) 来完成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=GBK"&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type="text/css"&gt; /*超链接访问前，访问后样式一致*/ a:link,a:visited&#123; color:#0044ff; text-decoration:none; &#125; a:hover&#123; color:#ff8800; &#125; #newstext&#123; width:500px; border:#00ff00 1px solid; padding:10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; //定义 改变字体 的方法。 function changeFont2(size,clr)&#123; //既然要对div newstext中的文本字体进行操作。 //必须要先获取div节点对象。 var oNewsText = document.getElementById("newstext"); //获取oNewText节点的style样式属性对象。 oNewsText.style.fontSize = size; oNewsText.style.color = clr; &#125; &lt;/script&gt; &lt;h1&gt;这是一个新闻标题&lt;/h1&gt; &lt;hr/&gt; &lt;a href="javascript:void(0)" onclick="changeFont('max')"&gt;大字体&lt;/a&gt; &lt;a href="javascript:void(0)" onclick="changeFont('norm')"&gt;中字体&lt;/a&gt; &lt;a href="javascript:void(0)" onclick="changeFont('min')"&gt;小字体&lt;/a&gt; &lt;div id="newstext" class="norm"&gt; 6月21日，夏至，太阳光将直射北回归线，北半球的白昼也达到了全年最长。 对于北纬40°左右地区，夏至前后几天夜晚可观星的时间只有短短不到5个小 时。即便如此，六月的夜空依然很精彩，土星将在本月迎来冲日，还有几个流 星雨活动，但它们的流量都不大。 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如果根据用户点击所需要的效果不唯一，仅通过传递多个参数虽然可以实现效果 但是存在很多缺点 传参过多，阅读性差 Js 代码和 CSS代码耦合性高 不利于扩展 解决办法： 将多个所需的样式进行封装 封装到选择器中，只要给指定的标签加载不同的而选择器就可以了 1234function changeFont(selectorName)&#123; var oNewsText = document.getElementById("newstext"); oNewsText.className = selectorName;&#125; 全选文本框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;全选&lt;/title&gt; &lt;script&gt; function checkAll()&#123; //1.获取编号前面的复选框 var checkAllEle = document.getElementById("checkAll"); //2.对编号前面复选框的状态进行判断 if(checkAllEle.checked==true)&#123; //3.获取下面所有的复选框 var checkOnes = document.getElementsByName("checkOne"); //4.对获取的所有复选框进行遍历 for(var i=0;i&lt;checkOnes.length;i++)&#123; //5.拿到每一个复选框，并将其状态置为选中 checkOnes[i].checked=true; &#125; &#125;else&#123; //6.获取下面所有的复选框 var checkOnes = document.getElementsByName("checkOne"); //7.对获取的所有复选框进行遍历 for(var i=0;i&lt;checkOnes.length;i++)&#123; //8.拿到每一个复选框，并将其状态置为未选中 checkOnes[i].checked=false; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1" width="500" height="50" align="center" &gt; &lt;thead&gt; &lt;tr&gt; &lt;td colspan="4"&gt; &lt;input type="button" value="添加" /&gt; &lt;input type="button" value="删除" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;input align="" type="checkbox" onclick="checkAll()" id="checkAll"/&gt;全选&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr &gt; &lt;td&gt;&lt;input type="checkbox" name="checkOne"/&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;/tr&gt; &lt;tr &gt; &lt;td&gt;&lt;input type="checkbox" name="checkOne"/&gt;&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;25&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 省市二级联动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;二级联动&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;script&gt; var cities = new Array(3); cities[0] = new Array("武汉市","黄冈市","襄阳市","荆州市"); cities[1] = new Array("长沙市","郴州市","株洲市","岳阳市"); cities[2] = new Array("石家庄市","邯郸市","廊坊市","保定市"); cities[3] = new Array("郑州市","洛阳市","开封市","安阳市"); function changeCity(val) &#123; //1、获取第二个下拉列表 var cityEle = document.getElementById("city"); //2、清空第二个下拉列表的option内容 cityEle.options.length = 0; //3、遍历二维数组中的省份 for(var i=0;i&lt;cities.length;i++)&#123; //注意，比较的是角标 if(val==i)&#123; //4、遍历用户选择的省份下的城市 for(var j=0;j&lt;cities[i].length;j++)&#123; //alert(cities[i][j]); //5、创建城市的文本节点 var textNode = document.createTextNode(cities[i][j]); //6、创建option元素节点 var opEle = document.createElement("option"); //7、将城市的文本节点添加到option元素节点 opEle.appendChild(textNode); //8、将option元素节点添加到第二个下拉列表中去 cityEle.appendChild(opEle); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;table border="1" align="center" height="70%" bgcolor="white"&gt; &lt;tr&gt; &lt;td colspan="2" align="center"&gt; &lt;font size="5"&gt;会员注册&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;籍贯&lt;/td&gt; &lt;td&gt; &lt;select onchange="changeCity(this.value)"&gt; &lt;option&gt;--请选择--&lt;/option&gt; &lt;option value="0"&gt;湖北&lt;/option&gt; &lt;option value="1"&gt;湖南&lt;/option&gt; &lt;option value="2"&gt;河北&lt;/option&gt; &lt;option value="3"&gt;河南&lt;/option&gt; &lt;/select&gt; &lt;select id="city"&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>Dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript入门]]></title>
    <url>%2F2018%2F05%2F29%2FJavaScript%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[概述 Js 是基于对象和事件驱动的脚本语言，主要应用在客户端 特点： 交互性（他可以做信息的动态交互） 安全性（不允许访问本地硬盘） 跨平台性（只要有可以解析 Js 的浏览器就可执行，与平台无关） 区别（Java） 它们分别是不同公司的产品 Js 基于对象，Java面向对象 Js 只需解释就可执行，Java需先编译为字节码文件，再执行 Js 弱类型，Java强类型 结合（HTML） Js和html相结合的方式： 1、将 Js 代码封装到 &lt;script> 标签中。 2、将 Js 代码封装到 Js 文件中，并通过 &lt;script> 中的src属性进行导入。 注意：如果 &lt;script> 标签中使用src属性，那么该标签中封装的 Js 代码不会被执行， 所以通常导入 Js 文件都是用单独 &lt;script> 来完成 1234567&lt;!--导入一个js文件--&gt;&lt;script type="text/javascript" src="demo.js"&gt;&lt;/script&gt;&lt;!--封装javascript代码。--&gt;&lt;script type="text/javascript"&gt; alert("hello javascript");&lt;/script&gt; 语法通用内容通常高级程序设计语言所包含的语法内容： 1、关键字:该种语言中被赋予了特殊含义的单词。 2、标示符:用于标示数据和表达式的符号。通常可以理解为在程序中自定义的名称。比如变量名，函数名。 3、注释:注解说明解释程序。用于调试程序。 4、变量:用于标示内存中一片空间。用于存储数据，该空间的中的数据是可以变化的。 什么时候使用变量，当数据不确定的时候。 5、运算符：可以让数据进行运算的符号。 6、语句:用于对程序的运行流程进行控制的表达式。 7、函数:用于对功能代码进行封装，便于提高复用性。 8、数组:对多数据进行存储，便于操作。就是传说中容器。 9、对象:只要是基于对象的语言，或者是面向对象的语言，就存在着对象的概念，对象就是一个封装体。 既可以封装数据有可以封装函数。 这些都是高级程序设计语言具备的共性内容，只不过各种语言对这些内容的表现形式有所不同, 但是使用基本思想是一致。 变量 Js 中定义变量，使用到关键字 var 定义变量，Js是弱类型的 123456789&lt;script type="text/javascript"&gt; //var不写也行，因为js是非严谨的语言，但是我们开发的时候建议都按照严谨的方式来定义。 var x = 4； x = "abc";//重新赋值为字符串abc。 x = 3.45;//赋值为小数。其实也是数字类型。 x = true;//赋值为boolean类型。 x = 'c';//赋值为字符串c。 alert("x="+x);//这是一个函数，将具体的参数通过对话框进行显示。&lt;/script&gt; 运算符 算术运算符 + - * / % ++ – 赋值运算符 = += -= *= /= %= 比较运算符：运算的结果要么是false要么是true。 > &lt; &gt;= &lt;= != == 逻辑运算符：用来连接两个 Boolean 型的表达式 位运算符 &amp; | ^ &gt;&gt; &lt;&lt; &gt;&gt;&gt; 三元运算符 ? : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script type="text/javascript"&gt; //1、算术运算符演示。 var a = 3710; alert("a="+a/1000*1000);//a=3710; var a1 = 2.3,b1 = 4.7; alert("a1+b1="+(a1+b1));//结果为 7 alert("12"-1);//11 alert("12"+1);//121 alert(true+1);//2 因为在js中false就是0，或者null，非0，非null。就是true。默认用1表示。 alert(2%5);//2 var n = 3,m; m = n++;//若该句为 m=++n n=4,m=4 alert("n="+n+",m="+m);//n=4，m=3 // 2、赋值运算符 var i = 3; i = i+2; i+=2; alert("i="+i); // 3、比较运算符。 var z = 3; alert(z!=4); // 4、逻辑运算符。 var t = 4; alert(t&gt;7 &amp;&amp; t&lt;6); alert(!true);// ！t false // 5、位运算符。 var c = 6; alert(c&amp;3);//2 alert(5^3^3);//5 alert(c&gt;&gt;&gt;1);//6/2的1次方; alert(c&lt;&lt;2);//24 //6，三元运算符。 3&gt;0?alert("yes"):alert("no"); alert(3&gt;10?100:200); &lt;/script&gt; 细节 undefined：未定义，其实它就是一个常量 123456789101112&lt;script type="text/javascript"&gt; var xx; alert(xx);//undefined alert(xx==undefined);//true 可用于健壮性判断 //要想获取具体的值的类型。可以通过typeof来完成。 alert(typeof("abc")=='string');//string alert(typeof(2.5)=='number');//number//判断类型。 alert(typeof(true));//boolean alert(typeof(78));//number alert(typeof('9'));//string&lt;/script&gt; 语句 顺序结构 判断结构 代表语句：if 选择结构 swich 循环结构 while do while for 其他语句 break continue: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script type="text/javascript"&gt; //判断结构 var x = 3; if(4==x)&#123; //建议将常量放左边。以报错来修正代码。 alert("yes"); &#125;else&#123; alert("no"); &#125; //选择结构。 var x = "abc"; switch(x)&#123; case "kk": alert("a"); break; case "abc": alert("b"); break; default: alert("c"); break;//省略。 &#125; //循环结构。 var x = 1; document.write("&lt;font color='blue' &gt;"); while(x&lt;10) &#123; // alert("x="+x); //将数据直接写到当前页面当中。 document.write("x="+x+"&lt;br/&gt;"); x++; &#125; document.write("&lt;/font&gt;"); for(var x=0; x&lt;3; x++)&#123; //别用int document.write("x="+x); &#125; w:for(var x=0; x&lt;3; x++)&#123; for(var y=0; y&lt;4; y++)&#123; document.write("x==="+x); continue w;//跳出当前循环。 &#125; &#125; &lt;/script&gt; 练习 99乘法表，加上样式 12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=GBK"&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link rel="stylesheet" href="table.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; document.write("&lt;table&gt;"); for(var x=1; x&lt;=9; x++)&#123; document.write("&lt;tr&gt;"); for(var y=1; y&lt;=x; y++)&#123; document.write("&lt;td&gt;"+y+"*"+x+"="+y*x+"&lt;/td&gt;"); &#125; document.write("&lt;/tr&gt;"); &#125; document.write("&lt;/table&gt;"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 数组 数组用于存储更多的数据，是一个容器。 特点： 1、长度的是可变的。 2、元素的类型是任意的。 建议在使用数组时，存储同一类型的元素。操作起来较多方便。 1234567js中的数组定义的两种方式：1、 var arr = []; var arr = [3,1,5,8];2、使用了javascript中的Array对象来完成的定义。 var arr = new Array();//var arr = []; var arr1 = new Array(5);//数组定义并长度是5. var arr2 = new Array(5,6,7);//定义一个数组，元素是5,6,7; 函数 函数：就是一个功能的封装体。 定义功能通常需要两个明确。 1、功能的结果 2、功能实现中的参与运算的未知的内容 Js中的定义函数的格式，通过指定的关键字来定义 12345678910111213function 函数名(参数列表)&#123; 函数体：return 返回值;//如果没有具体的返回值，return语句可以省略不写。&#125;&lt;script type="text/javascript"&gt; function add(x,y)&#123; return x+y; &#125; var sum = add(4,5); alert("sum="+sum);&lt;/script&gt; 细节 1、只要使用函数的名称就是对这个函数的调用。 2、函数中有一个数组在对传入的参数进行存储。这个数组就是arguments 12345678910&lt;script type="text/javascript"&gt; function show(x,y)&#123; alert(arguments.length); alert(x+":"+y); for(var a=0;a&lt;arguments.length; a++)&#123; document.write(arguments[a]); &#125; &#125; show(4,5,6,9,7,4);//建议函数中定义几个参数就传递几个实参。&lt;/script&gt; 小细节2 1234567891011121314151617181920212223&lt;script type="text/javascript"&gt; function getSum()&#123; return 100; &#125; //getSum函数运行，并将返回的结果赋值给sum var sum = getSum(); //getSum本身是一个函数名，而函数本身在js中就是一个对象。getSum就是这个函数对象的引用. //将getSum这个引用的地址赋值给sum。这时sum也指向了这个函数对象。 //相当于这个函数对象有两个函数名称 var sum = getSum; //打印时候如果sum指向的是函数对象，那么会将该函数对象的字符串表现形式打印出来 //就是该函数的代码定义格式 alert("sum="+sum);， function show2()&#123; alert("show2 run"); &#125; alert(show2()); //show2 run undefined //因为有两个alert&lt;/script&gt; 动态函数 Js函数的其他表现形式 动态函数：使用的是Js中内置的一个对象Function 只不过用的不是很多 参数列表，函数体都是通过字符串动态指定的 12345678&lt;script type="text/javascript"&gt; //参数列表，函数体都是通过字符串动态指定的 var add = new Function("x,y","var sum; sum=x+y; return sum;"); var he = add(4,8); alert("he="+he); &lt;/script&gt; 匿名函数 匿名函数：没有名字的函数，通常是函数的简写形式。 123456789101112131415161718192021&lt;script type="text/javascript"&gt; //示例一 var add3 = function (a,b)&#123; return a+b; &#125; alert(add3(7,8)); //示例二 function haha() &#123; alert("haha run"); &#125; var xixi = haha; //上述代码可以简写成下面的方式。 var xixi = function() &#123; alert("haha run"); &#125;&lt;/script&gt; 练习一 综合练习： 1、定义功能，完成对数组的最值获取 2、对数组排个序 3、对数组查个找 4、对数组元素进行反转 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;script type="text/javascript"&gt; var arr = [66,13,37,21,89,17]; //取最值。 function getMax(arr)&#123; var max = 0; for(var x=1; x&lt;arr.length; x++)&#123; if(arr[x]&gt;arr[max]) max = x; &#125; return arr[max]; &#125; var maxValue = getMax(arr); //排序。 function sortArray(arr)&#123; for(var x=0; x&lt;arr.length-1; x++)&#123; for(var y=x+1; y&lt;arr.length; y++)&#123; if(arr[x]&gt;arr[y])&#123; swap(arr,x,y); &#125; &#125; &#125; &#125; //数组中的元素位置置换。 function swap(arr,x,y)&#123; var temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125; function println(val)&#123; document.write(val+"&lt;br/&gt;"); &#125; println("排序前:"+arr) sortArray(arr); println("排序后:"+arr) &lt;/script&gt; &lt;script type="text/javascript"&gt; //查找。 function searchElement(arr,key)&#123; for(var x=0;x&lt;arr.length; x++)&#123; if(arr[x]==key) return x; &#125; return -1; &#125; //折半，必须有前提。必须是有序的数组。 function binarySearch(arr,key)&#123; var max,min,mid; min = 0; max = arr.length-1; while(min&lt;=max)&#123; mid = (max+min)&gt;&gt;1; if(key&gt;arr[mid]) min = mid + 1; else if(key&lt;arr[mid]) max = mid - 1; else return mid; &#125; return -1; &#125; //对数组的反转。 function reverseArray(arr)&#123; for(var start=0,end=arr.length-1; start&lt;end; start++,end--)&#123; swap(arr,start,end); &#125; &#125; reverseArray(arr); println("反转后:"+arr); &lt;/script&gt; 全局和局部变量 在脚本片段中定义的变量，是全局变量 函数内定义的变量，是局部变量 1234567891011121314151617181920212223&lt;script type="text/javascript"&gt;// for(var x=0; x&lt;3; x++)&#123;//在脚本片段中定义的变量，是全局变量。// document.write("x="+x);// &#125; // function show()&#123;// var x = 6;//局部变量。// &#125; // document.write("X======="+x); var x = 3;//全局变量x. function show(x)&#123;//函数局部的变量x x = 8; &#125; show(x); document.write("x="+x);//x=3; &lt;/script&gt; 常见对象Object toString()：将对象变成字符串 valueOf()：返回制定对象原始值 1234567891011121314151617&lt;script type="text/javascript"&gt; function show()&#123; alert("show run"); &#125; alert(show.toString()); var arr = [3,4,1,6,8]; alert(arr.toString()); var abc = function()&#123; alert("abc run"); &#125; alert(abc); alert(abc.valueOf());&lt;/script&gt; String Js相比 Java 的String少很多功能 我们可以自行添加 1234567891011//out.js//打印指定参数数据到页面上，并换行function println(param)&#123; document.write(param+"&lt;br/&gt;");&#125;//out.js打印指定参数数据到页面上。function print(param)&#123; document.write(param);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;body&gt;//导入out.js&lt;script type="text/javascript" src="out.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="stringtool.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //演示简单功能 var str = "abcde"; println("len="+str.length); println(str.bold());//加粗 println(str.fontcolor("red"));//字体颜色。 println(str.link("http://www.163.com"));//将字符串变成超链接。 println(str.substr(1,3));//bcd println(str.substring(1,3));//bc //自定义 //去除字符串两端的空格。 function trim(str)&#123; //定义两个变量，一个记录开始的位置。一个记录结束的位置。 //对开始的位置 的字符进行判断，如果是空格，就进行递增，直到不是空格为止。 //对结束的位置 的字符进行判断，如果是空格，就进行递减，直到不是空格为止。 //必须要保证开始&lt;=结束，这样才可以进行截取。 var start,end; start=0; end=str.length-1; while(start&lt;=end &amp;&amp; str.charAt(start)==' ')&#123; start++; &#125; while(start&lt;=end &amp;&amp; str.charAt(end)==" ")&#123; end--; &#125; return str.substring(start,end+1); &#125; var s = " ab c "; alert("-"+trim(s)+"-"); //alert("abc".bold());//&lt;b&gt;this&lt;/b&gt;//给string的原型中添加一个功能。 注意：给对象添加新功能直接使用 对象.新内容 即可。// String.prototype.len = 199;//给string的原型对象中添加一个属性 名为len。值为199.//添加行为。// println("abc".len);// alert("-"+" ab cd ".trim()+"-");&lt;/script&gt;&lt;/body&gt; 既然trim方法是用来操作字符串的方法，可不可以像字符串已有的方法一样， 将该方法也定义到字符串对象中呢？直接用字符串对象调用就欧了 原型 这里就可以使用一个该字符串的原型属性来完成： 原型：就是该对象的一个描述。该描述中如果添加了新功能，那么该对象都会具备这些新功能。 而prototype就可以获取到这个原型对象，通过prototype就可以对对象的功能进行扩展。 需求：想要给string对象添加一个可以去除字符串两端空格的新功能，就可以使用原型属性来完成。 12345678910111213141516171819&lt;script&gt; //String.prototype.mytrim = trim(); //在已有该函数时也可以这样写 String.prototype.trim = function()&#123; //匿名函数 var start,end; start=0; end=this.length-1; while(start&lt;=end &amp;&amp; this.charAt(start)==' ')&#123; start++; &#125; while(start&lt;=end &amp;&amp; this.charAt(end)==" ")&#123; end--; &#125; return this.substring(start,end+1); &#125;&lt;/script&gt; 我们来试着用原型完成一个小练习 添加一个，将字符串进行反转的方法 1234567891011121314151617String.prototype.reverse = function()&#123; var arr = this.toCharArray(); //将数组位置置换功能进行封装。并定义到了反转功能内部。 function swap(arr,a,b)&#123; var temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; for(var x=0,y=arr.length-1; x&lt;y ; x++,y--)&#123; swap(arr,x,y); &#125; return arr.join("");&#125; Array 在下面代码中展示了一些常用的Array方法 concat、join、pop、reverse、shift、sort、splice、unshift 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script type="text/javascript" src="../demo/out.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var arr = ["nba","haha","cba","aaa","abc"]; var arr2 = ["qq","xiaoqiang",70]; //在arr数组上连接一个元素"mm"，再连接一个arr2数组 //将mm作为新数组中的元素，将arr2数组中的元素也作为新数组中的元素 var newArr = arr.concat("mm",arr2); println(newArr); println(arr.join("-")); println(myJoin(arr,"+"));//以"+"为分隔符 //模拟一下的join的实现原理 function myJoin(arr,separator)&#123; var str = ""; for(var x=0;x&lt;arr.length ; x++)&#123; if(x!=arr.length-1) str += arr[x]+separator; else str += arr[x]; &#125; return str; &#125; //移除数组中的元素，并返回该元素。pop println("&lt;hr/&gt;"); println(arr.pop());//删除并返回最后一个元素。 println(arr.reverse());//反转 println(arr.shift());//删除并返回第一个元素 println(arr); println(arr); arr.sort(); //删除元素并可以进行元素的替换。 var temp = arr.splice(1,3,8080,9527,"xixixi","wangcai"); println(temp); println(arr.unshift("uuuu"));//在头部插入 println(arr);&lt;/script&gt; pop() 方法是删除最后一个元素，unshift()方法是在头部插入 那么是不是可以用他们做出堆栈，队列那？可以自己试试呀 Date12345678910111213141516171819202122232425262728293031&lt;script type="text/javascript" src="out.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var date = new Date(); println(date); println(date.toLocaleString());//日期和时间 println(date.toLocaleDateString());//只有日期。 function getWeek(num)&#123; var weeks = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六']; return weeks[num]; &#125; // 日期对象和毫秒值之间的转换 var date2 = new Date(); //获取毫秒值 日期对象--&gt;毫秒值 var time = date2.getTime(); println("time:"+time);//1338191622156 //将毫秒值转成日期对象。 //1、new Date(time);//setTime(); var date3 = new Date(time); //将日期对象和字符串之间进行转换 //日期对象转成字符串，toLocaleString toLocaleDateString //将字符串转成日期对象，具备指定格式的日期字符串--&gt;毫秒值---&gt;日期对象 var str_date = "9/28/2017"; var time2 = Date.parse(str_date); var date3 = new Date(time2); println(date3.toLocaleDateString());&lt;/script&gt; Math 该对象的中的方法都是静态的。不需要new，直接Math调用即可 123456789101112131415161718192021222324252627282930&lt;script type="text/javascript" src="out.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var num1 = Math.ceil(12.34);//返回大于等于指定参数的最小整数。 var num2 = Math.floor(12.34);//返回小于等于指定数据的最大整数。 var num3 = Math.round(12.54);//四舍五入 println("num1="+num1); //13 println("num2="+num2); //12 println("num3="+num3); //13 var num4 = Math.pow(10,2);//10的2次方 println("num4="+num4); println("&lt;hr/&gt;"); for(var x=0; x&lt;10; x++)&#123; //伪随机数// var num = Math.floor(Math.random()*10+1); //ParseInt 全局方法 var num = parseInt((Math.random()*10+1)); println(num); &#125; //将指定进制格式的字符串转成十进制 var num = parseInt("110",2); println("num="+num); var num1 = parseInt('0x3c',16); println("num1="+num1);&lt;/script&gt; 全局方法 全局对象都在 global 中, 如 ParseInt 12345678910111213parseInt("123");println(parseInt("123")+1);var val = parseInt("12abc");//val = 12;val val = parseInt("abc12");//非法，返回NANprintln("value="+val);//通过isNaN来判断结果是否非法。//将指定进制格式的字符串转成十进制var num = parseInt("110",2);println("num="+num);var num1 = parseInt('0x3c',16);println("num1="+num1); Number 我们刚刚在ParseInt 里，已经知道了怎么将指定进制转换十进制 那么如何把十进制 转换为 指定进制 那？ 12345678//将十进制转成其他进制，使用数字对象完成 var num3 = new Number(6);println("num3="+num3.toString(2));var num4 = 60;println("num4="+num4.toString(16)); 特有语句 为了简化对象调用内容的书写，可以使用 Js中的特有语句 with 来完成。 12345678910111213141516171819202122/*格式： with(对象) &#123; 在该区域中可以直接使用指定的对象的内容。不需要写对象. &#125;*/ // var year = date.getFullYear();// var month = date.getMonth()+1;// var day = date.getDate();// var week = getWeek(date.getDay());with(date)&#123; var year = getFullYear(); var month = getMonth()+1; var day = getDate(); var week = getWeek(getDay()); println(year+"-----"+month+"---+--"+day+"-----"+week);&#125; for in ：对对象进行变量的语句 12345678910var arr = [32,80,65];for(i in arr)&#123;println("i="+arr[i]);&#125;println("&lt;hr/&gt;");for(x in numObj)&#123;println(x);&#125; 自定义对象 如果想要自定义对象，应该先对对象进行描述 Js是基于对象，不是面向对象的，不具备描述事物的能力 我们还想按照面向对象的思想编写 Js 就要先描述，在 Js中，可以用函数来模拟面对对象的中的描述 12345678910111213141516171819202122232425//用js来描述人function Person()&#123;//相当于构造器。 alert("person run");&#125;//通过描述进行对象的建立。 new.var p = new Person();//动态给p对象添加属性。直接使用p.属性名即可。p.name = "zhangsan";p.age = 29;//如果定义的p对象的属性赋值为一个函数，即是给p对象添加一个方法。p.show = function()&#123; alert("show :"+this.name+":"+this.age);&#125;p.show();var obj = new Object();obj.name = "god father";obj.age = 2012;alert(obj.name+":"+obj.age); 封装 12345678910111213141516171819202122function Person(name,age)&#123; //在给Person对象添加了两个属性。 this.name = name; this.age = age; this.setName = function(name)&#123; this.name = name; &#125; this.getName = function()&#123; return this.name; &#125;&#125; var p = new Person("旺财",20);for(x in p)&#123; //记得导入out.js println(x+":"+p[x]);&#125;p.setName("小强");alert(p.getName()); 直接使用{}定义属性和值的键值对方式。键值键通过:连接，键与键之间用逗号隔开 12345678910111213141516171819202122232425262728var pp = &#123; //定义一些成员。 "name":"小明","age":38, "getName":function()&#123; return this.name; &#125; &#125; //对象调用成员有两种方式：对象.属性名 对象["属性名"]alert(pp["age"]+":"+pp.name); //用js实现键值对映射关系的集合容器。 var oMap = &#123; 8:"小强",3:"旺财",7:"小明"&#125; var val1 = oMap[8];alert("val1:"+val1);var val2 = get(7);alert("val2:"+val2);function get(key)&#123; return oMap[key];&#125; 定义对象 比较常用map，键值对的形式 123456789101112131415161718192021var myobj = &#123; myname:"lisisi",myage:30&#125; alert(myobj.myname+":"+myobj["myage"]);var myobj2 = &#123; "myname2":"hahahah","myage2":48&#125;alert(myobj2.myname2+":"+myobj2["myage2"]);var myMap = &#123; //names:["lsii1","lisi2","lisi4"],nums:[34,10,48] names:[&#123;name1:"zhangsan"&#125;,&#123;myname:"hahahah"&#125;]&#125;alert(myMap.names[1]);alert(myMap.names[0].name1);]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-正则表达式]]></title>
    <url>%2F2018%2F05%2F27%2FJava-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述 在讲正则表达式之前，让我们先完成一个小程序 需求：定义一个功能对QQ号进行校验。 要求：长度5~15. 只能是数字， 0不能开头 12345678910111213141516171819//太复杂public static void checkQQ(String qq)&#123; int len = qq.length(); if(len&gt;=5 &amp;&amp; len&lt;=15)&#123; if(!qq.startsWith("0"))&#123; try &#123; long l = Long.parseLong(qq); System.out.println(l+":正确"); &#125;catch(NumberFormatException e)&#123; System.out.println(qq+":含有非法字符"); &#125; &#125;else&#123; System.out.println(qq+":不能0开头"); &#125; &#125;else&#123; System.out.println(qq+":长度错误"); &#125;&#125; 1234String qq = "12346578";String regex = "[1-9][0-9]&#123;4,14&#125;";//正则表达式boolean b = qq.matches(regex); System.out.println(qq+":"+b); 你能想象到，之前那么多行的程序，可以被短短几行代码表达出来吗？ 正则表达式用于操作字符串数据，通过一些特定的符号来体现的。 所以我们为了掌握正则表达式，必须要学习一些符号。虽然简化了，但是阅读性差 规则 可以选择看API文档中 java.util.regex 目录下的Pattern类，或者下面的连接教程 正则表达式-语法 常用功能匹配 使用的就是String类中的matches方法 假设手机号只有13***,15***,18***这几个频段 1234567public static void functionDemo_1()&#123; //匹配手机号码是否正确。 String tel = "15800001111"; String regex = "1[358]\\d&#123;9&#125;"; boolean b = tel.matches(regex); System.out.println(tel+":"+b);&#125; 切割 使用的就是String类中的split方法 需求：想要以连续的出现的任意相同字母为切割符 那么就是用”.“ 来表示任意字符，它后面的字符应该是跟他一样的，所以把 . 用小括号括起来 这就是组，它是字符串中第一组被包起来的，所以后面用 “\\1”表示它，+代表可以出现1或多次 1234567891011public static void functionDemo_2()&#123; String str = "zhangsanttttxiaoqiangmmmmmmzhaoliu"; String[] names = str.split("(.)\\1+"); for(String name : names)&#123; System.out.println(name); &#125;&#125; 那么 ( ( a ) ( b ( c ) ) ) 分别是几组那？ 第一组： ( ( a ) ( b ( c ) ) ) 第二组： \a 第三组： ( b ( c ) ) 第四组： ( c ) 替换 使用的就是String类中的 replaceAll() 方法 需求1：将连续出现的字符，替换为一个该字符 需求2：输入手机号，将第4-7位替换为* 1234567891011121314public static void functionDemo_3() &#123; String str = "zhangsanttttxiaoqiangmmmmmmzhaoliu"; // $代表前一个参数，$1 前一个参数的第一组 str = str.replaceAll("(.)\\1+", "$1"); System.out.println(str); String tel = "15800001111";//158****1111; // 将手机号切割，前三位，后四位各为一组 tel = tel.replaceAll("(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)", "$1****$2"); System.out.println(tel);&#125; 获取 将正则规则进行对象的封装 通过正则对象的matcher方法字符串相关联。获取要对字符串操作的匹配器对象Matcher 通过Matcher匹配器对象的方法对字符串进行操作 123Pattern p = Pattern.compile("a*b");Matcher m = p.matcher("aaaaab");boolean b = m.matches(); 需求：获取字符串中的 三个字符的单词 123456789101112131415161718192021public static void functionDemo_4() &#123; String str = "da jia hao,ming tian bu fang jia!"; String regex = "\\b[a-z]&#123;3&#125;\\b"; //1,将正则封装成对象。 Pattern p = Pattern.compile(regex); //2, 通过正则对象获取匹配器对象。 Matcher m = p.matcher(str); //使用Matcher对象的方法对字符串进行操作。 //既然要获取三个字母组成的单词 //查找。 find(); System.out.println(str); while(m.find())&#123; System.out.println(m.group());//获取匹配的子序列 System.out.println(m.start()+":"+m.end()); &#125;&#125; 练习 1、治疗口吃:我我…我我…我我我爱…爱爱爱爱…爱爱..学学学学学…学学..习习习习.习 2、对IP地址排序。 192.168.10.34 127.0.0.1 3.3.3.3 105.70.11.55 3、对邮件地址校验。 12345678910111213//练习1public static void test_1()&#123; String str = "我我...我我...我我我爱...爱爱爱爱...爱爱..学学学学学...学学..习习习习.习"; //1，将字符串中.去掉 用替换。 str = str.replaceAll("\\.+", ""); System.out.println(str); //2,替换叠词。 str = str.replaceAll("(.)\\1+", "$1"); System.out.println(str); &#125; 12345678910111213141516171819202122232425262728//练习2public static void test_2()&#123; String ip_str = "192.168.10.34 127.0.0.1 3.3.3.3 105.70.11.55"; //1,为了让ip可以按照字符串顺序比较，只要让ip的每一段的位数相同。 //所以，补零，按照每一位所需做多0进行补充。每一段都加两个0. ip_str = ip_str.replaceAll("(\\d+)", "00$1"); System.out.println(ip_str); //然后每一段保留数字3位。 ip_str = ip_str.replaceAll("0*(\\d&#123;3&#125;)", "$1"); System.out.println(ip_str); //2、将ip地址切出。 String[] ips = ip_str.split(" +"); TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(); for(String ip : ips)&#123; ts.add(ip); &#125; for(String ip : ts)&#123; System.out.println(ip.replaceAll("0*(\\d+)", "$1")); &#125;&#125; 123456789101112//练习3public static void test_3() &#123; String mail = "abc1@sina.com.cn"; String regex = "^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$"; boolean b = mail.matches(regex); System.out.println(mail+":"+b);&#125; 练习（爬取邮箱）12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class RegexTest2 &#123; public static void main(String[] args) throws IOException &#123; List&lt;String&gt; list = getMailsByWeb(); for(String mail : list)&#123; System.out.println(mail); &#125; &#125; public static List&lt;String&gt; getMailsByWeb() throws IOException &#123; //1,读取源文件。 URL url = new URL("http://192.168.1.100:8080/myweb/mail.html"); BufferedReader bufIn = new BufferedReader(new InputStreamReader(url.openStream())); //2,对读取的数据进行规则的匹配。从中获取符合规则的数据. String mail_regex = "\\w+@\\w+(\\.\\w+)+"; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Pattern p = Pattern.compile(mail_regex); String line = null; while((line=bufIn.readLine())!=null)&#123; Matcher m = p.matcher(line); while(m.find())&#123; //3,将符合规则的数据存储到集合中。 list.add(m.group()); &#125; &#125; return list; &#125; //爬取本地文件 public static List&lt;String&gt; getMails() throws IOException&#123; //1,读取源文件。 BufferedReader bufr = new BufferedReader(new FileReader("c:\\mail.html")); //2、剩下的和上面的一样了（从第二步骤开始） //记得将 bufIn 改为 bufr &#125; &#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-反射]]></title>
    <url>%2F2018%2F05%2F27%2FJava-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[概述 JAVA反射机制是在运行状态中，对于任意一个类 (class文件)，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性； 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 动态获取类中信息，就是java反射 ，可以理解为对类的解剖。 原理 以Tomcat为例，它对外提供了一个接口是，servlet，我们在写程序的时候可以继承这个接口 可是我们怎么让Tomcat识别我们的程序那，在Tomcat里new 一个？ 我们把我们程序的配置信息写在配置文件中，这样Tomcat就可以识别我们的程序了 反射机制 使用 Java 反射机制可以在运行时期检查 Java 类的信息， 检查 Java 类的信息往往是你在使用 Java 反射机制的时候所做的第一件事情 通过获取类的信息你可以获取以下相关的内容： Class对象 要想要对字节码文件进行解剖，必须要有字节码文件对象，如何获取字节码文件对象呢？ 第一种方式： Object类中的getClass()方法的 必须要明确具体的类，并创建对象，太麻烦 12345678910public static void getClassObject_1()&#123; Person p = new Person(); Class clazz = p.getClass(); Person p1 = new Person(); Class clazz1 = p1.getClass(); System.out.println(clazz==clazz1);&#125; 第二种方式： 任何数据类型都具备一个静态的属性.class来获取其对应的Class对象 相对简单，但是还是要明确用到类中的静态成员，还是不够扩展 1234567public static void getClassObject_2() &#123; Class clazz = Person.class; Class clazz1 = Person.class; System.out.println(clazz==clazz1);&#125; 第三种方式 可使用Class类中的 forName() 方法完成 只要通过给定的类的 字符串名称就可以获取该类，更为方便，扩展性更强 12345678public static void getClassObject_3() throws ClassNotFoundException &#123; //类名记住一定要写全 String className = "cn.java.bean.Person"; Class clazz = Class.forName(className); System.out.println(clazz);&#125; 构造函数 早期：使用 new 的时候，先根据被new的类的名称找寻该类的字节码文件，并加载进内存， 并创建该字节码文件对象，并接着创建该字节文件的对应的Person对象 1cn.java.bean.Person p = new cn.java.bean.Person(); 现在： 12345String name = "cn.java.bean.Person";//找寻该名称类文件，并加载进内存，并产生Class对象。Class clazz = Class.forName(name);//如何产生该类的对象呢？Object obj = clazz.newInstance(); 当获取指定名称对应类中的所体现的对象时， 而该对象初始化不使用空参数构造该怎么办呢？ 既然是通过指定的构造函数进行对象的初始化， 所以应该先获取到该构造函数。 通过字节码文件对象即可完成。 该方法是：getConstructor(paramterTypes); 12345678String name = "cn.java.bean.Person";//找寻该名称类文件，并加载进内存，并产生Class对象。Class clazz = Class.forName(name);//获取到了指定的构造函数对象。Constructor constructor = clazz.getConstructor(String.class,int.class);//通过该构造器对象的newInstance方法进行对象的初始化。Object obj = constructor.newInstance("小明",38); 字段123456789101112131415161718192021public static void getFieldDemo() throws Exception &#123; Class clazz = Class.forName("cn.java.bean.Person"); Field field = null;//clazz.getField("age");//只能获取公有的， field = clazz.getDeclaredField("age");//只获取本类，但包含私有。 //对私有字段的访问取消权限检查。暴力访问。 field.setAccessible(true); Object obj = clazz.newInstance(); field.set(obj, 89); Object o = field.get(obj); System.out.println(o); //上述语句，和下面语句实现了一样的功能 //cn.java.bean.Person p = new cn.itcast.bean.Person(); //p.age = 89;&#125; 方法 获取指定Class中的所有公共函数 12345678910public static void getMethodDemo() throws Exception &#123; Class clazz = Class.forName("cn.itcast.bean.Person"); Method[] methods = clazz.getMethods();//获取的都是公有的方法。 methods = clazz.getDeclaredMethods();//只获取本类中所有方法，包含私有。 for(Method method : methods)&#123; System.out.println(method); &#125;&#125; 获取指定Class中的指定空参方法 123456789101112public static void getMethodDemo_2() throws Exception &#123; Class clazz = Class.forName("cn.itcast.bean.Person"); Method method = clazz.getMethod("show", null);//获取空参数一般方法。 Constructor constructor = clazz.getConstructor(String.class,int.class); Object obj = constructor.newInstance("小明",37); method.invoke(obj, null);&#125; 获取指定Class中指定有参方法 1234567891011public static void getMethodDemo_3() throws Exception &#123; Class clazz = Class.forName("cn.itcast.bean.Person"); Method method = clazz.getMethod("paramMethod", String.class,int.class); Object obj = clazz.newInstance(); method.invoke(obj, "小强",89);&#125; 演示类（Person）123456789101112131415161718192021222324252627282930313233343536373839package cn.java.bean;public class Person &#123; private int age; private String name; public Person(String name,int age) &#123; super(); this.age = age; this.name = name; System.out.println("Person param run..."+this.name+":"+this.age); &#125; public Person() &#123; super(); System.out.println("person run"); &#125; public void show()&#123; System.out.println(name+"...show run..."+age); &#125; private void privateMethod()&#123; System.out.println(" method run "); &#125; public void paramMethod(String str,int num)&#123; System.out.println("paramMethod run....."+str+":"+num); &#125; public static void staticMethod()&#123; System.out.println(" static method run......"); &#125;&#125; 练习 需求：简易模拟电脑运行，需要声卡和网卡 因为后期可能有各种设备，所以创建接口，让设备继承接口 12345678910111213141516171819202122232425//接口public interface PCI &#123; public void open(); public void close();&#125;public class SoundCard implements PCI &#123; public void open()&#123; System.out.println("sound open"); &#125; public void close()&#123; System.out.println("sound close"); &#125;&#125;public class NetCard implements PCI &#123; public void open() &#123; System.out.println("net open"); &#125; public void close() &#123; System.out.println("net close"); &#125;&#125; 模拟主板 12345678910111213public class Mainboard &#123; public void run() &#123; System.out.println("main board run...."); &#125; public void usePCI(PCI p) &#123;//PCI p = new SouncCard(); if (p != null) &#123; p.open(); p.close(); &#125; &#125;&#125; 每次添加设备都要修改代码传递新对象吗？可以不修改代码完成该动作吗？ 创建一个配置文件，包含着各设备信息，主类中调取并实现创建对象的动作 12345678910111213141516171819202122232425262728293031public class ReflectTest &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; Mainboard mb = new Mainboard(); mb.run(); File configFile = new File("pci.properties"); Properties prop = new Properties(); FileInputStream fis = new FileInputStream(configFile); prop.load(fis); for(int x=0; x&lt;prop.size(); x++)&#123; String pciName = prop.getProperty("pci"+(x+1)); Class clazz = Class.forName(pciName);//用Class去加载这个pci子类。 //这里实例化的对象，肯定是PCI的对象 PCI p = (PCI)clazz.newInstance(); mb.usePCI(p); &#125; fis.close(); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-网络编程]]></title>
    <url>%2F2018%2F05%2F26%2FJava-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述 下面给了两个链接，是关于OSI模型和TCPIP模型 网络七层模型及四层模型详解 网络编程完全总结 网络要素IP地址 网络中设备的标识 不易记忆，可用主机名 本地回环地址：127.0.0.1 主机名：localhost IP对象123456public static void main(String[] args) throws UnknownHostException &#123; InetAddress ip = InetAddress.getLocalHost(); System.out.println(ip.getHostName()+":::"+ip.getHostAddress()); ip = InetAddress.getByName("www.baidu.com"); System.out.println(ip.getHostName()+":::"+ip.getHostAddress()); &#125; 端口号 用于标识进程的逻辑地址，不同进程的标识 有效端口：0~65535，其中0~1024为系统保留端口 传输协议 通讯的规则 常见协议：TCP，UDP UDP 将数据及源和目的封装在数据包内，不需要建立连接 将每个数据包大小限制在64K内 无连接，是不可靠协议 不需建立连接，所以速度快 TCP 建立连接，形成传输数据的通道 在连接中进行大数据量传输 通过三次握手完成连接，可靠协议 必须建立连接，效率会稍低 域名解析 DNS( Domain Name System)是“域名系统”的英文缩写 它用于TCP/IP网络，提供的服务是用来将主机名和域名转换为IP地址的工作 当输入一个域名时，会先在本地的hosts下解析，如果没有就通过DNS解析为IP地址 屏蔽恶意网站原理 在本地 C:\Windows\System32\drivers\etc 目录下，有一个hosts文件 在最后面加上 127.0.0.1 www.xxxxx.com 那么这个网站就会被屏蔽掉了 socket编程UDP协议发送端 思路 1，建立UDP的socket服务 2、将要发送的数据封装到数据包中 3、通过UDP的socket服务将数据包发送出去 4、关闭socket服务 12345678910111213141516171819public static void main(String[] args) throws IOException &#123; System.out.println("发送端启动......"); //1、udpsocket服务。使用DatagramSocket对象。 DatagramSocket ds = new DatagramSocket(); //2、将要发送的数据封装到数据包中。 String str = "嘎嘎嘎嘎"; //使用DatagramPacket将数据封装到的该对象包中。 byte[] buf = str.getBytes(); DatagramPacket dp = new DatagramPacket(buf,buf.length, InetAddress.getByName("172.20.10.12"),10000); //3、通过udp的socket服务将数据包发送出去。使用send方法。 ds.send(dp); //4、关闭资源。 ds.close();&#125; 接收端 思路： 1、建立UDP socket服务,因为是要接收数据，必须要明确一个端口号 2、创建数据包，用于存储接收到的数据。方便用数据包对象的方法解析这些数据 3、使用socket服务的receive方法将接收的数据存储到数据包中 4、通过数据包的方法解析数据包中的数据 5、关闭资源 1234567891011121314151617181920212223242526public static void main(String[] args) throws IOException &#123; System.out.println("接收端启动......"); //1,建立udp socket服务。 DatagramSocket ds = new DatagramSocket(10000); //2,创建数据包。 byte[] buf = new byte[1024]; DatagramPacket dp = new DatagramPacket(buf,buf.length); //3,使用接收方法将数据存储到数据包中。 ds.receive(dp);//阻塞式的。 //4，通过数据包对象的方法，解析其中的数据,比如，地址，端口，数据内容。 String ip = dp.getAddress().getHostAddress(); int port = dp.getPort(); String text = new String(dp.getData(),0,dp.getLength()); System.out.println(ip+":"+port+":"+text); //5,关闭资源。 ds.close();&#125; 先开启接收端，再开启发送端 注意：发送端的DatagramPacket和接收端的DatagramSocket 端口需要一致 TCP协议客户端 客户端发数据到服务端 TCP传输，客户端建立的过程： 1、创建TCP客户端socket服务。使用的是Socket对象，建议该对象一创建就明确目的地，要连接的主机 2、如果连接建立成功，说明数据传输通道已建立。该通道就是socket流 ,是底层建立好的。 ​ 既然是流，说明这里既有输入，又有输出。想要输入或者输出流对象，可以找Socket来获取。 ​ 可以通过getOutputStream()，和getInputStream()来获取两个字节流。 3、使用输出流，将数据写出 4、关闭资源 1234567891011121314151617181920public static void main(String[] args) throws UnknownHostException, IOException &#123; Socket socket = new Socket("172.20.10.12",10002); OutputStream out = socket.getOutputStream(); out.write("tcp演示：哥们又来了!".getBytes()); //读取服务端返回的数据,使用socket读取流。 InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String text = new String(buf,0,len); System.out.println(text); //关闭资源。 socket.close();&#125; 服务端 服务端接收客户端发送过来的数据，并打印在控制台上。 建立TCP服务端的思路： 1、创建服务端socket服务。通过ServerSocket对象。 2、服务端必须对外提供一个端口，否则客户端无法连接 3、获取连接过来的客户端对象 4、通过客户端对象获取socket流读取客户端发来的数据，并打印在控制台上 5、关闭资源。关客户端，关服务端 1234567891011121314151617181920212223242526public static void main(String[] args) throws IOException &#123; //1创建服务端对象。 ServerSocket ss = new ServerSocket(10002); //2,获取连接过来的客户端对象。 Socket s = ss.accept(); String ip = s.getInetAddress().getHostAddress(); //3，通过socket对象获取输入流，要读取客户端发来的数据 InputStream in = s.getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String text = new String(buf,0,len); System.out.println(ip+":"+text); //使用客户端socket对象的输出流给客户端返回数据 OutputStream out = s.getOutputStream(); out.write("收到".getBytes()); s.close(); ss.close(); &#125; 练习一需求 客户端输入字母数据，发送给服务端，服务端收到后显示在控制台， 并将该数据转成大写返回给客户端，直到客户端输入over.转换结束. 创建一个英文大写转换服务器 分析： 有客户端和服务端，使用TCP传输 客户端编写 客户端思路： 1、需要先有socket端点 2、客户端的数据源：键盘 3、客户端的目的：socket 4、接收服务端的数据，源：socket 5、将数据显示在打印出来：目的：控制台 6、在这些流中操作的数据，都是文本数据 转换客户端思路： 1、创建socket客户端对象 2、获取键盘录入 3、将录入的信息发送给socket输出流 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) throws UnknownHostException, IOException &#123; //1、创建socket客户端对象。 Socket s = new Socket("192.168.1.100",10004); //2、获取键盘录入。 BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in)); //3、socket输出流。 PrintWriter out = new PrintWriter(s.getOutputStream(),true); //4、socket输入流，读取服务端返回的大写数据 BufferedReader bufIn = new BufferedReader(new InputStreamReader(s.getInputStream())); String line = null; while((line=bufr.readLine())!=null)&#123; if("over".equals(line)) break;// out.print(line+"\r\n");// out.flush(); out.println(line); //读取服务端发回的一行大写数。 String upperStr = bufIn.readLine(); System.out.println(upperStr); &#125; s.close();&#125; 服务端编写 转换服务端思路： 1、ServerSocket服务 2、获取socket对象 3、源：socket，读取客户端发过来的需要转换的数据 4、目的：显示在控制台上 5、将数据转成大写发给客户端 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws IOException &#123; //1、ServerSocket服务 ServerSocket ss = new ServerSocket(10004); //2、获取socket对象。 Socket s = ss.accept(); //获取ip. String ip = s.getInetAddress().getHostAddress(); System.out.println(ip+"......connected"); //3、获取socket读取流，并装饰。 BufferedReader bufIn = new BufferedReader(new InputStreamReader(s.getInputStream())); //4、获取socket的输出流，并装饰。 PrintWriter out = new PrintWriter(s.getOutputStream(),true); String line = null; while((line=bufIn.readLine())!=null)&#123; System.out.println(line); out.println(line.toUpperCase());// out.print(line.toUpperCase()+"\r\n");// out.flush(); &#125; s.close(); ss.close(); &#125; 常见问题 如果将这两段代码中的PrintWriter 的true删掉，也就是不让他自动刷新 再将out.println(line) 及 out.println(line.toUpperCase())注释掉， 改写为out.print(xxx); 运行代码试试 是否发现客户端输入后，服务端没显示，客户端也不能继续输入了？ 这是因为堵塞了，没有刷新 加上out.flush()再试试？还是不行 没有换行符没法终止，服务端认为客户端没有输入完整 一定注意，需要换行和刷新，PrintWriter 的true，System.out.println(xxx) 练习二需求 客户端发送服务端文本文件，服务端接收到后，返回接收成功 客户端编写 思路： 1、创建一个socket端点 2、客户端的数据源：硬盘文件 3、客户端的目的：socket 4、接收服务端的数据，源：socket 5、将数据显示在打印出来：目的：控制台 123456789101112131415161718192021222324252627public static void main(String[] args) throws UnknownHostException, IOException &#123; System.out.println("上传客户端。。。。。。"); //1、创建socket客户端对象 Socket s = new Socket("192.168.1.100",10005); //2、读取将要传输的文件 BufferedReader bufr = new BufferedReader(new FileReader(file)); //3、socket输出流 PrintWriter out = new PrintWriter(s.getOutputStream(),true); String line = null; while((line=bufr.readLine())!=null)&#123; out.println(line); &#125; //告诉服务端，客户端写完了。 s.shutdownOutput(); //4、socket输入流，读取服务端返回的数据 BufferedReader bufIn = new BufferedReader(new InputStreamReader(s.getInputStream())); String str = bufIn.readLine(); System.out.println(str); bufr.close(); s.close();&#125; 服务端编写 服务端思路： 1、ServerSocket服务 2、获取socket对象 3、源：socket，读取客户端发过来的文件数据 4、目的：硬盘，存放在指定目录下 5、返回客户端：上传成功 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) throws IOException &#123; System.out.println("上传服务端。。。。。。。。。"); //1、ServerSocket服务 ServerSocket ss = new ServerSocket(10005); //2、获取socket对象 Socket s = ss.accept(); System.out.println(s.getInetAddress().getHostAddress()+".....connected"); //3、读取客户端发送过来的文件字节，存到缓冲区 BufferedReader bufIn = new BufferedReader(new InputStreamReader(s.getInputStream())); //4、将读取到的文件字节，存放到指定目录下 BufferedWriter bufw = new BufferedWriter(new FileWriter("c:\\server.txt")); String line = null; while((line=bufIn.readLine())!=null)&#123; bufw.write(line); bufw.newLine(); bufw.flush(); &#125; PrintWriter out = new PrintWriter(s.getOutputStream(),true); out.println("上传成功"); bufw.close(); s.close(); ss.close(); &#125; 练习三需求 多客户端进行上传图片操作，服务端接收后并回复 客户端1234567891011121314151617181920212223242526272829303132public class UploadPicClient &#123; public static void main(String[] args) throws UnknownHostException, IOException &#123; //1,创建客户端socket。 Socket s = new Socket("192.168.1.100",10006); //2,读取客户端要上传的图片文件。 FileInputStream fis = new FileInputStream("c:\\0.bmp"); //3,获取socket输出流，将读到图片数据发送给服务端。 OutputStream out = s.getOutputStream(); byte[] buf = new byte[1024]; int len = 0; while((len=fis.read(buf))!=-1)&#123; out.write(buf,0,len); &#125; //告诉服务端说：这边的数据发送完毕。让服务端停止读取。 s.shutdownOutput(); //读取服务端发回的内容。 InputStream in = s.getInputStream(); byte[] bufIn = new byte[1024]; int lenIn = in.read(buf); String text = new String(buf,0,lenIn); System.out.println(text); fis.close(); s.close(); &#125;&#125; 服务端 因为是多客户端，所以需要用多线程 否则，一个客户端传文件时，别的客户端只能等待 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class UploadTask implements Runnable &#123; private static final int SIZE = 1024*1024*2; private Socket s; public UploadTask(Socket s) &#123; this.s = s; &#125; @Override public void run() &#123; int count = 0; String ip = s.getInetAddress().getHostAddress(); System.out.println(ip + ".....connected"); try&#123; // 读取客户端发来的数据。 InputStream in = s.getInputStream(); // 将读取到数据存储到一个文件中。 File dir = new File("c:\\pic"); if (!dir.exists()) &#123; dir.mkdirs(); &#125; File file = new File(dir, ip + ".jpg"); //如果文件已经存在于服务端 while(file.exists())&#123; file = new File(dir,ip+"("+(++count)+").jpg"); &#125; FileOutputStream fos = new FileOutputStream(file); byte[] buf = new byte[1024]; int len = 0; while ((len = in.read(buf)) != -1) &#123; fos.write(buf, 0, len); if(file.length()&gt;SIZE)&#123; System.out.println(ip+"文件体积过大"); fos.close(); s.close(); System.out.println(ip+"...."+file.delete()); return ; &#125; &#125; // 获取socket输出流，将上传成功字样发给客户端。 OutputStream out = s.getOutputStream(); out.write("上传成功".getBytes()); fos.close(); s.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125;public class UploadPicServer &#123; public static void main(String[] args) throws IOException &#123; //创建tcp的socket服务端。 ServerSocket ss = new ServerSocket(10006); while(true)&#123; //持续获取socket对象 Socket s = ss.accept(); new Thread(new UploadTask(s)).start(); &#125; &#125;&#125; 客户端服务端原理模拟服务器 为了了解原理，自定义一个服务器 1234567891011121314151617181920212223242526public class MyTomcat &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(9090); Socket s = ss.accept(); System.out.println(s.getInetAddress().getHostAddress()+".....connected"); InputStream in = s.getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String text = new String(buf,0,len); System.out.println(text); //给客户端一个反馈信息。 PrintWriter out = new PrintWriter(s.getOutputStream(),true); out.println("嘎嘎嘎嘎"); s.close(); ss.close(); &#125;&#125; 打开浏览器，输入localhost:9090，页面显示嘎嘎嘎嘎 控制台显示： 123456780:0:0:0:0:0:0:1.....connectedGET / HTTP/1.1 Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Language: zh-CNUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299Accept-Encoding: gzip, deflateHost: localhost:9090Connection: Keep-Alive 解释： 123456GET / HTTP/1.1 请求行 请求方式 http协议版本。请求消息头 . 属性名：属性值Accept: text/html, application/xhtml+xml, image/jxr, */*.....Connection: Keep-Alive 模拟浏览器123456789101112131415161718192021222324public class MyBrowser &#123; public static void main(String[] args) throws UnknownHostException, IOException &#123; Socket s = new Socket("127.0.0.1",9090); //模拟浏览器，给tomcat服务端发送符合http协议的请求消息。 PrintWriter out = new PrintWriter(s.getOutputStream(),true); out.println("GET / HTTP/1.1"); out.println("Accept: */*"); out.println("Host: 192.168.1.100:8080"); out.println("Connection: close"); out.println(); out.println(); InputStream in = s.getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String str =new String(buf,0,len); System.out.println(str); s.close(); &#125;&#125; 开启模拟服务器后，再开启模拟浏览器 模拟浏览器可以看到嘎嘎嘎嘎，模拟服务器也收到了浏览器传来的数据 URL 获取URL对象的URL连接器对象。将连接封装成了对象： Java中内置的可以解析的具体协议的对象+socket 1234URLConnection conn = url.openConnection();System.out.println(conn);String value = conn.getHeaderField("Content-Type");System.out.println(value); 常用网络结构C/S client/server（客户端、服务端） 特点： 该结构的软件，客户端和服务端都需要编写 可发成本较高，维护较为麻烦 好处： 客户端在本地可以分担一部分运算 B/S browser/server（浏览器、 服务端） 特点： 该结构的软件，只开发服务器端，不开发客户端，因为客户端直接由浏览器取代。 开发成本相对低，维护更为简单 缺点： 所有运算都要在服务端完成]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-GUI]]></title>
    <url>%2F2018%2F05%2F26%2FJava-GUI%2F</url>
    <content type="text"><![CDATA[GUI(Graphical User Interface) 即图形用户界面，更方便更直接 AWT简介 在Java的早期版本中，GUI组件由名为AWT(Abstract Window Toolkit，抽象窗口工具包)的标准库来提供。 继承关系图 事件监听机制 组成 事件源 事件 监听器 处理方式 简易代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class MouseAndKeyDemo &#123; private Frame f; private TextField tf; private Button but; public MouseAndKeyDemo() &#123; init(); &#125; private void init() &#123; f = new Frame("演示鼠标和键盘监听"); f.setBounds(400,200,500,400); //设置流式布局 f.setLayout(new FlowLayout()); tf = new TextField(35); but = new Button("一个按钮"); f.add(tf); //将按钮添加到窗体中。 f.add(but); myEvent(); //可视化 f.setVisible(true); &#125; private void myEvent() &#123; //给文本框添加键盘监听。 tf.addKeyListener(new KeyAdapter() &#123; @Override public void keyPressed(KeyEvent e) &#123; System.out.println("key run..."+ KeyEvent.getKeyText(e.getKeyCode()) +"::::"+e.getKeyCode()); int code = e.getKeyCode(); if(!(code&gt;=KeyEvent.VK_0 &amp;&amp; code&lt;=KeyEvent.VK_9))&#123; System.out.println("必须是数字"); //非数字字符无法显示在文本框 e.consume(); &#125; &#125; &#125;); f.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; //终止程序 System.exit(0); &#125; &#125;); but.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123;// System.out.println("action run....."); &#125; &#125;); //在按钮上添加一个鼠标监听. but.addMouseListener(new MouseAdapter() &#123; private int count = 1; @Override public void mouseEntered(MouseEvent e) &#123; System.out.println("mouse enter..."+count++); &#125; @Override public void mouseClicked(MouseEvent e) &#123; //双击 if(e.getClickCount()==2) tf.setText("mouse double click..."+count++); &#125; &#125;); &#125;&#125;public class test&#123; public static void main(String[] args) &#123; new MouseAndKeyDemo(); &#125;&#125; Swing Swing都是图形化的，很多代码都可以系统自动生成，就不详细说了 Swing不是线程安全的]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-IO流]]></title>
    <url>%2F2018%2F05%2F16%2FJava-IO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[输入流和输出流相对于内存设备而言. 将外设中的数据读取到内存中：输入 将内存的数写入到外设中：输出 字节流的两个顶层父类： InputStream OutputStream. 字符流的两个顶层父类： Reader Writer 这些体系的子类都以父类名作为后缀。 而且子类名的前缀就是该对象的功能。 字符流 字符流的由来： 其实就是：字节流读取文字字节数据后，不直接操作而是先查指定的编码表。获取对应的文字。 在对这个文字进行操作。简单说：字节流+编码表 FileWriter使用方法 需求：将一些文字存储到硬盘一个文件中。流程在代码注释中。 创建一个可以往文件中写入字符数据的字符输出流对象，如第14行代码 既然是往一个文件中写入文字数据，那么在创建对象时，就必须明确该文件(用于存储数据的目的地)。 如果文件不存在，则会自动创建；如果文件存在，则会被覆盖。 为什么调用Writer对象中的write(string)方法，写入数据后，文件并没有显示写入的数据？ 其实数据只是写入到临时存储缓冲区中，还需要进行刷新 flush(); close();关闭流，关闭资源。在关闭前会先调用flush刷新缓冲中的数据到目的地。 12345678910111213141516171819202122232425262728public class FileWriterDemo &#123; //换行，unix windows 不一样 ,所以使用这个 private static final String LINE_SEPARATOR = System.getProperty("line.separator"); public static void main(String[] args) throws IOException &#123; //创建一个可以往文件中写入字符数据的字符输出流对象。 /* * 如果构造函数中加入true，可以实现对文件进行续写！ */ FileWriter fw = new FileWriter("demo.txt",true); //调用Writer对象中的write(string)方法，写入数据 fw.write("abcde"+LINE_SEPARATOR+"hahaha"); //fw.write("xixi"); //进行刷新，将数据直接写到目的地中。 fw.flush(); // 关闭流，关闭资源。在关闭前会先调用flush刷新缓冲中的数据到目的地。 fw.close(); //关闭流后，无法再进行写操作// fw.write("haha");// java.io.IOException: Stream closed &#125;&#125; 处理异常 最好使用try，catch。在外部初始化创建 fileWriter，new在try代码块内部 finally中判断是否为空，然后写关闭的语句，给它也进行try，catch 1234567891011121314151617181920212223242526public class IOExceptionDemo &#123; public static void main(String[] args) &#123; FileWriter fw = null; try &#123; fw = new FileWriter("k:\\demo.txt"); fw.write("abcde" + LINE_SEPARATOR + "hahaha"); &#125; catch (IOException e) &#123; System.out.println(e.toString()); &#125; finally &#123; if (fw != null) try &#123; fw.close(); &#125; catch (IOException e) &#123; // code.... throw new RuntimeException("关闭失败"); &#125; &#125; &#125;&#125; FileReader 需求：读取一个文本文件。将读取到的字符打印到控制台 12345678FileReader fr = new FileReader("demo.txt");int ch = 0;while((ch=fr.read())!=-1)&#123; System.out.println((char)ch);&#125;//如果读完已有值后，再读取文件，会返回-1 第二种读取方式： 以数组为单位的读取 12345678假设demo.txt中有 abcde 五个字母char[] buf = new char[3];//将读取到的字符存储到数组中int num = fr.read(buf);System.out.println(num+":"+new String(buf)); //abcint num1 = fr.read(buf);System.out.println(num1+":"+new String(buf)); //dec 为什么一共只有五个字母，第二次读取时却是 ”dec“ ？ 因为是存在缓冲区，第一次abc没有清除，第二次是de覆盖了ab 1234567FileReader fr = new FileReader("demo.txt");char[] buf = new char[1024];int len = 0;while((len=fr.read(buf))!=-1)&#123; System.out.println(new String(buf,0,len));//读取buf，从0读到len&#125; 练习：复制文件 练习：将c盘的一个文本文件复制到d盘 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CopyTextTest_2 &#123; private static final int BUFFER_SIZE = 1024; public static void main(String[] args) &#123; //读取一个已有的文本文件，使用字符读取流和文件相关联。 FileReader fr = null; //创建一个目的，用于存储读到数据。 FileWriter fw = null; try &#123; fr = new FileReader("IO流_2.txt"); fw = new FileWriter("copytest_2.txt"); //创建一个临时容器，用于缓存读取到的字符。 char[] buf = new char[BUFFER_SIZE];//这就是缓冲区。 //定义一个变量记录读取到的字符数，(其实就是往数组里装的字符个数 ) int len = 0; while((len=fr.read(buf))!=-1)&#123; fw.write(buf, 0, len); //读取buf，从0开始，len结束 &#125; &#125; catch (Exception e) &#123; throw new RuntimeException("读写失败"); &#125;finally&#123; if(fw!=null) try &#123; fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if(fr!=null) try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 缓冲区 这就好比去超市，没有缓冲区就是买一样东西一结帐，有缓冲区就是拿着筐或者推着车，买完再结帐，可以大幅度提高效率 不过如果车过大会堵塞出口，那样的话就可以在车子里面放几个筐，结账用筐，也会提高效率 BufferWriter12345678910111213141516171819public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWriter("buf.txt"); //为了提高写入的效率。使用了字符流的缓冲区。 //创建了一个字符写入流的缓冲区对象，并和指定要被缓冲的流对象相关联 BufferedWriter bufw = new BufferedWriter(fw); //使用缓冲区的写入方法将数据先写入到缓冲区中。 for(int x=1; x&lt;=4; x++)&#123; bufw.write("abcdef"+x); bufw.newLine(); //使用缓冲区的刷新方法将数据刷目的地中。 bufw.flush(); &#125; //关闭缓冲区。其实关闭的就是被缓冲的流对象。 bufw.close();&#125; BufferReader123456789101112131415FileReader fr = new FileReader("buf.txt"); BufferedReader bufr = new BufferedReader(fr);FileWriter fw = new FileWriter("buf_copy.txt");BufferedWriter bufw = new BufferedWriter(fw);String line = null;while((line=bufr.readLine())!=null)&#123; bufw.write(line); bufw.newLine(); bufw.flush();&#125; bufw.close();bufr.close(); 自定义MyBufferReader1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 自定义的读取缓冲区。其实就是模拟一个BufferedReader. * * 分析： * 缓冲区中无非就是封装了一个数组， * 并对外提供了更多的方法对数组进行访问。 * 其实这些方法最终操作的都是数组的角标。 * * 缓冲的原理： * 其实就是从源中获取一批数据装进缓冲区中。 * 在从缓冲区中不断的取出一个一个数据。 * * 在此次取完后，在从源中继续取一批数据进缓冲区。 * 当源中的数据取光时，用-1作为结束标记。 */public class MyBufferedReader extends Reader &#123; private Reader r; //定义一个数组作为缓冲区。 private char[] buf = new char[1024]; //定义一个指针用于操作这个数组中的元素。当操作到最后一个元素后，指针应该归零。 private int pos = 0; //定义一个计数器用于记录缓冲区中的数据个数。 当该数据减到0，就从源中继续获取数据到缓冲区中。 private int count = 0; MyBufferedReader(Reader r)&#123; this.r = r; &#125; /** * 该方法从缓冲区中一次取一个字符。 * @return * @throws IOException */ public int myRead() throws IOException&#123; if(count==0)&#123; count = r.read(buf); pos = 0; &#125; if(count&lt;0) return -1; char ch = buf[pos++]; count--; return ch; &#125; public String myReadLine() throws IOException&#123; StringBuilder sb = new StringBuilder(); int ch = 0; while((ch = myRead())!=-1)&#123; if(ch=='\r') continue; if(ch=='\n') return sb.toString(); //将从缓冲区中读到的字符，存储到缓存行数据的缓冲区中。 sb.append((char)ch); &#125; if(sb.length()!=0) return sb.toString(); return null; &#125; public void myClose() throws IOException &#123; r.close();&#125; 装饰设计模式 对一组对象的功能进行增强时，就可以使用该模式进行问题的解决。 缓冲区的设计就是基于装饰设计模式实现的 然而装饰和继承都能实现一样的特点：进行功能的扩展增强。哪个好那？ 装饰和继承对比 假设有一个继承体系 123Writer |--TextWriter：用于操作文本 |--MediaWriter：用于操作媒体。 想要对操作的动作进行效率的提高，需要加入缓冲技术。 按照面向对象，可以通过继承对具体的进行功能的扩展。 12345678Writer |--TextWriter：用于操作文本 |--BufferTextWriter：加入了缓冲技术的操作文本的对象。 |--MediaWriter：用于操作媒体。 |--BufferMediaWriter:但是这样做好像并不理想，如果这个体系进行功能扩展，又多了流对象。那么这个流要提高效率，是不是也要产生子类呢？是。这时就会发现只为提高功能，进行的继承，导致继承体系越来越臃肿。不够灵活。 既然加入的都是同一种技术–缓冲。前一种是让缓冲和具体的对象相结合。 可不可以将缓冲进行单独的封装，哪个对象需要缓冲就将哪个对象和缓冲关联。 12345678910Writer |--TextWriter：用于操作文本 |--MediaWriter：用于操作媒体。 |--BufferWriter：用于提高效率。 class BufferWriter extends Writer&#123; BufferWriter(Writer w) &#123; &#125;&#125; 装饰比继承灵活 特点：装饰类和被装饰类都必须所属同一个接口或者父类。 LineNumberReader 可以增添行号 12345678910111213public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader("IO流_2.txt"); LineNumberReader lnr = new LineNumberReader(fr); String line = null; lnr.setLineNumber(100); while((line=lnr.readLine())!=null)&#123; System.out.println(lnr.getLineNumber()+":"+line); &#125; lnr.close();&#125; 字节流12345678910111213141516171819202122232425public static void demo_read() throws IOException &#123; //1，创建一个读取流对象。和指定文件关联。 FileInputStream fis = new FileInputStream("bytedemo.txt"); //建议使用这种读取数据的方式 byte[] buf = new byte[1024]; int len = 0; while((len=fis.read(buf))!=-1)&#123; System.out.println(new String(buf,0,len)); &#125; fis.close();&#125;public static void demo_write() throws IOException &#123; //1，创建字节输出流对象。用于操作文件. FileOutputStream fos = new FileOutputStream("bytedemo.txt"); //2,写数据。直接写入到了目的地中。 fos.write("abcdefg".getBytes()); fos.close();//关闭资源动作要完成。 &#125; 练习 复制一个Mp3文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class CopyMp3Test &#123; /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; copy_2(); &#125; //fis.available()：文件的字节数 //如果文件字节数特别大，那么速度会很慢 //不建议使用 public static void copy_3() throws IOException &#123; FileInputStream fis = new FileInputStream("c:\\0.mp3"); FileOutputStream fos = new FileOutputStream("c:\\3.mp3"); byte[] buf = new byte[fis.available()]; fis.read(buf); fos.write(buf); fos.close(); fis.close(); &#125; public static void copy_2() throws IOException &#123; FileInputStream fis = new FileInputStream("c:\\0.mp3"); BufferedInputStream bufis = new BufferedInputStream(fis); FileOutputStream fos = new FileOutputStream("c:\\2.mp3"); BufferedOutputStream bufos = new BufferedOutputStream(fos); int ch = 0; while((ch=bufis.read())!=-1)&#123; bufos.write(ch); &#125; bufos.close(); bufis.close(); &#125; public static void copy_1() throws IOException &#123; FileInputStream fis = new FileInputStream("c:\\0.mp3"); FileOutputStream fos = new FileOutputStream("c:\\1.mp3"); byte[] buf = new byte[1024]; int len = 0; while((len=fis.read(buf))!=-1)&#123; fos.write(buf,0,len); &#125; fos.close(); fis.close(); &#125;&#125; 键盘录入 运行下面代码后，在控制台输入一个字母，按回车运行，是不是发现多出来一个 10 ？ 是的，这个是“ \n ”,也就是刚才的回车。 12345678910public static void readKey() throws IOException &#123; InputStream in = System.in; int ch = in.read();//阻塞式方法。 System.out.println(ch); int ch1 = in.read();//阻塞式方法。 System.out.println(ch1);&#125; 练习 获取用户键盘录入的数据，并将数据变成大写显示在控制台上 如果用户输入的是over，结束键盘录入。 12345678910111213141516171819202122232425262728public static void readKey2() throws IOException &#123; //1，创建容器。 StringBuilder sb = new StringBuilder(); //2，获取键盘读取流。 InputStream in = System.in; //3，定义变量记录读取到的字节，并循环获取。 int ch = 0; while((ch=in.read())!=-1)&#123; //在存储之前需要判断是否是换行标记 ,因为换行标记不存储。 if(ch=='\r') continue; if(ch=='\n')&#123; String temp = sb.toString(); if("over".equals(temp)) break; System.out.println(temp.toUpperCase()); sb.delete(0, sb.length()); &#125; else //将读取到的字节存储到StringBuilder中。 sb.append((char)ch); &#125;&#125; 转换流123456789101112131415161718192021222324252627/* 这是方便理解的做法//字节流InputStream in = System.in;OutputStream out = System.out;//将字节转成字符的桥梁。装换流。 InputStreamReader isr = new InputStreamReader(in);OutputStreamWriter osw = new OutputStreamWriter(out);//字符流。BufferedReader bufr = new BufferedReader(isr);BufferedWriter bufw = new BufferedWriter(osw);*///更简洁BufferReader bufr = new BufferReader(new InputStream(System.in));BufferWriter bufr = new BufferWriter(new OutputStream(System.out));String line = null;while((line=bufr.readLine())!=null)&#123; if("over".equals(line)) break; bufw.write(line.toUpperCase()); bufw.newLine(); bufw.flush();&#125; 1、需求：将键盘录入的数据写入到一个文件中。 12BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(newFileOutputStream("a.txt"))); 2、需求：将一个文本文件内容显示在控制台上。 12BufferedReader bufr = new BufferedReader(new InputStreamReader(newFileInputStream("a.txt")));BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out)); 3、需求：将一个文件文件中的内容复制到的另一个文件中。 12BufferedReader bufr = new BufferedReader(new InputStreamReader(newFileInputStream("a.txt")));BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(newFileOutputStream("b.txt"))); 根据不同的需求，改变源的不同位置即可 编码解码 file 流中的read write都是默认编码，如果需要指定编码，则选择其父类 InputStreamReader 、OutputStreamWriter OutputStreamWriter接收一个字节输出流对象，既然是操作文件，那么该对象应该是FileOutputStream 12345OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("uu.txt"),"UTF-8");//BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("uu.txt"),"UTF-8"));osw.write("你好");osw.close(); 什么时候使用转换流呢？ 1、源或者目的对应的设备是字节流，但是操作的却是文本数据，可以使用转换作为桥梁。提高对文本操作的便捷。 2、一旦操作文本涉及到具体的指定编码表时，必须使用转换流 。 流的操作规律 之所以要弄清楚这个规律，是因为流对象太多，开发时不知道用哪个对象合适。 想要知道开发时用到哪些对象。只要通过四个明确即可。 1、明确源和目的(汇) 12源：InputStream Reader目的：OutputStream Writer 2、明确数据是否是纯文本数据。 12345源：是纯文本： Reader 否： InputStream目的：是纯文本： Writer 否： OutputStream 到这里，就可以明确需求中具体要使用哪个体系。 3、明确具体的设备。 12345源设备： 硬盘： File 键盘： System.in 内存： 数组 网络： Socket流 12345目的设备： 硬盘： File 控制台：System.out 内存： 数组 网络： Socket流 4、是否需要其他额外功能。 12341、是否需要高效(缓冲区); 是，就加上buffer.2、转换。 File对象 可以将一个已存在的，或者不存在的文件或者目录封装成file对象。 123456File f1 = new File("c:\\a.txt");File f2 = new File("c:\\","a.txt");File f = new File("c:\\");File f3 = new File(f,"a.txt");File f4 = new File("c:"+File.separator+"abc"+File.separator+"a.txt");System.out.println(f4); 方法 1、获取 获取文件名称 1.2 获取文件路径 1.3 获取文件大小 1.4 获取文件修改时间 12345678910File file = new File("a.txt");String name = file.getName();String absPath = file.getAbsolutePath();//绝对路径（开头有盘符）String path = file.getPath(); //相对路径（开头无盘符）（找不到父目录）long len = file.length();long time = file.lastModified(); //毫秒值Date date = new Date(time); //Date对象格式化DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);String str_time = dateFormat.format(date); 2、创建与删除 123456789101112131415//和输出流不一样，如果文件不存在，则创建，如果文件存在，则不创建。 boolean b = file.createNewFile(); System.out.println("b="+b);boolean b = file.delete();System.out.println("b="+b);File dir = new File("abc");boolean b = dir.mkdir();//make directory System.out.println("b="+b);System.out.println(dir.delete()); //慎用，不走回收站File dir = new File("abc\\q\\e\\c\\z\\r\\w\\y\\f\\e\\g\\s");dir.mkdirs();//创建多级目录System.out.println(dir.delete()); //运行后，仅删除 S 文件夹 3、判断 123456File f = new File("aaa"); boolean b = f.exists(); //是否存在 System.out.println("b="+b);// 最好先判断是否存在。 System.out.println(f.isFile()); //是否是文件System.out.println(f.isDirectory());//是否是目录 4、重命名 123456//可以从C到D盘 重命名//即为剪切C盘的文件，复制到D盘File f1 = new File("c:\\9.mp3");File f2 = new File("d:\\aa.mp3");boolean b = f1.renameTo(f2);System.out.println("b="+b); 根目录方法12345678File[] files = File.listRoots();for(File file : files)&#123; System.out.println(file);&#125;File file = new File("d:\\");System.out.println("getFreeSpace:"+file.getFreeSpace()); //空闲容量System.out.println("getTotalSpace:"+file.getTotalSpace()); //总容量System.out.println("getUsableSpace:"+file.getUsableSpace());//可使用容量 获取目录内容 获取当前目录下的文件以及文件夹的名称，包含隐藏文件 调用list方法的File对象中封装的必须是目录,否则会发生NullPointerException 如果访问的系统级目录也会发生空指针异常。 如果目录存在但是没有内容，会返回一个数组，但是长度为0. 123456789public static void listDemo() &#123; File file = new File("c:\\"); String[] names = file.list(); System.out.println(names.length); for(String name : names)&#123; System.out.println(name); &#125;&#125; 过滤器 显示后缀.java 的文件，使用 File类的 list方法 12345678public class FilterByJava implements FilenameFilter &#123; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(".java"); &#125;&#125; 显示未隐藏的文件，使用 listFiles 方法 12345678910111213141516171819public class FilterByHidden implements FileFilter &#123; @Override public boolean accept(File pathname) &#123; return !pathname.isHidden(); &#125;&#125;public static void listDemo() &#123; File dir = new File("c:\\"); File[] files = dir.listFiles(new FilterByHidden()); for(File file : files)&#123; System.out.println(file); &#125;&#125; 如果想过滤后缀，但是每次改过滤器太复杂，可以重新设计过滤器 1234567891011121314public class SuffixFilter implements FilenameFilter &#123; private String suffix ; public SuffixFilter(String suffix) &#123; super(); this.suffix = suffix; &#125; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(suffix); &#125;&#125; 这样ListDemo 类中就可以更改想要的后缀 12String[] names = dir.list(new SuffixFilter(".txt"));String[] names = dir.list(new SuffixFilter(".java")); 练习深度遍历 需求：对指定目录进行所有内容的列出（包含子目录中的内容），也可以理解为 深度遍历。 1234567891011121314151617181920212223242526272829public class FileTest &#123; public static void main(String[] args) &#123; File dir = new File("d:\\MyBlog"); listAll(dir,0); &#125; public static void listAll(File dir, int level) &#123; System.out.println(getSpace(level)+dir.getAbsolutePath()); level++; File[] file = dir.listFiles(); for (int x = 0; x &lt; file.length; x++) &#123; if (file[x].isDirectory()) listAll(file[x], level); else System.out.println(getSpace(level)+file[x].getAbsoluteFile()); &#125; &#125; private static String getSpace(int level) &#123; StringBuilder sb = new StringBuilder(); sb.append("|-- "); for (int i = 0; i &lt; level; i++) &#123; sb.insert(0, "| "); &#125; return sb.toString(); &#125;&#125; 删除目录（含内容的） 删除一个带内容的目录。 原理：必须从最里面往外，需要进行深度遍历。 12345678910111213141516public class Remove &#123; public static void main(String[] args) &#123; File dir = new File("d:\\demodemo"); remove(dir); &#125; public static void remove(File dir)&#123; File[] files = dir.listFiles(); for (File file:files)&#123; if (file.isDirectory()) remove(file); else System.out.println( file+":"+file.delete()); &#125; System.out.println( dir+":"+dir.delete()); &#125;&#125; Properties概述 Properties 是Map 子类Hashtable 的子类 Properties集合特点： 该集合中的键和值都是字符串类型。 集合中的数据可以保存到流中，或者从流获取。 通常该集合用于操作以键值对形式存在的配置文件。 演示方法 倒数第二行注意，大多数时候用于调试 123456789101112131415161718192021222324public static void propertiesDemo()&#123; //创建一个Properties集合。 Properties prop = new Properties(); //存储元素。 prop.setProperty("zhangsan","30"); prop.setProperty("lisi","31"); prop.setProperty("wangwu","36"); prop.setProperty("zhaoliu","20"); //修改元素。 prop.setProperty("wangwu","26"); //取出所有元素。 Set&lt;String&gt; names = prop.stringPropertyNames(); for(String name : names)&#123; String value = prop.getProperty(name); System.out.println(name+":"+value); &#125; //多用于调试，在控制台显示所有信息 prop.list(System.out);&#125; 想要将这些集合中的字符串键值信息持久化存储到文件中，则需要关联输出流。（使用store方法） 12345678910111213141516public static void methodDemo_3() throws IOException &#123; Properties prop = new Properties(); //存储元素。 prop.setProperty("zhangsan","30"); prop.setProperty("lisi","31"); //关联输出流。 FileOutputStream fos = new FileOutputStream("info.txt"); //将集合中数据存储到文件中，使用store方法。 prop.store(fos, "info"); fos.close();&#125; 既然可以存在文件中，自然可以在文件中读取（使用load方法） 注意：必须要保证该文件中的数据是键值对 12345678910111213public static void methodDemo_4() throws IOException &#123; Properties prop = new Properties(); //使用到读取流。 FileInputStream fis = new FileInputStream("info.txt"); //使用load方法。 prop.load(fis); prop.list(System.out);&#125; load方法原理1234567891011121314151617181920212223public static void myLoad() throws IOException&#123; Properties prop = new Properties(); BufferedReader bufr = new BufferedReader(new FileReader("info.txt")); String line = null; while((line=bufr.readLine())!=null)&#123; if(line.startsWith("#")) continue; String[] arr = line.split("="); prop.setProperty(arr[0], arr[1]); &#125; prop.list(System.out); bufr.close();&#125; 修改配置信息 流程 读取文件 创建集合存储配置信息 将流信息存储到集合中 修改集合 将集合信息写回文件中 123456789101112131415161718192021222324public static void test(File file) throws IOException&#123; //读取这个文件。 if(!file.exists())&#123; file.createNewFile(); &#125; FileReader fr = new FileReader(file); //创建集合存储配置信息。 Properties prop = new Properties(); //将流中信息存储到集合中。 prop.load(fr); prop.setProperty("wangwu", "16"); //需要信息修改完后才能将集合与输出流相关联 FileWriter fw = new FileWriter(file); prop.store(fw,""); fw.close(); fr.close();&#125; 练习一 定义功能：获取一个应用程序运行的次数， 如果超过5次，给出使用次数已到请注册的提示，并不要在运行程序。 123456789101112131415161718思路：1、 应该有计数器。 每次程序启动都需要计数一次,并且是在原有的次数上进行计数。2、 计数器就是一个变量。 那么我们就可以，程序启动时候进行计数，计数器必须存在于内存并进行运算。 可是程序一结束，计数器消失了。那么再次启动该程序，计数器又重新被初始化了。 而我们需要多次启动同一个应用程序，使用的是同一个计数器。 这就需要计数器的生命周期变长，从内存存储到硬盘文件中。3、 如何使用这个计数器呢？ 首先，程序启动时，应该先读取这个用于记录计数器信息的配置文件。 获取上一次计数器次数。 并进行试用次数的判断。 其次，对该次数进行自增，并自增后的次数重新存储到配置文件中。 4、 文件中的信息该如何进行存储并体现。 直接存储次数值可以，但是不明确该数据的含义。 所以起名字就变得很重要。 这就有了名字和值的对应，所以可以使用键值对。 可是映射关系map集合搞定，又需要读取硬盘上的数据，所以map+io = Properties. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class PropertiesTest &#123; public static void main(String[] args) throws IOException &#123; getAppCount(); &#125; public static void getAppCount() throws IOException&#123; //将配置文件封装成File对象。 File confile = new File("count.properties"); if(!confile.exists())&#123; confile.createNewFile(); &#125; FileInputStream fis = new FileInputStream(confile); Properties prop = new Properties(); prop.load(fis); //从集合中通过键获取次数。 String value = prop.getProperty("time"); //定义计数器。记录获取到的次数。 int count =0; if(value!=null)&#123; count = Integer.parseInt(value); if(count&gt;=5)&#123; throw new RuntimeException("使用次数已到，请充值vip，给钱！"); &#125; &#125; count++; //将改变后的次数重新存储到集合中。 prop.setProperty("time", count+""); FileOutputStream fos = new FileOutputStream(confile); prop.store(fos, ""); fos.close(); fis.close(); &#125;&#125; 练习二 获取指定目录下，指定扩展名的文件(包含子目录中的)，将这些文件的绝对路径写入到一个文本文件中。 简单说，就是建立一个指定扩展名的文件的列表。 思路： 进行深度遍历 创建过滤器，将符合要求的文件绝对路径写入集合 对容器中内容遍历并将绝对路径写入文件中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//过滤器public class Filter implements FilenameFilter &#123; private String suffix; public Filter(String suffix) &#123; super(); this.suffix = suffix; &#125; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(suffix); &#125;&#125;public class test &#123; public static void main(String[] args) &#123; File dir = new File("D:\\Code\\Java"); //过滤".java"结尾的文件 Filter filter = new Filter(".java"); getFileList(dir,filter); &#125; private static void getFileList(File dir, FilenameFilter filter) &#123; //判断目录是否存在，增强健壮性 if (!dir.exists()) throw new NullPointerException("该指定目录不存在"); //创建容器 List&lt;File&gt; list = new ArrayList(); getFile(dir,filter,list); //destfile：要存储到的目的文件 File destfile = new File(dir,"javaList.txt"); writeToFile(list,destfile); &#125; private static void getFile(File dir, FilenameFilter filter, List&lt;File&gt; list) &#123; File[] files = dir.listFiles(); //深度遍历 for (File file:files)&#123; //如果是文件夹，递归 if (file.isDirectory()) getFile(file, filter, list); else//过滤文件，将其添加到容器中 if (filter.accept(file, file.getName())) &#123; list.add(file); &#125; &#125; &#125; private static void writeToFile(List&lt;File&gt; list, File destfile) &#123; BufferedWriter bw = null; try &#123; bw = new BufferedWriter(new FileWriter(destfile)); for (File file:list)&#123; bw.write(file.getAbsolutePath()); bw.newLine(); bw.flush(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException("写入失败"); &#125; finally &#123; if (bw != null) &#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; throw new RuntimeException("关闭失败"); &#125; &#125; &#125; &#125;&#125; 打印流PrintStream 1、提供了打印方法可以对多种数据类型值进行打印。并保持数据的表示形式。 2、它不抛IOException 构造函数，接收三种类型的值： 1、字符串路径 2、File对象 3、字节输出流 1234567891011public static void main(String[] args) throws IOException &#123; PrintStream out = new PrintStream("print.txt"); //只写最低8位，对比下面两个结果，文件中存储的值都为 b out.write(98); out.write(610); //将97先变成字符保持原样将数据打印到目的地。 out.print(97); out.close();&#125; PrintWriter 字符打印流 构造函数参数： 1、字符串路径 2、File对象 3、字节输出流 4、字符输出流 12345678910111213141516public static void main(String[] args) throws IOException &#123; BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in)); //在创建输出流的时候，最后加上true，则可以自动刷新 PrintWriter out = new PrintWriter(new FileWriter("out.txt"),true); //PrintWriter out = new PrintWriter(System.out,true);//在控制台输出 String line = null; while((line=bufr.readLine())!=null)&#123; if("over".equals(line)) break; out.println(line.toUpperCase()); //out.flush; 第四行中有了true的设置，就不用手动刷新了 &#125; out.close(); bufr.close();&#125; 序列流 可以将文件合并为一个序列流，对其进行操作 需求：将1.txt 2.txt 3.txt文件中的数据合并到一个文件中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class SequenceInputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //Vector含枚举，但是太慢了 ArrayList&lt;FileInputStream&gt; al = new ArrayList&lt;FileInputStream&gt;(); for(int x=1; x&lt;=3; x++)&#123; al.add(new FileInputStream(x+".txt")); &#125; Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al); /* 这里是Collection工具类的enumeration实现原理 //利用迭代器和新建的枚举 final Iterator&lt;FileInputStream&gt; it = al.iterator(); Enumeration&lt;FileInputStream&gt; en = new Enumeration&lt;FileInputStream&gt;()&#123; @Override public boolean hasMoreElements() &#123; return it.hasNext(); &#125; @Override public FileInputStream nextElement() &#123; return it.next(); &#125; &#125;;*/ SequenceInputStream sis = new SequenceInputStream(en); FileOutputStream fos = new FileOutputStream("1234.txt"); byte[] buf = new byte[1024]; int len = 0; while((len=sis.read(buf))!=-1)&#123; fos.write(buf,0,len); &#125; fos.close(); sis.close(); &#125;&#125; 文件切割与合并切割 需求：将一个.MP3 文件按照 1M 切割 思路： 用读取流关联源文件，定义缓冲区 创建目的 将被切割文件的信息保存到prop集合中 将prop集合中的数据存储到文件中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class SplitFileDemo &#123; private static final int SIZE = 1024 * 1024; public static void main(String[] args) throws Exception &#123; File file = new File("c:\\aa.mp3"); splitFile(file); &#125; private static void splitFile(File file) throws IOException &#123; // 用读取流关联源文件。 FileInputStream fis = new FileInputStream(file); // 定义一个1M的缓冲区。 byte[] buf = new byte[SIZE]; // 创建目的。 FileOutputStream fos = null; int len = 0; int count = 1; /* * 切割文件时，必须记录住被切割文件的名称，以及切割出来碎片文件的个数。 以方便于合并。 * 这个信息为了进行描述，使用键值对的方式。用到了properties对象 * */ Properties prop = new Properties(); File dir = new File("c:\\partfiles"); if (!dir.exists()) dir.mkdirs(); while ((len = fis.read(buf)) != -1) &#123; fos = new FileOutputStream(new File(dir, (count++) + ".part")); fos.write(buf, 0, len); fos.close(); &#125; //将被切割文件的信息保存到prop集合中。 prop.setProperty("partcount", count+""); prop.setProperty("filename", file.getName()); fos = new FileOutputStream(new File(dir,count+".properties")); //将prop集合中的数据存储到文件中。 prop.store(fos, "save file info"); fos.close(); fis.close(); &#125;&#125; 合并 被切割的文件是无法被运行的，需要进行合并（以上面切割代码为示例） 思路： 获取指定目录下的配置文件对象 记录配置文件对象，获取该配置文件中的信息 获取该目录下的所有碎片文件（.part） 将碎片文件和流对象关联 并存储到集合中 将多个流合并成一个序列流，输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MergeFile &#123; public static void main(String[] args) throws IOException &#123; File dir = new File("c:\\partfiles"); mergeFile(dir); &#125; public static void mergeFile(File dir) throws IOException &#123; /* * 获取指定目录下的配置文件对象。 */ File[] files = dir.listFiles(new SuffixFilter(".properties")); if(files.length!=1) throw new RuntimeException(dir+",该目录下没有properties扩展名的文件或者不唯一"); //记录配置文件对象。 File confile = files[0]; //获取该文件中的信息 Properties prop = new Properties(); FileInputStream fis = new FileInputStream(confile); prop.load(fis); String filename = prop.getProperty("filename"); int count = Integer.parseInt(prop.getProperty("partcount")); //获取该目录下的所有碎片文件。 File[] partFiles = dir.listFiles(new SuffixFilter(".part")); if(partFiles.length!=(count-1))&#123; throw new RuntimeException(" 碎片文件不符合要求，个数不对!应该"+count+"个"); &#125; //将碎片文件和流对象关联 并存储到集合中。 ArrayList&lt;FileInputStream&gt; al = new ArrayList&lt;FileInputStream&gt;(); for(int x=0; x&lt;partFiles.length; x++)&#123; al.add(new FileInputStream(partFiles[x])); &#125; //将多个流合并成一个序列流。 Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al); SequenceInputStream sis = new SequenceInputStream(en); FileOutputStream fos = new FileOutputStream(new File(dir,filename)); byte[] buf = new byte[1024]; int len = 0; while((len=sis.read(buf))!=-1)&#123; fos.write(buf,0,len); &#125; fos.close(); sis.close(); &#125;&#125; 操作对象流 平常创建的对象都是存储在硬盘上，通过对象输出流可以将其存储在硬盘中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * Serializable：用于给被序列化的类加入ID号。 * 用于判断类和对象是否是同一个版本。 */public class Person implements Serializable/*标记接口*/ &#123; /** * transient：非静态数据不想被序列化可以使用这个关键字修饰。 * 如果不自己添加序列号，序列化后更改name为public 就会报错 */ private static final long serialVersionUID = 9527l; private String name; private int age; //构造函数 //get set函数&#125;public class ObjectStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; writeObj(); readObj(); &#125; public static void readObj() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream("obj.object")); //对象的反序列化。 Person p = (Person)ois.readObject(); System.out.println(p.getName()+":"+p.getAge()); ois.close(); &#125; public static void writeObj() throws IOException, IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("obj.object")); //对象序列化。 被序列化的对象必须实现Serializable接口。 oos.writeObject(new Person("小强",30)); oos.close(); &#125;&#125; RandomAccessFile 特点： 1、即可读取，又可以写入。 2、内部维护了一个大型的byte数组，通过对数组的操作完成读取和写入。 3、通过getFilePointer方法获取指针的位置，还可以通过seek方法设置指针的位置。 4、该对象的内容应该封装了字节输入流和字节输出流。 5、该对象只能操作文件。 注意： 通过seek方法操作指针，可以从这个数组中的任意位置上进行读和写，可以完成对数据的修改。 但是要注意：数据必须有规律。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class RandomAccessFileDemo &#123; public static void main(String[] args) throws IOException &#123; // writeFile();// readFile(); randomWrite(); &#125; public static void randomWrite() throws IOException&#123; RandomAccessFile raf = new RandomAccessFile("ranacc.txt", "rw"); //往指定位置写入数据。 raf.seek(3*8); raf.write("哈哈".getBytes()); raf.writeInt(108); raf.close(); &#125; public static void readFile() throws IOException &#123; RandomAccessFile raf = new RandomAccessFile("ranacc.txt", "r"); //通过seek设置指针的位置。 raf.seek(1*8);//随机的读取。只要指定指针的位置即可。 byte[] buf = new byte[4]; raf.read(buf); String name = new String(buf); int age = raf.readInt(); System.out.println("name="+name); System.out.println("age="+age); System.out.println("pos:"+raf.getFilePointer()); raf.close(); &#125; //使用RandomAccessFile对象写入一些人员信息，比如姓名和年龄。 public static void writeFile() throws IOException&#123; //如果文件不存在，则创建，如果文件存在，不创建 RandomAccessFile raf = new RandomAccessFile("ranacc.txt","rw"); raf.write("张三".getBytes()); raf.writeInt(97); raf.write("小强".getBytes()); raf.writeInt(99); raf.close(); &#125;&#125; 管道流 需要和多线程技术相结合的流对象 PipedOutputStream、PipedInputStream 如果想指定哪里来的数据读取哪个数据的话，需要将两个流接上，则使用管道流 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class PipedStream &#123; public static void main(String[] args) throws IOException &#123; PipedInputStream input = new PipedInputStream(); PipedOutputStream output = new PipedOutputStream(); input.connect(output); new Thread(new Input(input)).start(); new Thread(new Output(output)).start(); &#125;&#125;class Input implements Runnable&#123; private PipedInputStream in; Input(PipedInputStream in)&#123; this.in = in; &#125; public void run()&#123; try &#123; byte[] buf = new byte[1024]; int len = in.read(buf); String s = new String(buf,0,len); System.out.println("s="+s); in.close(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;&#125;class Output implements Runnable&#123; private PipedOutputStream out; Output(PipedOutputStream out)&#123; this.out = out; &#125; public void run()&#123; try &#123; Thread.sleep(5000); out.write("hi，管道来了！".getBytes()); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;&#125; 操作基本数据类型的流 用操作基本数据类型值的对象 DataInputStream 、DataOutputStream 1234567891011121314151617public class DataSteamDemo &#123; public static void main(String[] args) throws IOException &#123;// writeData(); readData(); &#125; public static void readData() throws IOException &#123; DataInputStream dis = new DataInputStream(new FileInputStream("data.txt")); String str = dis.readUTF(); System.out.println(str); &#125; public static void writeData() throws IOException &#123; DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.txt")); dos.writeUTF("你好"); dos.close(); &#125;&#125; 操作数组的流 设备是内存的流对象。 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter StringReader StringWriter 1234567891011121314public class ByteArrayStreamDemo &#123; public static void main(String[] args) &#123; ByteArrayInputStream bis = new ByteArrayInputStream("abcedf".getBytes()); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int ch = 0; while((ch=bis.read())!=-1)&#123; bos.write(ch); &#125; System.out.println(bos.toString()); &#125;&#125; 编码表常见编码表 ASCII： 美国标准信息交换码，用一个字节7位表示 ISO8859-1： 拉丁码表，用一个字节8位表示 GB2312： 中文编码表 GBK： 升级的中文编码表 Unicode： 国际标准码，融合多种文字（均用两字节表示） UTF-8： 国标码（最多三个字节表示一个字符） 简单编码解码123456789101112131415161718public static void encodeDemo(String str) throws UnsupportedEncodingException &#123; //编码 byte[] buf = str.getBytes("UTF-8"); printBytes(buf); //解码 String s1 = new String(buf,"UTF-8"); System.out.println("s1="+s1);&#125;private static void printBytes(byte[] buf) &#123; for(byte b : buf)&#123; System.out.print(b +" "); &#125;&#125; 问题1 如果编码的时候是 ” GBK“， 解码的时候是 ”iso8859-1“ 怎么解决 12345678910111213141516public static void main(String[] args) throws UnsupportedEncodingException &#123; String str = "谢谢"; encodeDemo(str); &#125;public static void encodeDemo(String str) throws UnsupportedEncodingException &#123; byte[] buf = str.getBytes("gbk"); String s1 = new String(buf,"iso8859-1"); System.out.println("s1="+s1); //用iso8859-1编码 byte[] buf2 = s1.getBytes("iso8859-1"); //用GBK解码 String s2 = new String(buf2,"GBK"); System.out.println("s2="+s2); &#125; 如果编码用GBK，解码用UTF-8，会出现什么问题 1234567891011121314151617181920public static void main(String[] args) throws UnsupportedEncodingException &#123; String str1 = "你好"; String str2 = "哈哈"; String str3 = "谢谢"; encodeDemo(str1); encodeDemo(str2); encodeDemo(str3); &#125;public static void encodeDemo(String str) throws UnsupportedEncodingException &#123; byte[] buf = str.getBytes("gbk"); String s1 = new String(buf,"utf-8"); System.out.println("s1="+s1); //用iso8859-1编码 byte[] buf2 = s1.getBytes("utf-8"); //用GBK解码 String s2 = new String(buf2,"GBK"); System.out.println("s2="+s2); &#125; 运行一下上面的代码 看看结果是什么样的？ 只有谢谢成功转回原样，其他的都是类似这样的–&gt;”锟斤拷锟�“ 我们把printBytes的注释 解掉，发现 ”-17 -65 -67“ ，重复出现，这是什么原因呢？ 因为”你好“的字节在经过 UTF-8 转义时出现了错误 ，没有能够成功识别， 返回的不是“你好”的字节，而是UTF-8特有的 未知字符 的字节 联通问题 切换到桌面，新建一个文本文档，在里面输入”联通“ 这两个字，保存后关闭，重新打开，发现什么问题？ 是否发现不是联通两个字，变成了未知字符那？ 123456789public static void main(String[] args) throws UnsupportedEncodingException &#123; String str = "联通"; byte[] buf = str.getBytes("gbk"); for (byte b : buf)&#123; System.out.print(b+" "); //System.out.println(Integer.toBinaryString(b)); System.out.println(Integer.toBinaryString(b&amp;255)); &#125; &#125; 我们试试用GBK解码”联通“，先看一下他的字节，没有发现什么，再转为二进制取后八位 123411000001101010101100110110101000 开头分别是110，10 这就导致它被记事本解码时，误以为是UTF-8，于是解码后出现未知字符 练习 在java中，字符串“abcd”与字符串“ab你好”的长度是一样，都是四个字符。 但对应的字节数不同，一个汉字占两个字节。 定义一个方法，按照最大的字节数来取子串 如：对于“ab你好”，如果取三个字节，那么子串就是ab与“你”字的半个， 那么半个就要舍弃。如果去四个字节就是“ab你”，取五个字节还是“ab你”. 思路： 我们先从GBK编码的入手，字母是一个字节，汉字是两个字节 汉字两个字节开头都是1，所以为负数，如“你”字，-60 -29 以”ab你好“为例，97 98 -60 -29 -70 -61 一次取5字节，进行判断 指针指向-70，为负数，指针前移，若指向负数，计数器每次加一，直到指针指向正数 如果计数器值%2为0，可以全部输出 如果%2为1，输出（截取字节数-1）个字节（取5字节就是这种情况） 12345678910111213141516171819202122232425public static void main(String[] args) throws IOException &#123; String str = "ab你好cd谢谢"; int len = str.getBytes("GBK").length; for(int x=0; x&lt;len; x++)&#123; System.out.println("截取"+(x+1)+"个字节结果是："+cutStringByByte(str, x+1)); &#125;&#125;public static String cutStringByByte(String str,int len) throws IOException&#123; byte[] buf = str.getBytes("gbk"); int count = 0; for(int x=len-1; x&gt;=0; x--)&#123; if(buf[x]&lt;0) count++; else break; &#125; if(count%2==0) return new String(buf,0,len,"gbk"); else return new String(buf,0,len-1,"gbk");&#125; UTF-8 1234567891011121314151617181920public static String cutStringByU8Byte(String str, int len) throws IOException &#123; byte[] buf = str.getBytes("utf-8"); int count = 0; for(int x=len-1; x&gt;=0; x--)&#123; if(buf[x]&lt;0) count++; else break; &#125; if(count%3==0) return new String(buf,0,len,"utf-8"); else if(count%3==1) return new String(buf,0,len-1,"utf-8"); else return new String(buf,0,len-2,"utf-8"); &#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-其余对象API]]></title>
    <url>%2F2018%2F05%2F15%2FJava-%E5%85%B6%E4%BD%99%E5%AF%B9%E8%B1%A1API%2F</url>
    <content type="text"><![CDATA[System类 System：类中的方法和属性都是静态的。 常用方法currentTimeMillis 获取当前时间的毫秒值。 1public static long currentTimeMillis(); 与1970.1.1午夜时间的差 Properties 获取系统的属性信息，并存储到了Properties集合中。 properties集合中存储都是String类型的键和值。 最好使用它自己的存储和取出的方法来完成元素的操作。 12345678910111213public static void demo_1()&#123; Properties prop = System.getProperties(); Set&lt;String&gt; nameSet = prop.stringPropertyNames(); for(String name : nameSet)&#123; String value = prop.getProperty(name); System.out.println(name+"::"+value); &#125;&#125; 在linux、windows上换行符号是不一样的 123456//如果这样写的话，这个换行符在哪个系统中都不会出问题System.out.println(System.getProperty("hello"+"line_separator"+"world");//如果多次调用太麻烦，就可以将他在文件中用final定义private static final String LINE_SEPARATOR = System.getProperty("line.separator");System.out.println("hello"+LINE_SEPARATOR+" world"); Runtime类 Runtime：没有构造方法摘要，说明该类不可以创建对象。 又发现还有非静态的方法。说明该类应该提供静态的返回该类对象的方法 而且只有一个，说明Runtime类使用了单例设计模式。 1234567891011public static void main(String[] args) throws IOException, InterruptedException &#123; Runtime r = Runtime.getRuntime();// execute: 执行。 xxx.exe Process p = r.exec("notepad.exe");// r.exec("D:\\abc\\asd\\xxxx.exe"); Thread.sleep(5000); //延迟 p.destroy(); //杀死进程，只能杀掉他开启的&#125; Math类 Math：提供了操作数学运算的方法。都是静态的 常用的方法： ceil()：返回大于参数的最小整数。（如18.6 返回19） floor()：返回小于参数的最大整数。（如18.6 返回18） round()：返回四舍五入的整数。 （如18.6 返回19） pow(a,b)：a的b次方。 random()：返回大于0.0且小于1.0的一个伪随机数 12345678910111213for (int i = 0; i &lt; 10; i++) &#123; double d1 = Math.ceil(Math.random()*10); //返回 1 到 10 的数值 double d2 = Math.ceil(Math.random()*10); //返回 0 到 9 的数值 double d3 = (int)(Math.random()*10+1); //返回 1 到 10 的数值 System.out.println(d1);&#125;//Random也有自己的对象Random r = new Random();for (int i = 0; i &lt; 10; i++) &#123; double d4 = (int)(r.nextDouble()*6+1); int d5 = r.nextInt(6); //限定数值大于0 小于6 System.out.println(d5);&#125; Date类 月份：0–11 （代表12个月） 日期对象、毫秒值之间的转换 毫秒值–&gt;日期对象 ： 1，通过Date对象的构造方法 new Date(timeMillis); 2，还可以通过setTime设置。 因为可以通过Date对象的方法对该日期中的各个字段(年月日等)进行操作。 日期对象–&gt;毫秒值： 2，getTime方法。 因为可以通过具体的数值进行运算。 123System.out.println(System.currentTimeMillis());Date d = new Date(1526459420372L); //因为数值太大，所以加上LSystem.out.println(d); 将日期对象进行格式化 将日期对象–&gt;日期格式的字符串 使用的是DateFormat类中的format方法 12345678910111213141516public static void methodDemo() &#123; Date date = new Date(); //获取日期格式对象。具体着默认的风格。 FULL LONG等可以指定风格。 DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG); dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);// System.out.println(dateFormat); //如果风格是自定义的如何解决呢？ dateFormat = new SimpleDateFormat("yyyy--MM--dd"); String str_date = dateFormat.format(date); System.out.println(str_date);&#125; 将日期格式的字符串–&gt;日期对象 使用的是Date Format类中的parse()方法。 12345678910111213public static void methodDemo_3() throws ParseException &#123; String str_date1 = "2018年5月16日"; DateFormat dateFormat1 = DateFormat.getDateInstance(DateFormat.LONG); String str_date2 = "2018---6---6"; DateFormat dateFormat2 = new SimpleDateFormat("yyyy---MM---dd"); Date date1 = dateFormat1.parse(str_date1); Date date2 = dateFormat2.parse(str_date2); System.out.println(date1); System.out.println(date2);&#125; 练习 计算2018-04-11与2018-05-16中间相差多少天 思路： 日期字符串转日期对象 日期对象转毫秒值 毫秒值相减，取绝对值 将结果转换成天数 1234567891011121314151617181920public class DateTest &#123; public static void main(String[] args) throws ParseException &#123; String str1 = "2018-04-11"; String str2 = "2018-05-16"; int day = datetest(str1, str2); System.out.println(day); &#125; public static int datetest(String str1,String str2) throws ParseException &#123; DateFormat dateFormat = DateFormat.getDateInstance(); Date date1 = dateFormat.parse(str1); Date date2 = dateFormat.parse(str2); long date = Math.abs(date2.getTime()-date1.getTime()); int day = getDay(date); return day; &#125; public static int getDay(long date)&#123; int day = (int)(date/1000/60/60/24); return day; &#125;&#125; calendar类 Date类中已经过时的类，都是在calendar中被替换 1234567891011121314public static void showDate(Calendar c) &#123; int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH)+1; //表示月份的数字是0-11 int day = c.get(Calendar.DAY_OF_MONTH); int week = c.get(Calendar.DAY_OF_WEEK); //这里的周日为美国的周一 System.out.println(year+"年"+month+"月"+day+"日"+getWeek(week));&#125;public static String getWeek(int i) &#123; String[] weeks = &#123;"","星期日","星期一","星期二","星期三","星期四","星期五","星期六"&#125;; return weeks[i];&#125; calendar中的add方法，偏移日期 123Calendar c = Calendar.getInstance();c.set(2018, 11, 20);c.add(Calendar.MONTH, 2);]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-集合框架]]></title>
    <url>%2F2018%2F05%2F10%2FJava-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[概述 集合类的由来： 对象用于封装特有数据，对象多了需要存储，如果对象的个数不确定。就使用集合容器进行存储。 集合特点： 用于存储对象的容器。 集合的长度是可变的。 集合中不可以存储基本数据类型值。 体系 集合容器因为内部的数据结构不同，有多种具体容器。不断的向上抽取，就形成了集合框架。 框架的顶层就是Collection接口： List：有序(存入和取出的顺序一致),元素都有索引(角标)，元素可以重复。 Set：元素不能重复,无序。 功能(Collection接口) 添加 12boolean add(E e);boolean addAll(Collection coll); 判断 123boolean remove(object obj):boolean removeAll(Collection coll);void clear(); 删除 123boolean contains(object obj):boolean containsAll(Colllection coll);boolean isEmpty();//判断集合中是否有元素。 获取 123456789int size():Iterator iterator():取出元素的方式：迭代器。该对象必须依赖于具体容器，因为每一个容器的数据结构都不同。所以该迭代器对象是在容器中进行内部实现的。对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可，也就是iterator方法。Iterator接口就是对所有的Collection容器进行元素取出的公共接口。其实就是抓娃娃游戏机中的夹子！ 其他 12boolean retainAll(Collection coll);//取交集。Object[] toArray();//将集合转成数组。 ​ 方法演示 展示一下如何使用这些方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class CollectionDemo &#123; /** * @param args */ public static void main(String[] args) &#123; Collection coll = new ArrayList(); // show(coll); Collection c1 = new ArrayList(); Collection c2 = new ArrayList(); show(c1,c2); &#125; public static void show(Collection coll)&#123; //1,添加元素。add. coll.add("abc1"); coll.add("abc2"); coll.add("abc3"); System.out.println(coll); //2，删除元素。remove coll.remove("abc2");//会改变集合的长度 //清空集合. //coll.clear(); System.out.println(coll.contains("abc3")); System.out.println(coll); &#125; public static void show(Collection c1,Collection c2)&#123; //给c1添加元素。 c1.add("abc1"); c1.add("abc2"); c1.add("abc3"); c1.add("abc4"); //给c2添加元素。 c2.add("abc1"); c2.add("abc2"); c2.add("abc3"); c2.add("abc4"); c2.add("abc5"); System.out.println("c1:"+c1); System.out.println("c2:"+c2); //演示addAll// c1.addAll(c2);//将c2中的元素添加到c1中。 //演示removeAll// boolean b = c1.removeAll(c2);//将两个集合中的相同元素从调用removeAll的集合中删除。// System.out.println("removeAll:"+b); //演示containsAll// boolean b = c1.containsAll(c2);// System.out.println("containsAll:"+b); //演示retainAll boolean b = c1.retainAll(c2);//取交集，保留和指定的集合相同的元素，而删除不同的元素。 //和removeAll功能相反 。 System.out.println("retainAll:"+b); System.out.println("c1:"+c1); &#125; &#125; ​ 迭代器 演示迭代器方法： 1234567891011121314151617181920212223public static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add("abc1"); coll.add("abc2"); coll.add("abc3"); coll.add("abc4"); // System.out.println(coll); // 使用了Collection中的iterator()方法。 调用集合中的迭代器方法，是为了获取集合中的迭代器对象。// Iterator it = coll.iterator(); // while(it.hasNext())&#123;// System.out.println(it.next());// &#125; //这样写也可以 for(Iterator it = coll.iterator(); it.hasNext(); )&#123; System.out.println(it.next()); &#125; &#125;&#125; 迭代器图解 List List：有序(存入和取出的顺序一致),元素都有索引(角标)，元素可以重复。 特有的常见方法：有一个共性特点就是都可以操作角标。 1234567891011121314151，添加 void add(index,element); void add(index,collection);2，删除； Object remove(index):3，修改： Object set(index,element);4，获取： Object get(index); int indexOf(object); int lastIndexOf(object); List subList(from,to); list集合是可以完成对元素的增删改查。 ListIterator 在迭代器过程中，不要使用集合操作元素，容易出现异常。 否则会报错（java.util.ConcurrentModificationException) 可以使用Iterator接口的子接口ListIterator来完成在迭代中对元素进行更多的操作。 它可以实现在迭代过程中完成对元素的增删改查。 注意：只有list集合具备该迭代功能 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; List list = new ArrayList(); list.add("abc1"); list.add("abc2"); list.add("abc3"); System.out.println("list:"+list); ListIterator it = list.listIterator(); while(it.hasNext())&#123; Object obj = it.next(); if(obj.equals("abc2"))&#123; it.set("abc9"); &#125; &#125; System.out.println("hasNext:"+it.hasNext()); //判断是否有上一个数据 System.out.println("hasPrevious:"+it.hasPrevious()); //反向迭代数据 while(it.hasPrevious())&#123; System.out.println("previous:"+it.previous()); &#125; System.out.println("list:"+list);&#125; List常用子类特点 Vector：内部是数组数据结构，是同步的。增删，查询都很慢！ ArrayList：内部是数组数据结构，是不同步的。替代了Vector。查询的速度快。 LinkedList：内部是链表数据结构，是不同步的。增删元素的速度很快。 Vector 的Enumeration方法和迭代器功能相同，但名字过长 LinkedList jdk1.6的方法更新 1234567891011getFirst();.//获取但不移除，如果链表为空，抛出NoSuchElementException.getLast();JDK1.6peekFirst();//获取但不移除，如果链表为空，返回null.peekLast():removeFirst();//获取并移除，如果链表为空，抛出NoSuchElementException.removeLast();JDK1.6pollFirst();//获取并移除，如果链表为空，返回null.pollLast(); 存储自定义对象12345678910111213141516171819202122public class ArrayListTest &#123; public static void main(String[] args) &#123; Person p1 = new Person("lisi1",21); ArrayList al = new ArrayList(); al.add(p1); al.add(new Person("lisi2",22)); al.add(new Person("lisi3",23)); al.add(new Person("lisi4",24)); Iterator it = al.iterator(); while(it.hasNext())&#123; //在这里进行向下转型，以使用子类特有方法 Person p = (Person) it.next(); System.out.println(p.getName()+"--"+p.getAge()); &#125; &#125; &#125; ​ 链表练习 用链表简单模拟一个堆栈及队列的输入输出过程 123456789101112131415161718192021222324252627282930313233import java.util.Iterator;import java.util.LinkedList;public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList link = new LinkedList(); link.addFirst("abc1"); link.addFirst("abc2"); link.addFirst("abc3"); link.addFirst("abc4");// System.out.println(link);// System.out.println(link.getFirst());//获取第一个但不删除。// System.out.println(link.getFirst()); // System.out.println(link.removeFirst());//获取元素但是会删除。// System.out.println(link.removeFirst()); while(!link.isEmpty())&#123; System.out.println(link.removeLast()); &#125; System.out.println(link);// Iterator it = link.iterator();// while(it.hasNext())&#123;// System.out.println(it.next());// &#125; &#125;&#125; Set Set:元素不可以重复，是无序。Set接口中的方法和Collection一致。 HashSet HashSet: 内部数据结构是哈希表 ，是不同步的。 如何保证该集合的元素唯一性呢？ 是通过对象的hashCode和equals方法来完成对象唯一性的！ 如果对象的hashCode值不同，那么不用判断equals方法，就直接存储到哈希表中。 如果对象的hashCode值相同，那么要再次判断对象的equals方法是否为true。 如果为true，视为相同元素，不存。如果为false，那么视为不同元素，就进行存储。 记住：如果元素要存储到HashSet集合中，必须覆盖hashCode方法和equals方法。一般情况下，如果定义的类会产生很多对象，比如人，学生，书，通常都需要覆盖equals，hashCode方法。建立对象判断是否相同的依据。 12345678910111213141516//Person类有name，年龄//重写hashCode，equalspublic int hashCode() &#123; return name.hashCode()+age*27; return 100;&#125;public boolean equals(Object obj) &#123; //判断是否是同一个对象 if(this == obj) return true; //判断是否属于Person类 if(!(obj instanceof Person)) throw new ClassCastException("类型错误"); Person p = (Person)obj; return this.name.equals(p.name) &amp;&amp; this.age == p.age;&#125; 练习 将Person类中去除相同元素 1234567891011121314151617181920//前提：Person中public static ArrayList getSingleElement(ArrayList al) &#123; //1,定义一个临时容器。 ArrayList temp = new ArrayList(); //2,迭代al集合。 Iterator it = al.iterator(); while(it.hasNext())&#123; Object obj = it.next(); //3,判断被迭代到的元素是否在临时容器存在。 if(!temp.contains(obj))&#123; temp.add(obj); &#125; &#125; return temp;&#125; LinkedHashSet 与HashSet区别就是HashSet无序，LinkedHashSet有序， TreeSet TreeSet可以对Set集合中的元素进行排序。是不同步的。 判断元素唯一性的方式：就是根据比较方法的返回结果是否是0，是0，就是相同元素，不存。 TreeSet对元素进行排序的方式一： 让元素自身具备比较功能，就需要实现Comparable接口。覆盖compareTo方法。 12345678910111213141516171819//Person中的方法public int compareTo(Object o) &#123; //向下转型前最好进行健壮性增强 Person p = (Person)o; int temp = this.age-p.age; return temp==0?this.name.compareTo(p.name):temp; /* if(this.age&gt;p.age) return 1; if(this.age&lt;p.age) return -1; else&#123; return this.name.compareTo(p.name); &#125; */&#125; 如果不要按照对象中具备的自然顺序进行排序。如果对象中不具备自然顺序。怎么办？ 可以使用TreeSet集合第二种排序方式二： 让集合自身具备比较功能，定义一个类实现Comparator接口，覆盖compare方法。 将该类对象作为参数传递给TreeSet集合的构造函数。 12345678910111213141516/** * 创建了一个根据Person类的name进行排序的比较器。 */public class ComparatorByName implements Comparator &#123; @Override public int compare(Object o1, Object o2) &#123; Person p1 = (Person)o1; Person p2 = (Person)o2; int temp = p1.getName().compareTo(p2.getName()); return temp==0?p1.getAge()-p2.getAge(): temp; //return 1; 这样写的话，注销前面的就意味着按输入顺序来 &#125;&#125; 内部实现用的二叉树，打个比方，返回正数为右子树，负数为左子树 泛型 jdk1.5出现的安全机制。 好处： 1、将运行时期的问题ClassCastException转到了编译时期。 2、避免了强制转换的麻烦。 &lt;&gt;:什么时候用？ 当操作的引用数据类型不确定的时候。就使用&lt;&gt;。将要操作的引用数据类型传入即可. 其实&lt;&gt;就是一个用于接收具体引用数据类型的参数范围。 在程序中，只要用到了带有&lt;&gt;的类或者接口，就要明确传入的具体引用数据类型 。 泛型技术是给编译器使用的技术,用于编译时期。确保了类型的安全。 擦除补偿 运行时，会将泛型去掉，生成的class文件中是不带泛型的,这个称为泛型的擦除。 为什么擦除呢？ 因为为了兼容运行的类加载器。 泛型的补偿： 在运行时，通过获取元素的类型进行转换动作。不用使用者在强制转换了。 泛型类 在jdk1.5后，使用泛型来接收类中要操作的引用数据类型。 泛型类。什么时候用？ 当类中的操作的引用数据类型不确定的时候，就使用泛型来表示。 123456789101112//主类调用此类时，需为其赋上数据类型public class Tool&lt;QQ&gt;&#123; private QQ q; public QQ getObject() &#123; return q; &#125; public void setObject(QQ object) &#123; this.q = object; &#125;&#125; 泛型方法 泛型方法的使用 1234567891011121314151617181920212223242526272829303132public class Tool&lt;QQ&gt;&#123; private QQ q; public QQ getObject() &#123; return q; &#125; public void setObject(QQ object) &#123; this.q = object; &#125; /** * 将泛型定义在方法上。 * @param str */ public &lt;W&gt; void show(W str)&#123; System.out.println("show : "+str.toString()); &#125; public void print(QQ str)&#123; System.out.println("print : "+str); &#125; /** * 当方法静态时，不能访问类上定义的泛型。如果静态方法使用泛型， * 只能将泛型定义在方法上。 * @param obj */ public static &lt;Y&gt; void method(Y obj)&#123; System.out.println("method:"+obj); &#125;&#125; 通配符 泛型的通配符：? 未知类型。 1234567891011121314151617181920212223public static void main(String[] args) &#123; ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;(); al.add(&quot;abc&quot;); al.add(&quot;hehe&quot;); ArrayList&lt;Integer&gt; al2 = new ArrayList&lt;Integer&gt;(); al2.add(5); al2.add(67); printCollection(al); printCollection(al2);&#125;/*** 迭代并打印集合中元素。* @param al*/public static void printCollection(Collection&lt;?&gt; al) &#123; Iterator&lt;?&gt; it = al.iterator(); while(it.hasNext())&#123; System.out.println(it.next().toString()); &#125;&#125; 泛型的限定 上限 ? extends E 接收E类型或者E的子类型对象 一般存储对象的时候用。比如 添加元素 addAll. 下限 ? super E 接收E类型或者E的父类型对象。 一般取出对象的时候用。比如比较器。 123456789public static void printCollection(Collection&lt;? extends Person&gt; al) &#123; Iterator&lt;? extends Person&gt; it = al.iterator(); while(it.hasNext())&#123; Person p = it.next(); System.out.println(p.getName()+":"+p.getAge()); &#125;&#125; 什么时候用上限？ 一般在存储元素的时候都是用上限，因为这样取出都是按照上限类型来运算的。不会出现类型安全隐患。 什么时候用下限呢？ 通常对集合中的元素进行取出操作时，可以使用下限。如TreeSet的比较器 集合选择技巧需要唯一吗？？ 需要：Set 需要制定顺序： 需要： TreeSet 不需要：HashSet 但是想要一个和存储一致的顺序(有序):LinkedHashSet 不需要：List 需要频繁增删吗？ 需要：LinkedList 不需要：ArrayList 如何记录各容器的结构和所属体系呢？？ List ArrayList LinkedList Set HashSet TreeSet 后缀名就是该集合所属的体系，前缀名就是该集合的数据结构。看到array：就要想到数组，就要想到查询快，有角标. 看到Link：就要想到链表，就要想到增删快，就要想要 add get remove方法及头插尾插法 看到hash：就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashCode方法和equals方法。 看到tree：就要想到二叉树，就要想要排序，就要想到两个接口Comparable，Comparator 。 而且通常这些常用的集合容器都是不同步的。 Map 一次添加一对元素。Collection 一次添加一个元素。 Map也称为双列集合，Collection集合称为单列集合。 其实map集合中存储的就是键值对。 map集合中必须保证键的唯一性。 常用方法123456789101112131415161，添加。 value put(key,value):返回前一个和key关联的值，如果没有返回null.2，删除。 void clear():清空map集合。 value remove(key):根据指定的key删除这个键值对。 3，判断。 boolean containsKey(key): boolean containsValue(value): boolean isEmpty();4，获取。 value get(key):通过键获取值，如果没有该键返回null。 当然可以通过返回null，来判断是否包含指定键。 int size(): 获取键值对的个数。 重点方法 取出map中所有元素 12345678910111213//取出map中的所有元素。//原理，通过keySet方法获取map中所有的键所在的Set集合，在通过Set的迭代器获取到每一个键，//在对每一个键通过map集合的get方法获取其对应的值即可。public static void keySetDemo(Map&lt;Integer,String&gt; map)&#123; Set&lt;Integer&gt; keySet = map.keySet(); Iterator&lt;Integer&gt; it = keySet.iterator(); while(it.hasNext())&#123; Integer key = it.next(); String value = map.get(key); System.out.println(key+":"+value);&#125; 取出map中所有元素–&gt;第二种方法 12345678910111213141516/** 通过Map转成set就可以迭代。* 找到了另一个方法。entrySet。* 该方法将键和值的映射关系作为对象存储到了Set集合中，而这个映射关系的类型就是Map.Entry类型(结婚证)*/public static void keySetDemo(Map&lt;Integer,String&gt; map)&#123; Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator(); while(it.hasNext())&#123; Map.Entry&lt;Integer, String&gt; me = it.next(); Integer key = me.getKey(); String value = me.getValue(); System.out.println(key+"::::"+value);&#125; 常用子类 Hashtable :内部结构是哈希表，是同步的。不允许null作为键，null作为值。 Properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合 。 |–HashMap : 内部结构是哈希表，不是同步的。允许null作为键，null作为值。 |–TreeMap : 内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。 ​ 练习一 将学生对象和学生的归属地通过键与值存储到map集合中。 123456789101112131415161718192021public static void hashMapMethod()&#123; HashMap&lt;Student,String&gt; hm = new HashMap&lt;Student,String&gt;(); hm.put(new Student("lisi",38),"北京"); hm.put(new Student("zhaoliu",24),"上海"); hm.put(new Student("xiaoqiang",31),"沈阳"); hm.put(new Student("wangcai",28),"大连"); //需要对student类进行hashCode、equals方法的重写 //否则相同的student也会被传进去 hm.put(new Student("zhaoliu",24),"铁岭"); //Set&lt;Student&gt; keySet = hm.keySet(); //Iterator&lt;Student&gt; it = keySet.iterator(); Iterator&lt;Student&gt; it = hm.keySet().iterator(); while(it.hasNext())&#123; Student key = it.next(); String value = hm.get(key); System.out.println(key.getName()+":"+key.getAge()+"---"+value); &#125;&#125; 如果需要进行排序的话，使用TreeMap 12345678910111213141516171819202122public static void treeMapDemo() &#123; TreeMap&lt;Student,String&gt; tm = new TreeMap&lt;Student,String&gt;(new ComparatorByName()); tm.put(new Student("lisi",38),"北京"); tm.put(new Student("zhaoliu",24),"上海"); tm.put(new Student("xiaoqiang",31),"沈阳"); tm.put(new Student("wangcai",28),"大连"); tm.put(new Student("zhaoliu",24),"铁岭"); Iterator&lt;Map.Entry&lt;Student, String&gt;&gt; it = tm.entrySet().iterator(); while(it.hasNext())&#123; Map.Entry&lt;Student,String&gt; me = it.next(); Student key = me.getKey(); String value = me.getValue(); System.out.println(key.getName()+":"+key.getAge()+"---"+value); &#125;&#125; 如果需要按输入顺序存储的话，LinkedHashMap 练习二12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* * 练习: * "fdgavcbsacdfs" 获取该字符串中，每一个字母出现的次数。 * 要求打印结果是：a(2)b(1)...; * 思路： * 对于结果的分析发现，字母和次数之间存在着映射的关系。而且这种关系很多。 * 很多就需要存储，能存储映射关系的容器有数组和Map集合。 * 关系一方式有序编号吗？没有！ * 那就是使用Map集合。 又发现可以保证唯一性的一方具备着顺序如 a b c ... * 所以可以使用TreeMap集合。 * * 这个集合最终应该存储的是字母和次数的对应关系。 * * 1，因为操作的是字符串中的字母，所以先将字符串变成字符数组。 * 2，遍历字符数组，用每一个字母作为键去查Map集合这个表。 * 如果该字母键不存在，就将该字母作为键 1作为值存储到map集合中。 * 如果该字母键存在，就将该字母键对应值取出并+1，在将该字母和+1后的值存储到map集合中， * 键相同值会覆盖。这样就记录住了该字母的次数. * 3，遍历结束，map集合就记录所有字母的出现的次数。 * */public class MapTest &#123; public static void main(String[] args) &#123; String str = "fdg+avAdc bs5dDa9c-dfs"; String s = getCharCount(str); System.out.println(s); &#125; public static String getCharCount(String str) &#123; //将字符串变成字符数组 char[] chs = str.toCharArray(); //定义map集合表。 Map&lt;Character,Integer&gt; map = new TreeMap&lt;Character,Integer&gt;(); for (int i = 0; i &lt; chs.length; i++) &#123; if(!(chs[i]&gt;='a' &amp;&amp; chs[i]&lt;='z' || chs[i]&gt;='A' &amp;&amp; chs[i]&lt;='Z'))// if(!(Character.toLowerCase(chs[i])&gt;='a' &amp;&amp; Character.toLowerCase(chs[i])&lt;='z')) continue; //将数组中的字母作为键去查map表。 Integer value = map.get(chs[i]); int count = 1; //判断值是否为null. if(value!=null)&#123; count = value+1; &#125; map.put(chs[i], count); &#125; return mapToString(map); &#125; private static String mapToString(Map&lt;Character, Integer&gt; map) &#123; StringBuilder sb = new StringBuilder(); //取出map中所有元素，更改格式存储 Iterator&lt;Character&gt; it = map.keySet().iterator(); while(it.hasNext())&#123; Character key = it.next(); Integer value = map.get(key); sb.append(key+"("+value+")"); &#125; return sb.toString(); &#125;&#125; 工具类Collections Collections是集合框架的工具类， 里面的方法都是静态的。 对list集合进行指定顺序的排列 12345//因为这个排序方法是基于比较器Comparable的，所以使用泛型//这样继承了Comparable的类及其父类都可以使用该方法public static &lt;T extends Comparable&lt;? super T&gt;&gt; void Sort(List&lt;T&gt; list)&#123; //代码&#125; 折半查找 binarySearch 最值 max 逆序 替换 replace 全部替换 fill 将list随机洗牌 shuffle 给非同步集合加锁 同步方法怎么实现的那？ 123456789101112131415161718192021222324252627282930class MyCollections&#123; public static List synList(List list)&#123; return new MyList(list); &#125; private class MyList implements List&#123; private List list; private static final Object lock = new Object(); MyList(List list)&#123; this.list = list; &#125; public boolean add(Object obj)&#123; synchronized(lock) &#123; return list.add(obj); &#125; &#125; public boolean remove(Object obj)&#123; synchronized(lock) &#123; return list.remove(obj); &#125; &#125; &#125;&#125; 那么该如何调用这个方法那？ 123List list = new ArrayList();//非同步的。list = MyCollections.synList(list);//返回一个同步的list. ArraystoString toString 经典实现 123456789101112131415//toString的经典实现。public static String myToString(int[] a)&#123; int iMax = a.length - 1; if (iMax == -1) return "[]"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) &#123;//中间省略条件判断，提高了效率。 b.append(a[i]); if (i == iMax) return b.append(']').toString(); b.append(", "); &#125;&#125; asList asList 数组转 List 集合 12345678910111213141516171819202122232425262728293031323334353637public static void demo_1() &#123; /* * 重点：List asList(数组)将数组转成集合。 * * 好处：其实可以使用集合的方法操作数组中的元素。 * * 注意：数组的长度是固定的，所以对于集合的增删方法是不可以使用的 * 否则会发生UnsupportedOperationException * */ String[] arr = &#123;"abc","haha","xixi"&#125;; boolean b = myContains(arr, "xixi"); System.out.println("contains:"+b); List&lt;String&gt; list = Arrays.asList(arr); boolean b1 = list.contains("xixi"); System.out.println("list contaisn:="+b1); //list.add("hiahia");//UnsupportedOperationException System.out.println(list);&#125;public static void demo_2() &#123; /* * 如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储。 * * 如果数组中的元素是基本类型数值，那么会将该数组作为集合中的元素进行存储。 * */ int[] arr = &#123;31,11,51,61&#125;; List&lt;int[]&gt; list = Arrays.asList(arr); System.out.println(list);&#125; toArray 集合转数组 12345678910111213141516171819202122232425 /** 集合转成数组呢？* * 使用的就是Collection接口中的toArray方法。* * 集合转成数组：可以对集合中的元素操作的方法进行限定。不允许对其进行增删。*/ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc1"); list.add("abc2"); list.add("abc3"); /* * toArray方法需要传入一个指定类型的数组。 * 长度该如何定义呢？ * 如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组。 * 如果长度大于集合的size，那么该方法就会使用指定的数组，存储集合中的元素，其他位置默认为null。 * * 所以建议，最后长度就指定为，集合的size。 */ String[] arr = list.toArray(new String[list.size()]); System.out.println(Arrays.toString(arr)); JDK5 特性ForEach概述123456foreach语句：格式：for(类型 变量 ：Collection集合|数组)&#123; &#125; 代码演示 1234567891011121314151617181920212223public static void main(String[] args)&#123; List&lt;String&gt; list =new ArrayList&lt;String&gt;(); list.add(&quot;abc1&quot;); list.add(&quot;abc2&quot;); list.add(&quot;abc3&quot;); for(String s : list)&#123; //简化书写。 System.out.println(s); &#125; int[] arr = &#123;3,1,5,7,4&#125;; for(int i : arr)&#123; System.out.println(i); &#125; // Iterator&lt;String&gt; it = list.iterator(); // while(it.hasNext())&#123;// System.out.println(it.next());// &#125;&#125; 传统for、高级for区别 传统for可以完成对语句执行很多次，因为可以定义控制循环的增量和条件。 高级for是一种简化形式。 它必须有被遍历的目标。该目标要是数组，要么是Collection单列集合。 对数数组的遍历如果仅仅是获取数组中的元素，可以使用高级for。 如果要对数组的角标进行操作建议使用传统for。 注意事项 可以使用高级for遍历map集合吗？ 不能直接用，但是可以将map转成单列的set，就可以用了。 12345678910111213141516171819Map&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(); map.put(3,"zhagsan"); map.put(1,"wangyi"); map.put(7,"wagnwu"); map.put(4,"zhagsansan"); for(Integer key : map.keySet())&#123; String value = map.get(key); System.out.println(key+"::"+value); &#125; for(Map.Entry&lt;Integer,String&gt; me : map.entrySet())&#123; Integer key = me.getKey(); String value = me.getValue(); System.out.println(key+":"+value); &#125; 函数可变参数 函数的可变参数。 其实就是一个数组，但是接收的是数组的元素。 自动将这些元素封装成数组。简化了调用者的书写。 注意：可变参数类型，必须定义在参数列表的结尾。 123456789101112131415161718192021222324public static void main(String[] args) &#123; int sum = newAdd(5,1,4,7,3); System.out.println("sum="+sum); int sum1 = newAdd(5,1,2,7,3,9,8,7,6); System.out.println("sum1="+sum1);&#125;public static int newAdd(int... arr)&#123; int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; sum+=arr[i]; &#125; return sum;&#125;注意！！！！public static int newAdd1(int... arr,int a)&#123; 会报错，因为arr吃掉了所有值&#125;public static int newAdd2(int a，int... arr)&#123; 这样就没事了&#125; 静态导入12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;import java.util.List;import static java.util.Collections.*;//静态导入，其实导入的是类中的静态成员。//import static java.util.Collections.max;//静态导入，其实导入的是类中的静态成员。import static java.lang.System.*;public class StaticImportDemo &#123; /** * @param args * 注意：如果两个类中有相同名字的方法，并且都会被使用 * 一定不能静态导入，否则程序会不知道用哪个方法 */ public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc3"); list.add("abc7"); list.add("abc1"); out.println(list); //collection.sort(list); sort(list); //静态导入后可以简写 String max = max(list); System.out.println("max="+max); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基本数据类型包装类]]></title>
    <url>%2F2018%2F05%2F10%2FJava-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[基本数据类型对象包装类 为了方便操作基本数据类型值，将其封装成了对象，在对象中定义了属性和行为丰富了该数据的操作 用于描述该对象的类就成为基本数据类型对象包装类 12345678byte Byteshort Shortint Integerlong Longfloat Floatdouble Doublechar Characterboolean Boolean 类型转换 该包装对象主要用于基本类型和字符串之间的转换 123456789基本类型---&gt;字符串 1、基本数据类型+"" 2、用String类中的静态方法 valueOf(基本类型数值) 3、用Integer方法的 valueOf(基本数据类型)字符串--&gt;基本类型 1、使用包装类中的静态方法 xxx parseXxx("xxx类型的字符串") 注意：只有Character类型没有该方法 2、如果字符串被Integer进行对象的封装，可使用另一个非静态的方法 intValue(); 将一个Integer对象转成基本数据类型值 进制转换 整数具备不同的进制体现 十进制–&gt;其他进制 1234Integer.toBinaryString(); //转换二进制Integer.toOctalString(); //转换八进制Integer.toHexString(); //转换十六进制Integer.toString(数，进制数); //转换任意进制 其他进制–&gt;十进制 1Integer.parseInt(&quot;需要转换的数据&quot;,进制数) 观察下面代码运行结果 1234567Integer a = new Integer("3");Integer b = new Integer(3);System.out.println(a==b); //falseSystem.out.println(a.equals(b)); //trueInteger c = new Integer(100);System.out.println(a.compareTo(c)); //-1System.out.println(c.compareTo(a)); //1 自动装拆箱 简化书写 1啊 注意事项 14 14分 练习 对一个字符串中的数值进行从小到大的排序 思路： 1，排序，我很熟。可是我只熟int。 2，如何获取到这个字符串中的这些需要排序的数值？？？发现这个字符串中其实都是空格来对数值进行分隔的。所以就想到用字符串对象的切割方法将大串变成多个小串。 3，数值最终变成小字符串，怎么变成一个int数呢？？？字符串–&gt;基本类型 可以使用包装类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class WrapperTest &#123; private static final String SPACE_SEPARATOR = " "; public static void main(String[] args) &#123; String numStr = "20 78 9 -7 88 36 29"; System.out.println(numStr); numStr = sortStringNumber(numStr); System.out.println(numStr); &#125; public static String sortStringNumber(String numStr) &#123; //1,将字符串变成字符串数组。 String[] str_arr = stringToArray(numStr); //2,将字符串数组变成int数组。 int[] num_arr = toIntArray(str_arr); //3,对int数组排序。 mySortArray(num_arr); //4,将排序后的int数组变成字符串。 String temp = arrayToString(num_arr); return temp; &#125; public static String arrayToString(int[] num_arr) &#123; StringBuilder sb = new StringBuilder(); for(int x = 0; x&lt;num_arr.length; x++)&#123; if(x!=num_arr.length-1) sb.append(num_arr[x]+SPACE_SEPARATOR); else sb.append(num_arr[x]); &#125; return sb.toString(); &#125; public static void mySortArray(int[] num_arr) &#123; Arrays.sort(num_arr); &#125; public static int[] toIntArray(String[] str_arr) &#123; int[] arr = new int[str_arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = Integer.parseInt(str_arr[i]); &#125; return arr; &#125; public static String[] stringToArray(String numStr) &#123; String[] str_arr = numStr.split(SPACE_SEPARATOR); return str_arr; &#125;&#125; ​]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-String及相关类]]></title>
    <url>%2F2018%2F05%2F08%2FJava-String%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[特点 字符串是一个初始化的对象 字符串一旦初始化就不可以被改变 12345678910111213//创建一个字符串对象在常量池中//池中没有就建立，有就使用String str = "abc";String str1 = "abc";System.out.println(str == str1); //true//str2 是在堆内存中创建的一个String对象//创建两个对象一个new一个字符串对象在堆内存中String str2 = new String("abc");System.out.println(str == str2); //falseSystem.out.println(str.equals(str2)); //true//String类中的equals方法复写了Object中的//其实就是比较字符串内容 构造函数12345678910111213String str = new String();//等价于 String str = "";//不等价于 String str = null; byte[] arr = &#123;97,66,67,68&#125;;String s1 = new String(arr);System.out.println("s1 = "+s1);//运行结果：s1 = aBCDchar[] chars = &#123;'q','w','e','r','t'&#125;;String s2 = new String(chars,1,3);System.out.println("s2 = "+s2);//运行结果：s2 = wer; 常见功能获取 获取字符串长度 1int length(); 根据位置获取字符 1char charAt(int index); 根据字符获取在字符串中第一次出现的位置 1234int indexOf(int ch);int indexOf(int ch,int fromIndex);//从指定位置查找int indexOf(String str);int indexOf(String str,int fromIndex); 根据字符获取在字符串中最后一次出现的位置 1234int lastIndexOf(int ch);int lastIndexOf(int ch,int fromIndex); //从指定位置反向搜索int lastIndexOf(String str);int lastIndexOf(String str,int fromIndex); 获取字符串的一部分，也叫子串 123注意：起始索引包括，结束索引不包括String substring(int beginIndex,int endIndex);String substring(int beginIndex);​ 转换 将字符串转换成字符串数组（字符串的切割） 1String[] split(String regex); 涉及正则表达式 将字符串转换成字符数组 1char[] toCharArray(); 将字符串转换成字节数组 12byte[] getBytes();注意：一个汉字占两个字节，且这两个字节的最高位都是1 将字符串的字母转成大小写 12String toUpperCase(); 转大写String toLowerCase(); 转小写 将字符串内容替换 12String replace(char oldch,char newch);String replace(String s1,String s2); 将字符串两端空格去除 1String trim(); 将字符串进行连接 1String concat(String); 判断 判断两个字符串内容是否相同 123boolean equals(Object obj);忽略大小写比较内容：boolean equalsIgnoreCase(String str); 字符串是否包含指定字符串 1boolean contains(String str); 字符串是否以指定字符串开头，或者结尾 12boolean startsWith(String);boolean endWith(String); ​ 比较 按字典顺序比较两个字符串 1compareTo(String); intern方法 返回字符串对象的规范化表示形式 12String s1 = new String("abc");String s2 = s1.intern(); ​ 练习题练习一 1、计算一个子串在整串中出现的次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Basic_1 &#123; public static void main(String[] args)&#123; String str = "nbaasdnbaanbanba"; String key = "nba"; //第一种方法会生成较多常量 int count = getKeyStringCount(str,key); //第二种方法较好 int count1 = getKeyStringCount_2(str,key ); System.out.println(count); System.out.println(count1); &#125; private static int getKeyStringCount_2(String str, String key) &#123; int count = 0; int index = 0; //从index处开始判断是否还含有子串 while((index = str.indexOf(key, index))!=-1)&#123; count++; //index加上刚才查找到的子串长度，从这里继续查 index = index + key.length(); &#125; return count; &#125; /** * 获取子串在整串中出现的个数 * @param str * @param key * @return */ private static int getKeyStringCount(String str, String key) &#123; //定义计数器 int count = 0; //记录变量key出现的位置 int index = 0; //循环判断是否还含有子串，有则加1 while((index = str.indexOf(key))!=-1) &#123; //将字符串切割掉刚才查找过的位置 str = str.substring(index+key.length()); count ++; &#125; return count; &#125;&#125; 练习二 2、模拟一个与trim功能一致的方法（去除字符串两边空白） 1234567891011121314151617181920public class Basic_4 &#123; public static void main(String[] args)&#123; String str = " as s "; System.out.println(str); str = myTrim(str); System.out.println(str); &#125; public static String myTrim(String str)&#123; int start = 0,end = str.length()-1; while (start&lt;=end &amp;&amp; str.charAt(start)==' ')&#123; start++; &#125; while (start&lt;=end &amp;&amp; str.charAt(end)==' ')&#123; end--; &#125; //注意：该方法结果包括起始索引，不包括结束索引 str = str.substring(start, end+1); return str; &#125;&#125; ​ StringBuffer类 StringBuffer：就是字符串缓冲区，用于存储数据的容器 可变数组原理：初始为16，超出后，长度翻倍至32，不够再增加 特点 1、长度可变的 2、可以存储不同类型数据 3、最终要转成字符串使用 4、可以对字符串修改 功能 1、添加 12StringBuffer append(data);StringBuffer insert(index,data); 2、删除 12StringBuffer delete(start,end);//删除头，不删除尾StringBuffer delete(index); //删除指定位置元素 3、查找 123char charAt(index);int indexOf(string);int lastOf(string); 4、修改 12StringBuffer replace(start,end,string);void setCharAt(index,chars); ​ StringBuilder类 JDK1.5后出现了功能和StringBuffer一模一样的对象，就是StringBuilder 不同的是： StringBuffer 是线程同步的，建议多线程使用 StringBuilder是线程不同步的，建议单线程使用，提高效率 JDK升级： 简化书写 增加效率 增加安全性 练习 将一个 int 数组转字符串 1234567891011public static String arrayToString(int[] arr)&#123; StringBuilder sb = new StringBuilder(); sb.append('['); for (int i = 0; i &lt; arr.length; i++) &#123; if(i!=arr.length-1) sb.append(arr[i]+','); else sb.append(arr[i]+']'); &#125; return sb.toString(); &#125; 针对本题，使用String和StringBuilder的区别？ 使用String每次变化都会产生一个新的字符串常量池中的一个成员 使用StringBuilder是不断的把字符串变成数组往容器里装]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-主题美化]]></title>
    <url>%2F2018%2F05%2F08%2FHexo-%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[博客搭建已经好久了，这段时间对next主题也根据个人的意愿进行了一些美化，就在这里记载下来 首页不显示全文 进入hexo博客项目的themes/next目录 打开_config.yml文件（主题配置文件） 搜索”auto_excerpt” 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 将enable的值从false改为true，再 hexo g hexo d就可以了 增加搜索功能 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑站点配置文件（hexo博客项目下的config_yml） 12345search: path: search.xml field: post format: html limit: 10000 博客里使用 Ctrl + F 进行搜索 添加顶部加载条 打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: 12&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 标签图标替换 将标签 # 更换为 修改模板 /themes/next/layout/_macro/post.swig12搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 鼠标点击小红心 将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 链接文本设置为蓝色 将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。 找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 访问量及阅读统计为NexT主题添加文章阅读量统计功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-多线程]]></title>
    <url>%2F2018%2F05%2F05%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述 进程：计算机中的程序关于某数据集合的一次运行活动，是系统进行资源分配和调度的基本单位。 线程：就是进程中的一个负责程序执行的控制单元（执行路径）。 一个进程中可以有多个执行路径，称之为多线程。 一个进程中至少要有一个线程 开启多个线程是为了同时运行多部分代码 每一个线程都有自己运行的内容，这个内容可以称为线程要执行的任务 利弊 多线程操作，可以让多个任务并行执行，a任务等待硬盘响应时，让b任务去用cpu，所以，多线程不能提高单任务的运行速度，但是可以提高多个可以并发的任务速度。 好处：解决多部分同时运行的问题 弊端：线程过多会导致效率的降低 JVM多线程分析 JVM启动时就启动了多个线程，至少有两个可以分析出来 1.执行main函数的线程 该线程的任务代码都定义在main函数中 2.负责垃圾回收的线程 创建线程创建方式一 继承 Thread 类 1、定义一个类继承 Thread 类 2、必须覆盖 Thread 类的 run 方法 3、直接创建 Thread 的子类对象创建线程 4、调用 start 方法开启线程并调用线程的任务 run 方法执行 12345678910111213141516171819202122232425262728293031323334/*创建线程的目的是开启一条执行路径，去运行指定的代码和其他代码同时运行而运行的代码就是这个执行路径的任务JVM创建的主线程的任务都定义在主函数中而自定义的线程，他的任务在哪儿？Thread类用于描述线程，线程是需要任务的，所以Thread类也对任务的描述这个任务就通过Thread类中的run方法来体现也就是说，run方法就是封装自定义线程运行任务的函数，run方法中定义就是线程要运行的任务代码*/public class Demo extends Thread&#123; private String name; public Demo(String name)&#123; this.name = name; &#125; public void run()&#123; show(); &#125; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.println(name+&quot;...i:&quot;+i); &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(&quot;小白&quot;); Demo b = new Demo(&quot;black&quot;); a.start(); b.start(); //a.run(); //b.run(); &#125;&#125; 在上述代码的结尾，调用run和start函数有什么区别？ 调用start函数是多线程的，调用run函数还是按顺序主线程进行的 线程名称 想要展示出当前运行对象线程名称需要使用Thread类的currentThread方法 123456789101112131415161718192021222324252627public class Demo extends Thread&#123; private String name; public Demo(String name)&#123; super(); this.name = name; //super(name); &#125; public void run()&#123; show(); &#125; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.print(name+&quot;...i:&quot;+i); System.out.println(&quot;ThreadName&quot;+Thread.currentThread().getName()); &#125; &#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(&quot;小白&quot;); Demo b = new Demo(&quot;black&quot;); a.start(); b.start(); System.out.println(&quot;here&quot;+&quot;...&quot;+Thread.currentThread().getName());// a.run();// b.run(); &#125;&#125; 运行后可以试着4.5行注释掉，6行解除注释试一下，发现可以自己给线程名称赋值了 图解 开启了多线程后，栈内存就和之前不一样了，以前面代码为示例 如果在上文倒数第三行加上一句代码“System.out.println(4/0);” 观察运行结果，发现main函数已经抛出异常终止了，其余两线程仍能正常进行 线程的状态 创建方式二 实现Runnable接口 1、定义类实现Runnable接口 2、覆盖接口中的run方法，将编程的任务代码封装到run方法中 3、通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递 4、调用线程对象的start方法开启线程 第三步的原因 因为线程的任务都封装在Runnable接口子类对象的run方法中，所以要在线程对象创建时就必须明确要运行的任务 123456789101112131415161718192021222324public class Demo implements Runnable&#123; //准备扩展Demo类的功能，让其中的内容可以作为多线程执行 //通过接口的方式完成 private String name; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.println(Thread.currentThread().getName()+&quot;...&quot;+i); &#125; @Override public void run() &#123; show(); &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(); Demo b = new Demo(); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); System.out.println(&quot;here&quot;+&quot;...&quot;+Thread.currentThread().getName()); &#125;&#125; 方式二细节方式二优点 实现Runnable接口的好处 1、将线程的任务从线程的子类中分离出来，进行了单独的封装，按照面向对象的思想将任务封装成了对象 2、避免了Java单继承的局限性 所以创建线程的第二种方式比较常用 卖票示例 在火车站一共有100张票，4个窗口同时卖票，用多线程来描述 运行图中左侧代码后发现，并不是想象中的卖100张，而是变成了4*100张，可以选择将ticket类中的num值变成静态变量，但这不是最好的选择。 另外还有人说可以不在堆中创建那么多的对象，只创建一个对象，进行4次线程开启，这是不可取的，多次启动一个线程是非法的。 12345678910111213141516171819202122 class Ticket implements Runnable&#123; private int num = 100; public void run()&#123; while(true)&#123; if(num&gt;0) System.out.println(num--); &#125; &#125; &#125; class TicketDemo&#123; public static void main(String[] args)&#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 通过继承的方式创建没有达到我们的目的，于是就采用上述代码中接口的方式创建 线程安全隐患 以车站卖票为示例，如果当车票只剩一张时，t1进入临时堵塞状态，有执行资格不具备执行权，推给t2执行，t2也临时堵塞一下，继续往后推，然后假设t3，t4也是临时堵塞，那他们现在都具备执行资格，没有执行权，然后t1卖出一张票，票数为0，但是t2.3.4都已经进入循环，可以卖票，于是分别卖出了第0.-1.-2张票。这对于铁路局来说是不允许的，有安全隐患。 有人说为什么我运行很多次都没有出现这种错误那，因为这只是有一定可能发生的，为了看起来更清晰，可以人为的方式，使产生安全隐患概率增加 12345678910111213141516class Ticket implements Runnable&#123; private int num = 100; public void run()&#123; while(true)&#123; if(num&gt;0)&#123; try&#123; Thread.sleep(10); &#125;catch(InterruptedException)&#123; //解决异常代码 &#125; System.out.println(num--); &#125; &#125; &#125;&#125; &#125; 将ticket类改成这样，在运行主类，发现会出现之前所说的安全隐患 线程安全问题产生原因 1、多个线程在操作共享数据 2、操作共享数据的线程代码有多条 当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算，就会导致线程安全问题的产生 解决思路（同步） 就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程不可以参与运算的，必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算 在Java中用同步代码块就可以解决这个问题 1234同步代码块格式：synchronized(对象)&#123; 需要被同步的代码；&#125; 所以更改代码后变为这样 123456789101112131415161718class Ticket implements Runnable&#123; private int num = 100; Object obj = new Object(); public void run()&#123; while(true)&#123; synchronized(obj)&#123; if(num&gt;0)&#123; try&#123; Thread.sleep(10); &#125;catch(InterruptedException)&#123; //解决异常代码 &#125; System.out.println(num--); &#125; &#125; &#125; &#125; &#125; 这次再去运行一下发现不会有问题 这很像锁，可以比喻成火车上的卫生间，一个人进去后，门锁上，门上有提示“有人”，别人就进不来，只有里面的人出去才可以。 同步的好处：解决了线程的安全问题 同步的弊端：相对降低了效率，因为同步外的线程都会判断同步锁同步前提 同步的前提：同步中必须有多个线程并使用同一个锁 1234567891011 private int num = 100; public void run()&#123; Object obj = new Object(); //注意：上面这句代码的位置和之前不同 while(true)&#123; synchronized(obj)&#123; //代码 &#125; &#125; &#125;&#125; 运行上面的代码后发现并没有解决安全问题，是因为这样写相当于有四个锁，把二三行代码换位置即可 同步函数 需求：两个储户去银行存款，每次100，存三次 1234567891011121314151617181920212223242526272829303132333435public class Bank &#123; private int sum; //private Object obj = new Object(); public synchronized void add(int num) &#123; //synchronized(obj)&#123; sum = sum + num; try &#123; //延时，增加出错可能性 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(sum); //&#125; &#125;&#125;public class Cus implements Runnable&#123; private String name; public Bank b = new Bank(); @Override public void run() &#123; for (int i=0; i&lt;3; i++) &#123; b.add(100); &#125; &#125;&#125;public class BankDemo &#123; public static void main(String[] args)&#123; Cus a = new Cus(); Thread t1 = new Thread(a); Thread t2 = new Thread(a); t1.start(); t2.start(); &#125;&#125; “多个线程在操作共享数据（sum），操作共享数据代码有多条（不算trycatch两条）”这两点都符合，所以有线程安全隐患 像上面这种情况，可以使用同步代码块，不过还有更简洁的方式就是在函数中加上同步关键字 验证同步函数锁 同步函数锁固定是this，同步代码块锁是任意的对象 开发中建议使用同步代码块 下面是验证时的代码（以双线程卖票为示例）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Ticket implements Runnable &#123; private int num = 100; boolean flag = true; public void run() &#123; if (flag) &#123; while (true) &#123; synchronized (this) &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;..emmm..&quot; + num--); &#125; &#125; &#125; &#125; else &#123; while (true) show(); &#125; &#125; public synchronized void show() &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;......&quot; + num--); &#125; &#125;&#125;public class SynFunctionLockDemo &#123; public static void main(String[] args)&#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t.flag = false; t2.start(); &#125;&#125; 验证静态同步函数锁 静态的同步函数使用的锁是 该函数所属的字节码文件对象 可以用getClass方法获取，也可以用 当前类名.class 表示 验证的代码和上面的大同小异，将this改为this.getClass或者Ticket.class再试试 单例模式涉及的多线程问题安全隐患分析 会出现安全隐患的是懒汉式，也就是延迟加载单例模式 123456789public class Single2 &#123; private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null) s = new Single2(); return s; &#125;&#125; 仔细想一下，他符合了会出现隐患的两个因素，线程0在进行（s==null）判断后，进入临时堵塞状态，然后线程1进行null的判断，进入临时堵塞状态。这时线程0创建了s对象，返回s，线程1又创建了一个对象，现在就有两个对象，不能保证唯一了，这就出现大问题了。 解决方法 加同步代码块解决安全问题，外面再加一次判断是解决效率问题 12345678910111213public class Single2 &#123; private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null)&#123; synchronized(Single2.class)&#123; if(s==null) s = new Single2(); &#125; &#125; return s; &#125; &#125; 死锁 常见情景之一：同步的嵌套 12 run函数里拿着obj的锁想进this的锁，show函数里拿着this锁想进obj 简单死锁代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MyLock &#123; //写两个锁 public static final Object MyLockA = new Object(); public static final Object MyLockB = new Object();&#125;import static bxdDay_13.MyLock.MyLockA;import static bxdDay_13.MyLock.MyLockB;public class DeadLock implements Runnable&#123; public boolean flag; //有参构造函数，创建对象时附带flag状态 public DeadLock(boolean flag)&#123; this.flag = flag; &#125; @Override public void run() &#123; if (flag)&#123; synchronized (MyLockA)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;if LockA&quot;); synchronized (MyLockB)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;if LockB&quot;); &#125; &#125; &#125;else &#123; synchronized (MyLockB)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;else LockB&quot;); synchronized (MyLockA)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;else LockA&quot;); &#125; &#125; &#125; &#125;&#125;public class DeadLockTest &#123; public static void main(String[] args)&#123; DeadLock a = new DeadLock(true); DeadLock b = new DeadLock(false); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); &#125;&#125; 运行上面的代码，观察结果,线程1拿到了B锁，线程2拿到了A锁，他们都想继续，可是互不相让，死锁了 12Thread-1 else LockBThread-0 if LockA 如果试了多次都是没有成功死锁，那就在 if语句 及 else语句 后面各加一句 while(true) 线程间通信 多个线程在处理资源，但是任务却不同 同步前提：多个线程使用同一个锁 接下来用一个例子演示一下 需求：有一个资源库存放数据，一条线程在向里面输入，还有一条在向外输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//资源类public class Resource &#123; public String name; public String sex;&#125;//输入类public class Input implements Runnable &#123; Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; synchronized (r) &#123; if (x == 0) &#123; r.name = &quot;小白&quot;; r.sex = &quot;女女女&quot;; &#125; else &#123; r.name = &quot;black&quot;; r.sex = &quot;malemale&quot;; &#125; x = (++x) % 2; &#125; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; synchronized (r) &#123; System.out.println(&quot;name:&quot; + r.name + &quot;...&quot; + &quot;sex:&quot; + r.sex); &#125; &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args)&#123; //创建资源 Resource r = new Resource(); //创建任务 Input in = new Input(r); Output out = new Output(r); //创建线程，执行路径 Thread t1 = new Thread(in); Thread t2 = new Thread(out); //开启线程 t1.start(); t2.start(); &#125;&#125; 上面的代码中输入设置的是输入两个人名，需要注意的地方是，输入和输出类中加的锁是一样的，都是r，这个在测试类中，创建in、out对象时，要给他们传一样的参数。否则同步锁无用！ 但是这样的代码运行后还是不太好，因为输出的都是大片相同的人名，想让他们输入一个就输出一个，就需要使用线程的等待唤醒机制了。 等待唤醒机制 涉及方法 wait()：让线程处于冻结状态，被wait的线程会被存储到线程池中 notify()：唤醒线程池中的一个线程（任意） nitifyAll()：唤醒线程池中的所有线程 这些方法都必须定义在同步中，因为这些方法是用于操作线程状态的方法，必须要明确到底操作的是哪个锁上的线程 观察api文档后，为什么操作线程的方法wait、notify、notifyAll定义在Object类中那？ 因为这些方法是监视器的方法，监视器其实就是锁，锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//资源类public class Resource &#123; public String name; public String sex; public boolean flag = false;&#125;//输入类public class Input implements Runnable &#123; Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; synchronized (r) &#123; if (r.flag) &#123; try &#123; r.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (x == 0) &#123; r.name = &quot;小白&quot;; r.sex = &quot;女女女&quot;; &#125; else &#123; r.name = &quot;black&quot;; r.sex = &quot;malemale&quot;; &#125; r.flag = true; r.notify(); &#125; x = (++x) % 2; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; synchronized (r) &#123; if (!r.flag) &#123; try &#123; r.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;name:&quot; + r.name + &quot;...&quot; + &quot;sex:&quot; + r.sex); r.flag = false; r.notify(); &#125; &#125; &#125;&#125; 思路：输入数据之前判断一下是否有数据，如果有数据，控制输入的线程等待，先让控制输出的线程输出，输出数据后，将flag更改为false，意味着资源中数据为空，可以继续输入，然后再将控制输入的线程唤醒,自己（控制输出的线程）等待。这样就可以实现输入一个数据再输出一个数据了。 注意：输入输出的锁都是 r，等待唤醒中的线程池都是基于这个锁（也就是 r） 代码优化 上面的代码虽然最后实现了功能，但是封装性差,我们可以把输入，输出的方法定义在资源类中，在输入输出类中调用输入输出的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//资源类public class Resource &#123; private String name; private String sex; private boolean flag = false; //输入方法 public synchronized void set(String name,String sex)&#123; if (this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name; this.sex = sex; this.flag = true; this.notify(); &#125; //输出方法 public synchronized void out()&#123; if (!this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;name:&quot; + name + &quot;...&quot; + &quot;sex:&quot; + sex); this.flag = false; this.notify(); &#125;&#125;//输入类public class Input implements Runnable &#123; private Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; if (x == 0) &#123; r.set(&quot;小白&quot;,&quot;女女女&quot; ); &#125; else &#123; r.set(&quot;black&quot;, &quot;malemale&quot;); &#125; x = (++x) % 2; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; private Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; r.out(); &#125; &#125;&#125; 对共享资源修改的语句都写在了资源类中，可以给他们加同步锁，但是还是在方法中加上同步关键字看上去更简洁，这样他们加的锁还是同一个锁—&gt; this 。 生产者消费者问题 假设生产者生产产品，消费者消费产品，和上面进出资源的问题差不多 问题一 这里直接开始4个线程的，两个生产者，两个消费者，运行一下，会发现有错误，比如一个生产者生产完一件产品，消费者连着两次消费这一件产品。这类问题产生的原因是什么那？ t0、t1是生产者 t2、t3是消费者，让我们按照代码的顺序走一遍。 t0进行判断，生产产品（1），t0等待，t1进行判断，t1等待。t2进行判断，消费产品（1），t2等待，t3进行判断，t3等待。唤醒t0，t0没有进行判断，生产产品（2），t0等待。然后需要唤醒一个线程，但是这时线程池中有三个在等待，如果唤醒的是t1，t1没有进行判断直接生产产品（3），t1等待，唤醒t2，t2消费了产品（3），如果再唤醒t3，t3没有进行判断，就会再消费产品（3） 问题1产生原因：if判断标记，只有一次，会导致不该运行的线程运行了，出现了数据错误的情况 解决方法：将资源类中的输入输出方法的 if 判断改为 while 循环，这样就不会唤醒后跳过判断了，不过这样又会产生一个新的问题 问题二 问题2：4个线程都处在等待状态，没人去唤醒他们 产生原因：notify只能唤醒一个线程，如果本方唤醒本方，无意义，而且while+notify会导致死锁 解决办法：将资源类中的输入输出方法的唤醒改为全部唤醒（notifyAll）1234567891011121314151617181920212223242526272829303132333435//这里就只贴上资源类的代码了，其他类代码的写法和上面差不多//还需要有生产者类，消费者类 实现Runnable接口，和Test类//资源类public class Resource &#123; private String name; private int count = 1; private boolean flag = false; public synchronized void set(String name)&#123; while (this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); this.flag = true; this.notifyAll(); &#125; public synchronized void out()&#123; while (!this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); this.flag = false; this.notifyAll(); &#125;&#125; 问题三 解决了第二个问题后，已经不会报错了，但是还有些小弊端，使用notifyAll方法的时候会唤醒所有等待线程，但是如果唤醒了本方等待线程会降低效率，能不能只唤醒对方线程那？ 解决方法：使用jdk1.5新特性中的Lock Condition，可以创建多个监视器，该问题中，创建两个即可。关于Lock，Condition可以看该文章偏靠后的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;//资源类public class Resource &#123; private String name; private int count = 1; private boolean flag = false; public Lock lock = new ReentrantLock(); //通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者 public Condition producer_con = lock.newCondition(); public Condition consumer_con = lock.newCondition(); public void set(String name)&#123; //生产者 t0 t1 lock.lock(); try &#123; while (flag) &#123; try &#123; //该生产者线程进入等待状态 producer_con.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); flag = true; //唤醒随机一个消费者 consumer_con.signal(); &#125;finally &#123; //如果抛出异常，必须将关锁写在finally中 lock.unlock(); &#125; &#125; public void out()&#123; //消费者 t2 t3 lock.lock(); try &#123; while (!flag) &#123; try &#123; //该消费者进入等待状态 consumer_con.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); flag = false; //唤醒随机一个生产者 producer_con.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; locks包Lock接口 java.util.concurrent.locks.Lock Lock替代了同步代码块或者同步函数，将同步的隐式锁操作变成显式锁操作，同时更为灵活，可以一个锁加上多个监视器。 方法： lock()：获取锁 unlock()：释放锁，通常需要定义在finally代码块中 1234567//同步代码块对于锁的操作是隐式的Object obj = new Object();void show()&#123; synchronized(obj)&#123; ...code... &#125;&#125; 12345678//同步和锁被封装成了对象，并将操作锁的隐式方式定义到了该对象中//将隐式动作变为了显式动作。Lock lock = new ReentrantLock();void show()&#123; lock.lock();//获取锁 ...code... lock.unlock();//释放锁&#125; 如果上面代码第六行位置会抛异常的话，一定要将释放锁写在finally里123456789Lock lock = new ReentrantLock(); void show()&#123; lock.lock();//获取锁 try&#123; ...code... &#125;finally&#123; lock.unlock();//释放锁 &#125; &#125; Condition接口 Condition接口出现替代Object中的wait notify notifyAll等方法，将他们单独进行了封装，变成了Condition监视器对象，可以与任意锁进行组合 方法： await()：等待 signal()：唤醒 signalAll()：全部唤醒 1234567891011121314151617//旧版功能演示//在没有Lock，Condition之前，生产消费者问题只能创建一个监视器Object obj = new Object();synchronzied(obj)&#123; obj.wait(); obj.notify(); obj.notifyAll();&#125;//新版功能演示Lock lock = new ReectrantLock();//生产者的锁Condition producter_con = lock.newCondition();//消费者的锁Condition consumer_con = lock.newCondition();producter_con.await();producter_con.signal();producter_con.signalAll(); 范例123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class BoundedBuffer &#123; final Lock lock = new ReentrantLock();//锁对象 final Condition notFull =lock.newCondition();//写线程条件 final Condition notEmpty = lock.newCondition();//读线程条件 final Object[] items = new Object[100];//缓存队列 //下面是操作上面数组的变量（前两个指针） int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/; public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length)//如果队列满了 notFull.await();//阻塞写线程 items[putptr] = x;//赋值 if (++putptr == items.length) putptr = 0;//如果写索引写到队列的最后一个位置了，那么置为0 ++count;//个数++ notEmpty.signal();//唤醒读线程 &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0)//如果队列为空 notEmpty.await();//阻塞读线程 Object x = items[takeptr];//取值 if (++takeptr == items.length) takeptr = 0;//如果读索引读到队列的最后一个位置了，那么置为0 --count;//个数-- notFull.signal();//唤醒写线程 return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 这是一个处于多线程工作环境下的缓存区，缓存区提供了两个方法，put和take，put是存数据，take是取数据，内部有个缓存队列，具体变量和方法说明见代码，这个缓存区类实现的功能：有多个线程往里面存数据和从里面取数据，其缓存队列(先进先出后进后出)能缓存的最大数值是100，多个线程间是互斥的，当缓存队列中存储的值达到100时，将写线程阻塞，并唤醒读线程，当缓存队列中存储的值为0时，将读线程阻塞，并唤醒写线程，这也是ArrayBlockingQueue的内部实现。 下面分析一下代码的执行过程： 1、一个写线程执行，调用put方法； 2、判断count是否为100，显然没有100； 3、继续执行，存入值； 4、判断当前写入的索引位置++后，是否和100相等，相等将写入索引值变为0，并将count+1； 5、仅唤醒读线程阻塞队列中的一个； 6、一个读线程执行，调用take方法； 7、…… 8、仅唤醒写线程阻塞队列中的一个 如果不用多个 Condition ，只有一个Condition或者使用的同步代码块的内容时，当存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。 线程终止wait和sleep区别 wait可指定也可不指定时间，sleep必须指定时间 同步中时，对cpu的执行权和锁的处理不同 wait：释放执行权，释放锁 sleep：释放执行权，不释放锁 终止线程方式 停止线程： stop方法：不推荐使用 run方法结束 怎么控制线程中的任务结束那？ 任务中都会有循环结构，只要控制住循环就可以结束任务，控制循环通常就用定义标记来完成 123456789101112//通过在主函数中调用setFlag方法，即可终止线程public class StopThread implements Runnable&#123; private boolean flag = true; public void run()&#123; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; public void setFlag()&#123; flag = false; &#125;&#125; 但是使用这种方法也有一定的弊端，如果线程处于冻结状态无法读取标记，程序就不能停下来了 1234567891011//这样的程序无法终止public synchronized void run()&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; 可以使用interrupt()方法将线程从冻结状态强制恢复到运行状态中来，让线程具备cpu的执行资格，但是强制动作会发生InterruptedException异常，记得要处理 123456789101112131415161718192021222324252627282930313233343536373839public class StopThread implements Runnable&#123; private boolean flag = true; public synchronized void run()&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); //也可以选择在这里更改标记 //flag = false; &#125; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; public void setFlag()&#123; flag = false; &#125;&#125;public class StopThreadDemo &#123; public static void main(String[] args)&#123; StopThread s = new StopThread(); Thread t1 = new Thread(s); Thread t2 = new Thread(s); t1.start(); t2.start(); int num = 1; for(;;)&#123; if(++num == 50)&#123; //这里加上了interrupt方法 t1.interrupt(); t2.interrupt(); s.setFlag(); break; &#125; System.out.println(Thread.currentThread().getName()); &#125; &#125;&#125; 守护线程 setDaemon可以将线程变为守护线程（后台线程） 后台线程在运行时与前台线程无差别，前台线程终止时必须手动终止，如果前台线程都终止了，后台线程自动终止线程小方法join join方法也会抛出中断异常1234567891011121314//有线程t0、t1t0.start();t0.join();t1.start();System.out.println(&quot; &quot;);//运行结果一定是t0线程运行完，//运行main线程，再运行t1线程//情况2t0.start();t1.start();t0.join();System.out.println(&quot; &quot;); //运行结果：t0，t1互相抢占cpu，main等t0执行完再执行 线程优先值 可以给线程分配不同优先级的值，会让他们在执行中被执行几率增加 123456//t0为线程名t0.setPriority(Thread.MAX_PROIORITY);//为了方便，设置三个final值//MAX_PROIORITY = 10//MIN_PROIORITY = 0;//NORM_PROIORITY = 5; 两道多线程面试题 判断下面的程序是否能成功运行，如果不能，报错在哪一行 123456public class Test implements Runnable&#123; public void run(Thread t)&#123;&#125;&#125;//最后报错在第一行，第二行是子类的特有方法//在这个接口的实现类中没有覆盖run方法//报错解决：使用abstract修饰类或者覆盖run方法 判断下面程序，运行结果是什么？123456789101112131415public class ThreadTest &#123; public static void main(String[] main)&#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;我是任务里面的 &quot;); &#125; &#125;)&#123; public void run() &#123; System.out.println(&quot;我是子类里面的 &quot;); &#125; &#125;.start(); &#125;&#125;//现在的运行结果是“我是子类里面的”//如果注释掉8.9.10行，结果是“我是任务里面的”]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-异常]]></title>
    <url>%2F2018%2F05%2F03%2FJava-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[概述 异常：运行时期发生的不正常情况 在java中用类的形式对不正常情况进行了描述和封装对象 描述不正常的情况的类，被称为异常类 以前正常流程代码和问题处理代码相结合，现在将正常流程代码、问题处理代码分离，提高阅读性 其实异常就是java通过面向对象的思想将问题封装为对象，用异常类对其描述 不同类用问题用不同的类进行具体的描述，比如角标越界，空指针等等。 体系 问题很多，意味着描述的类也很多，将其共性进行向上抽取，形成了异常体系 最终问题就分成了两大类 Throwable：（直译：可抛的）问题发生应该就可以抛出，让调用者知道并处理 1、一般不可处理的 Error 2、可以处理的 Exception 该体系的特点就在于 Throwable 及其所有的子类都具有可抛性 可抛性是怎么体现的那？ 通过throws throw 这两个关键字所操作的类和对象都具备可抛性 该体系特点： 子类的后缀名都是用其父类名作为后缀，阅读性很强 Error JVM抛出的严重性问题，这种问题发生一般不针对性处理，直接修改程序 123456public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[1024*1024*800]; //java.lang.OutOfMemoryError: Java heap space &#125;&#125; Exception 分为两种： 编译时受检测异常：Exception和其子类都是，除了特殊子类RuntimeExcetion 这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。 编译不检测异常（运行时异常）：RuntimeExcetion和其子类 这种问题的发生，让功能无法继续，运算也无法进行，更多是因为调用的原因导致的，或者引发程序内部状态改变，导致的异常。这种问题一般不处理，直接编译通过，在运行时，调用者调用时引发异常从而程序强制停止，此时调用者即可对异常进行修正。 过程 运到识别的问题，对象进行封装 把问题抛给调用者 123456789101112131415161718public class Demo &#123; public int method(int[] arr,int index)&#123; if(arr == null) throw new NullPointerException(&quot;你咋空指针了&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;兄台，数组越界了，角标是：&quot;+index); return arr[index]; &#125;&#125;public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[3]; Demo d = new Demo(); d.method(arr, 30); &#125;&#125; 自定义异常 对于角标是整数不存在，可以用角标越界表示，对于负数角标的情况，准备用负数角标异常表示，但是这在Java中没有定义过，那就按照Java异常的创建思想，面向对象，将负数角标进行自定义描述，并封装成对象，这种自定义问题描述称为自定义异常。 注意：如果让一个类称为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性。才可以被两个关键字所操作 throws throw 12345678910111213141516171819202122232425262728 class FuShuIndexException extends Exception&#123; FuShuIndexException()&#123;&#125; FuShuIndexException(String msg)&#123; Super(msg); &#125; &#125; class Demo&#123; public int method(int[] arr,int index) throws FuShuIndexException&#123; if(arr==null) throw new NullPointerException(&quot;数组的引用不能为空&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;数组角标越界=&quot; + index); if(index &lt; 0) throw new FuShuIndexException(); return arr[index]; &#125; &#125; public class ExceptionDemo &#123; public static void main(String[] args) throws FuShuIndexException &#123; int[] arr = new int[3]; Demo d = new Demo(); d.method(arr, -1); &#125; &#125; 自定义的异常，要么继承Exception,要么继承RuntimeException 抛出 throw throw和throws区别： throws使用在函数上，抛出的是异常类，可以跑出多个，用逗号隔开 throw使用在函数内，抛出的是异常对象 捕捉 catch 可以对异常进行针对性处理的方式 12345678具体格式： try&#123; //需要被检测异常的代码 &#125;catch(异常类 变量)&#123; //该变量用于接收发生的异常对象 //真正处理该异常的代码 &#125;finally&#123; //一定会被执行的代码 &#125; 下面是演示代码 12345678910111213141516171819202122232425262728public class Demo &#123; public int method(int[] arr,int index)&#123; if(arr == null) throw new NullPointerException(&quot;你咋空指针了&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;兄台，数组越界了，角标是：&quot;+index); return arr[index]; &#125;&#125;public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[3]; Demo d = new Demo(); try &#123; int num = d.method(null, 30); System.out.println(num); &#125;catch (NullPointerException e)&#123; System.out.println(e.toString()); &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;message:&quot;+e.getMessage()); System.out.println(&quot;String:&quot;+e.toString()); //e.printStackTrace();//Jvm默认处理机制就是调用异常这个方法 System.out.println(&quot;越界&quot;); &#125;/*catch (Exception e)&#123; //多catch，父类的catch放在最下面 &#125;*/ &#125;&#125; finally代码块 除了在catch中强制关闭JVM的情况下，finally中的语句都会被执行 123456789101112131415161718/* 情况1： 运行结果：finally*/try &#123; //需要被检测异常的代码&#125;catch (NullPointerException e)&#123; //处理异常的代码 return;&#125;finally&#123; //通常用于关闭（释放）资源 System.out.println(&quot;finally&quot;);&#125;System.out.println(&quot;Over&quot;);/* 情况2：去掉第9行的return后，运行 结果：finally Over*/ try catch finally 代码组合特点 1、try catch finally 2、try catch（多个） 没有必要资源需要释放时，可以不用定义finally 3、try finally 异常无法直接处理，但是资源需要关闭 123456try&#123; //开启资源 throw new Exception;&#125;finally&#123; //关闭资源&#125; 异常处理原则 1、函数内部如果抛出需要检测的异常，函数上必须要声明，否则必须在函数内用trycatch捕捉，否则编译失败 2、如果调用到了声明异常的函数，要么trycatch，要么throws，否则编译失败 3、什么时候catch，什么时候throws那？ 功能内容可以解决，用catch 解决不了，用throws告诉调用者，由调用者解决 4、一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理，内部有几个需要检测的异常，就抛几个异常，抛出几个，就catch几个 异常应用 用Java描述老师上课，需要电脑，电脑会出现蓝屏冒烟两种故障 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class LanPingException extends Exception &#123; LanPingException(String msg)&#123; super(msg); &#125;&#125;public class MaoYanException extends Exception &#123; MaoYanException(String msg)&#123; super(msg); &#125;&#125; public class Computer &#123; private int state = 0; public void run() throws LanPingException, MaoYanException &#123; if (state == 1) throw new LanPingException(&quot;蓝屏&quot;); if (state == 2) throw new MaoYanException(&quot;冒烟&quot;); System.out.println(&quot;computer run&quot;); &#125; public void reset()&#123; state = 0; System.out.println(&quot;电脑重启&quot;); &#125;&#125;public class Teacher &#123; private String name; private Computer comp; public Teacher(String name)&#123; this.name = name; comp = new Computer(); &#125; public void prolect() throws MaoYanException&#123; try &#123; comp.run(); System.out.println(name+&quot;讲课&quot;); &#125;catch (LanPingException e)&#123; e.getMessage(); comp.reset(); prolect(); &#125;catch (MaoYanException e)&#123; System.out.println(e.toString()); practice(); throw e; &#125; &#125; public void practice()&#123; System.out.println(&quot;电脑坏了，大家练习&quot;); &#125;&#125;public class Demo &#123; public static void main(String[] args)&#123; Teacher t = new Teacher(&quot;cheng&quot;); try &#123; t.prolect(); &#125; catch (MaoYanException e) &#123; System.out.println(&quot;......&quot;); &#125; &#125;&#125; 数据库连接出现异常怎么解决那 123456789101112131415class NoAddException extends Exception&#123;&#125;void addData(Data d) throws NoAddException&#123; 连接数据库 try&#123; 添加数据，出现异常 &#125;catch(NoAddException e)&#123; //处理代码 throw new NoAddException(); &#125;finally&#123; 关闭数据库 &#125;&#125; 注意事项 1、子类在覆盖父类方法的时候，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常，或者该异常的子类 2、如果父类抛出多个异常，子类只能抛出父类异常的子集 简而言之：子类覆盖父类方法时，只能抛出父类异常或异常子类或子集 注意：若父类方法没抛出异常，子类覆盖时绝对不能抛出异常，只能try]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-Object类]]></title>
    <url>%2F2018%2F05%2F03%2FJava-Object%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类 Object ：所有类的根类 Object 是抽取而来的，具备着所有对象都具备的共性内容 常用的共性内容： equals 方法 hashCode 方法 getClass 方法 toString 方法equals方法 equals 实现对象上差别可能性最大的相等关系，即，对于任何非空引用值 x 和 y ，当且仅当 x 和 y引用同一个对象时，此方法才返回 true （x==y 具有值 true） 12345678910111213141516public class Person &#123; private int age; public Person(int age)&#123; this.age = age; &#125;&#125;public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); Person p2 = new Person(20); Person p3 = p1; System.out.println(p1==p2); System.out.println(p1.equals(p2)); System.out.println(p1.equals(p3)); &#125;&#125; equals 方法重写，比较成员变量值 123456789101112131415161718public class Person &#123; private int age; public Person(int age)&#123; this.age = age; &#125; /* 一般都会覆盖此方法，根据对象的特有内容，建立判断对象是否相同的依据 */ public boolean equals(Object obj)&#123;//会将参数中的对象进行向上转型 //为了提高程序鲁棒性，进行判断 if (!(obj instanceof Person))&#123; throw new ClassCastException(&quot;类型错误&quot;); &#125; //为了使用子类的私有方法，进行向下转型 Person p = (Person) obj; return this.age == p.age; &#125;&#125; hashCode方法 先演示一下功能，发现运行后的结果很相似，发现hashCode的结果是16进制地址值的10进制数。 1234567891011public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); System.out.println(p1); System.out.println(p1.hashCode()); System.out.println(Integer.toHexString(p1.hashCode())); //Person@1540e19d //356573597 //1540e19d &#125;&#125; hashCode可以进行重写，在person类中加入如下的代码，ObjectDemo运行的结果会发生变化 123456public int hashCode()&#123; return age; &#125; //Person@14 //20 //14 getClass方法 字节码文件是经过编译器预处理过的一种文件，是JAVA的执行文件存在形式，它本身是二进制文件，但是不可以被系统直接执行，而是需要虚拟机解释执行，由于被预处理过，所以比一般的解释代码要快，但是仍然会比系统直接执行的慢 人中抽出Person，class抽取出Class（字节码文件类名）12345678910public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); Person p2 = new Person(40); Class claz1 = p1.getClass(); Class claz2 = p2.getClass(); System.out.println(claz1.equals(claz2)); //true &#125;&#125; toString方法 这是一个改写字符串方法 1234567public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); System.out.println(p1); System.out.println(p1.getClass().getName()+&quot;@&quot;+Integer.toHexString(p1.hashCode())); &#125;&#125; 运行结果：Person@1540e19d Person@1540e19d 其实这就是没改写前方法的功能，我们也可以自己进行改写 123public String toString()&#123; return &quot;Person:&quot;+age; &#125; 这样改写后输出 p1 的结果就是 Person:20]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类]]></title>
    <url>%2F2018%2F04%2F27%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类概述 内部类 如其名，就是类的内部定义的一个类 内部类访问特点 内部类可以直接访问外部类的成员 外部类要访问内部类，必须建立内部类的对象 一般用于类的设计 分析事物时，发现该事物描述中还有事物，而且这个事物还在访问被描述的事物，这时就把含有的事物定义成内部类来描述 修饰符 如何直接访问外部类中的内部类的成员1234567891011121314public class Outer &#123; private int num = 3; public class Inner &#123; void show()&#123; System.out.println(&quot;num = &quot;+num); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; Outer.Inner in = new Outer().new Inner(); in.show(); &#125;&#125; static 如果内部类是静态的，该如何访问内部类方法123456789101112131415161718192021public class Outer &#123; private int num = 3; public static class Inner &#123; void show()&#123; System.out.println(&quot;num = &quot;+num); &#125; //如果内部类中定义了静态成员，该内部类必须也是静态的 static void fun()&#123; System.out.println(&quot;fun&quot;); &#125; &#125; &#125; public class Test &#123; public static void main(String[] args)&#123; //如果内部类是静态的，相当于一个外部类 Outer.Inner in = new Outer.Inner(); in.show(); //如果内部类是静态的，成员是静态的 Outer.Inner.fun(); &#125; &#125; 细节 观察如下代码判断运行结果 123456789101112131415161718192021public class Outer &#123; private int num = 3; public class Inner &#123; int num = 4; public void show()&#123; int num = 5; System.out.println(num); System.out.println(this.num); System.out.println(Inner.this.num); System.out.println(Outer.this.num); &#125; &#125; public void method()&#123; new Inner().show(); &#125; &#125;public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125; &#125; 结果是：5 4 4 3 为什么内部类能直接访问外部类中成员那？ 那是因为内部类持有了外部类的引用。 外部类名.this 局部内部类 内部类可以存放在局部位置上 内部类在局部变量位置上只能访问局部中被final修饰的局部变量12345678910111213141516171819public class Outer &#123; private int num = 3; public void method()&#123; //如果不加final，会报错 final int x = 9; public class Inner &#123; public void show()&#123; System.out.println(x); &#125; &#125; Inner in = new Inner(); in.show(); &#125; &#125; public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125; &#125; 匿名内部类 匿名内部类，就是内部类的简写格式 前提：内部类必须继承或实现一个外部类或接口 匿名用户类：其实就是一个用户匿名子对象 格式：new 父类or接口 (){ 子类内容 通常使用场景之一： 当函数参数是接口类型时，而且接口中的方法不超过三个，可以用匿名内部类作为实际参数进行传递123456789101112131415161718192021222324interface inter&#123; public void show1(); public void show1();&#125;class Outer&#123; public void method()&#123; /*可以这么写 new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125;*/ //也可以这么写 inter in = new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125; /*居然还可以这么写 new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125;.show1(); */ &#125;&#125; 小细节静态问题 试试能不能编译如下代码 1234567891011public class InnerClassDemo &#123; class Inner&#123; &#125; public static void main(String[] args)&#123; new Inner(); &#125; public void method()&#123; new Inner(); &#125;&#125; ‘InnerClassDemo.this’ cannot be referenced from a static context 为什么 method 也写了同样的内容却没有报错？ 因为 main 是静态的，只能直接调用静态成员 转型问题 运行如下代码，将注释1取消注释，观察结果，再注释掉1，取消掉注释2，观察结果 123456789101112131415161718192021222324public class Outer &#123; public void method()&#123; /*注释1 new Object()&#123; public void show()&#123; System.out.println(&quot;i can run&quot;); &#125; &#125;.show(); */ /*注释2 Object obj = new Object()&#123; public void show()&#123; System.out.println(&quot;i can run&quot;); &#125; &#125;; obj.show(); */ &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125;&#125; 为什么第一次编译运行正确，第二次编译错误？ 因为匿名内部类这个子类对象被向上转型为 object 类型，这样就不能再使用子类特有的方法了]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多态]]></title>
    <url>%2F2018%2F04%2F27%2FJava%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[对象的多态性 以代码为示例 1234567891011121314151617public class Animals &#123; public void speak()&#123; System.out.println(&quot;i am animals&quot;); &#125;&#125;public class Cat extends Animals&#123; public void speak()&#123; System.out.println(&quot;i am cat&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; //一个对象，两种形态 Animals cat = new Cat(); cat.speak(); &#125;&#125; 运行后的结果为”i am cat” 猫这类事物既具备猫的形态，又具备动物形态，这就是对象的多样性，简单说，一个对象对应着多种类型 多态在代码中的体现 父类或者接口的引用指向了其子类的对象 多态的好处 提高了代码扩展性，前期定义的代码可以使用后期的内容。 123456789101112131415161718192021222324252627282930313233public abstract class Animals &#123; public abstract void eat();&#125;public class Cat extends Animals&#123; public void eat()&#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse()&#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125;public class Dog &#123; public void eat()&#123; System.out.println(&quot;啃骨头&quot;); &#125; public void guardDoor()&#123; System.out.println(&quot;看门&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; Cat c1 = new Cat(); Dog d1 = new Dog(); Dog d2 = new Dog(); method(c1); method(d1); method(d2); &#125; public static void method(Animals a)&#123; a.eat(); &#125;&#125; 如上图所示代码，如果很多只猫，很多只狗，为了代码复用性，需要在主类中定义一个方法，可是如果动物种类很多，是否要定义不同参数的许多方法那，答案是不用的，只需要定义个参数为Animals对象的即可 多态的局限性及前提 前期定义的内容，不能调用后期子类定义的特有内容 多态的前提 必须有关系，继承，实现 要有覆盖 多态转型 123456789101112131415//自动类型提升，猫对象提升了动物类型，但特有功能无法访问//作用就是限制对猫特有功能的访问//专业讲就是 向上转型，将子类型隐藏，就不用使用子类的特有方法Animals a = new Cat();a.eat();//如果还想访问具体动物的特有功能//可以进行向下转型Cat c = (Cat)a;//向下转型目的：为了使用子类中的特有方法c.eat();c.catchMouse();//错误示例Animals a1 = new Dog();Cat c1 = (Cat)a1; //ClassCastException类型转换异常 注意：对于转型来说，自始至终都是子类对象在做着类型的变化 类型判断 还是以之前的代码为示例，如果method方法内想进行输出猫，狗的特有功能该怎么做那？123456789101112public void method(Animals a)&#123; a.eat(); if(a instanceof Cat)&#123; //instanceof：用于判断对象的具体类型，只能用于引用数据类型判断 //通常在向下转型前用于健壮性的判断 Cat c = Cat(a); c.catchMouse(); &#125;else if(a instanceof dog)&#123; Dog d = Dog(a); d.guardDoor(); &#125;&#125; 多态时成员特点成员变量 编译时：参考引用型变量所属的类中是否有调用的成员变量，有则编译通过，没有则编译失败 运行时：参考引用型变量所属的类中是否有调用的成员变量，并运行该所属类中的成员变量 编译和运行都参考左边，如 animals a = new Cat(); 成员函数（非静态） 编译时：参考引用型变量所属的类中是否有调用的函数，有则编译通过，没有则编译失败 运行时：参考对象所属的类中是否有调用的函数， 简单说：编译看左边，运行看右边 1234567891011121314public class Father &#123; public void show()&#123; System.out.println(&quot;i am father&quot;); &#125;&#125;public class Son extends Father&#123; public void show() &#123; System.out.println(&quot;i am son&quot;); &#125;&#125;public class Test()&#123; Father f = new Son(); f.show();&#125; 运行后的结果 i am son 静态函数 编译时：参考引用型变量所属的类中是否有调用的静态方法，有则编译通过，没有则编译失败 运行时：参考对象所属的类中是否有调用的静态方法 简单说：编译和运行都看左边 其实对于静态方法，是不需要对象的，直接类名调用即可 1234567891011121314public class Father &#123; public static void show()&#123; System.out.println(&quot;i am father&quot;); &#125; &#125; public class Son extends Father&#123; public static void show() &#123; System.out.println(&quot;i am son&quot;); &#125; &#125; public class Test()&#123; Father f = new Son(); f.show(); &#125; 运行结果为 i am father]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承及接口]]></title>
    <url>%2F2018%2F04%2F21%2FJava%E7%BB%A7%E6%89%BF%E5%8F%8A%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[继承 什么时候继承？ 当类中存在所属关系时，就定义继承。狗和狼都是犬科，所以他们都可以继承犬科 所属关系：is a 关系 谁是谁中的一种 优点 提高代码复用性 让类与类之间产生了联系，为多态提供了前提 缺点 打破封装性 解决方法看下面的final关键字 注意 Java中支持单继承，不直接支持多继承，但对C++中多继承进行了改良 单继承：一个子类只能有一个父类 多继承：一个子类可以有多个父类（Java不直接支持，但是改良了） 因为如果多个父类中有相同成员，会产生调用的不确定性（Java中通过”多实现”的方式） Java支持多重继承 继承体系 C继承B，B继承A，就会出现继承体系 如何使用 创建该子类中的顶层类，了解该体系的基本使用功能 创建体系中的最子类对象，完成功能的使用 子父类中成员特点 子父类中，成员的特点体现 成员变量 成员函数 构造函数 成员变量 本类中成员和局部变量同名用this区分 子父类中的成员变量用super区分 this super 用法很相似 this 代表一个本类对象的引用 super 代表一个父类空间 子类不能直接访问父类中私有的内容 成员变量内存图解 以如下代码为例123456789101112131415public class Father&#123; int num = 4;&#125;public class extends Son&#123; int num = 5; void show()&#123; System.out.println(this.num+super.num); &#125;&#125;public class Demo&#123; public static void main(Sting[] args)&#123; Son s = new Son(); s.show(); &#125;&#125; 运行Demo类，main方法进栈，执行下一句话，创建一个子类对象，因为它是继承的父类，所以方法区需要先加载父类函数及构造方法，再加载子类构造方法。接下来在堆中开辟空间，给予地址，num值在父类子类中都有体现，所以存储时num值系统会通过关键字标注好。show方法入栈，this关键字指向son的num，super关键字指向father的num。 成员函数特点（覆盖） 当子父类中出现成员函数一模一样的情况，会运行子类的函数，这种现象就是覆盖操作，这是函数在子父类中的特性。 函数两个特性 重载：同一个类中 overload 覆盖：子类中，也成为重写，复写 override 注意事项： 子类方法覆盖父类方法时，子类权限必须大于等于父类权限才可以引发覆盖 静态只能覆盖静态，或被静态覆盖 什么时候使用覆盖操作？ 当对一个类进行子类的扩展时，子类需要保留父类的功能声明，但是要定义子类中该功能的特有内容时，就使用覆盖操作完成 成员函数特点应用 观察下面的代码，Phone类拥有两个方法，现在需要在他的基础上更改增加show方法的功能，就可以采用成员函数覆盖的方法 为什么不更改原代码的函数？为了安全起见，如果出错，那样很难复原。1234567891011121314151617181920212223public class Phone&#123; public void call()&#123;&#125; public void show()&#123; System.out.println(&quot;number&quot;); &#125;&#125;public class newPhone extends Phone&#123; public void call()&#123; super.call()； &#125; public void show()&#123; super.show(); System.out.println(&quot;name&quot;); System.out.println(&quot;picture&quot;); &#125;&#125;public class Demo&#123; public static void main()&#123; newPhone p = new newPhone(); p.call(); p.show(); &#125;&#125; 子父类中的构造函数子类的实例化过程 看下图代码，运行主函数后会是怎么样的结果 123456789101112131415public class Father &#123; Father()&#123; System.out.print(&quot;Father&quot;); &#125;&#125;public class Son extends Father &#123; public Son()&#123; System.out.print(&quot;Son&quot;); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; new Student(); &#125;&#125; 运行结果FatherSon，有Son我们理解，调用的是Son类，可是为什么有Father啊 特点 在子类构造对象时，发现访问子类构造参数时，父类也运行了，Why？ 在子类的构造函数第一行有一个默认的隐式语句。super(); 子类中所有的构造函数默认都会访问父类中的空参构造函数 细节 为什么子类实例化的时候，要访问父类中的构造函数那？ 那是因为子类继承了父类，获取到了父类中的内容（属性），所以在使用父类内容之前要先看父类是如何对自己的内容进行初始化的。所以子类在构造对象时，就必须访问父类中的构造函数。为了完成这个必须的动作，就在子类的构造函数中加入了super语句。如果父类中没有定义空参数构造函数，那么子类的构造函数必须用super明确要调用父类中的那个构造函数。 super语句必须要定义子类构造函数第一行。因为父类的初始化动作要先完成 如下面代码所示，子类构造函数中如果使用this调用了本类构造函数时，那么super没有了，因为super和this都只能定义在第一行，不过可以保证的是，子类中肯定会有其他构造函数访问父类的构造函数和数据 12345678910111213141516public class Father &#123; Father()&#123; System.out.print(&quot;F&quot;); &#125; &#125;public class Son extends Father &#123; Public Son()&#123; super(); System.out.print(&quot;Son1&quot;); &#125; public Son(int x)&#123; this(); //super(); System.out.print(&quot;Son2&quot;); &#125;&#125; 所有的类在创建时其实都是继承的object类,如下图的Demo类，注释掉的内容都是自动生成的隐式 123456789class Demo //extends object()&#123; /* Demo()&#123; super(); return; &#125; */&#125; 图解 以下面代码为示,123456789101112131415161718192021222324252627282930313233public class Father &#123; Father()&#123; //super(); show(); //return; &#125; public void show()&#123; System.out.println(&quot;Father show&quot;); &#125;&#125;public class Son extends Father&#123; int num = 8; public Son()&#123; super(); //-&gt;通过super初始化父类内容时，子类的成员变量并未显示初始化。 //等super()父类初始化结束后，才对子类成员变量初始化 return; &#125; public void show() &#123; System.out.println(&quot;Son show &quot;+num); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Son s = new Son(); s.show(); &#125;&#125;/*运行结果：Son show 0 Son show 8*/ 过程 一个对象的实例化过程 1、JVM会读取指定路径下的Person.class文件，并加载进内存，并会加载Person的父类（如果有直接父类的情况下） 2、在堆内存中开辟空间，分配地址 3、并在对象空间中，对对象中的属性进行默认初始化 4、调用相应的构造函数进行初始化 5、在构造函数中，第一行会先调用父类中构造函数进行初始化 6、父类在初始化完毕后，再对子类的属性进行显示初始化 7、再进行子类函数的构造初始化 8、初始化完毕后，将地址值赋给引用变量 final关键字 1、final是一个修饰符，可以修饰类，方法，变量 2、final修饰的类不可以被继承，该类为最终类 3、final修饰的方法不可以被覆盖 4、final修饰的变量是一个常量，只能赋值一次 为什么使用final修饰变量？ 其实在程序中如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差，所以应该给这个数据起个名称。而且这个变量名称的值不能变化，所以加上final固定 final应用 如下面的圆周率想定义后不被人修改，即可加上final修饰 注：被修饰后变量即是常量，表示方法为 “所有单词都大写，如果多个单词，中间用_连接” 注：final修饰的变量必须手动进行初始化，且前面一般加上static，方便调用123456class Circle&#123; static final double PI = 3.14; void method()&#123; System.out.println(PI); &#125; &#125; 抽象类 抽象：笼统，模糊，不具体 特点 1、方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰。抽象方法必须定义在抽象类中，该类也必须被abstract修饰 2、抽象类不可以被实例化，不可以被new 创建对象。因为调用抽象方法无意义 3、抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化，否则这个子类还是抽象类 细节 1、抽象类中有构造函数吗？ 有，用于给子类对象初始化 2、抽象类可以不定义抽象方法吗？ 可以，但是很少见，目的是不让该类创建对象。AWT的适配器对象就是这种类。通常这个类中的方法有方法体，但是没有内容 3、抽象关键字不可以和哪些关键字共存？ private 抽象方法需要被覆盖，加上私有不能覆盖 static 加上静态后可以用类调用方法，但是抽象方法运行无意义 final final修饰后不能被继承，抽象类或方法就没有用了 4、抽象类与一般类的异同点？ 抽象类和一般类都是用来描述事物的，都在内存定义了成员 一般类有足够信息描述事物，抽象类描述事物信息一般都不足 一般类中不能定义抽象方法，抽象类中可定义抽象方法或非抽象方法 一般类能被实例化，抽象类不可以被实例化 5、抽象类一定是父类吗？ 是的，因为需要子类覆盖其方法后，才可以对子类实例化 接口定义 当一个抽象类中的方法都是抽象类的时候，可以将该抽象类用另一种形式定义和表示，就是接口 interface。 定义接口使用的关键字不是class 是interface 接口当中常见的成员：（这些成员都有固定的修饰符，都是公共权限） 全局常量：public static final 抽象方法：public static 实现 类与类之间是继承方式，类与接口之间是实现方式 1234567891011121314151617181920public interface Demo&#123; public static final int NUM = 1; public static void show1(); public static void show2();&#125;public class DemoImpl implements Demo&#123; public void show1() &#123;&#125; public void show2() &#123;&#125;&#125;public class Test&#123; public static void main(String[] args)&#123; DemoImpl d = new DemoImpl(); //下面三行语句都正确 System.out.println(d.NUM); System.out.println(DemoImpl.NUM); System.out.println(Demo.NUM); &#125;&#125; 接口不可以实例化，只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化，否则，这个就是一个抽象类 多实现 Java中不直接支持多继承，因为会出现调用的不确定性，所以Java将多继承机制进行改良，在Java中变成了多实现 一个类支持多个接口 一个类在继承另一个类的同时，还可以实现多个接口 123456789101112131415161718public interface A&#123; public abstract void show1();&#125;public interface B&#123; public abstract void show2();&#125;public class Q&#123; public void method() &#123;&#125;&#125;//Test类继承Q类意味着他们属于一个体系//实现A,B接口是为了扩展功能class Test extends Q implements A,B&#123; public void show1() &#123;&#125; public void show2() &#123;&#125;&#125; 接口的出现避免了单继承的局限性，一个类 注意 接口与接口之间是继承关系，而且接口之间可以多继承 Java不能多继承的原因是因为方法体导致的运行不确定性，不过接口无方法体，所以接口可以多继承 接口类型的引用，都是指向自己类型子类的对象 特点 接口是对外暴露的规则 接口是程序的功能扩展 接口的出现降低耦合性 接口可以用来多实现 类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口 接口与接口之间可以有继承关系 接口抽象类区别 相同点：都是向上不断抽取而来 不同点： 抽象类： 抽象类需要被继承，且只能单继承 抽象类可以定义抽象方法和非抽象方法，子类继承后可以直接使用抽象方法 抽象类继承是 is a 关系，是在定义该体系的基本共性内容 接口： 接口需要被实现，可以多实现 接口只能定义抽象方法，必须由子类去实现 借口实现是 like a 关系，在定义体系的额外功能]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java单例模式]]></title>
    <url>%2F2018%2F04%2F21%2FJava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式 解决问题：可以保证一个类在对象中唯一性 必须对于多个实例使用同一个配置信息对象时，就需要保证该对象唯一性 如何保证对象唯一性？ 不允许其他程序使用new创建对象 在该类创建一个本地实例 对外提供一个方法让其他程序可以获取该对象 步骤： 私有化该类构造函数 通过new在本类中创建一个本类对象 定义一个公有的方法，将创建的对象返回 饿汉式 代码展示 12345678910111213141516//饿汉式public class Single &#123; //类加载进来时，对象就已经生成了 private static Single s = new Single(); private Single()&#123;&#125; public static Single getInstance()&#123; return s; &#125;&#125;public class Demo&#123; `public static void main(String[] args)&#123; Single s1 = Single.getInstance(); Single s2 = Single.getInstance(); System.out.println(s1 == s2); &#125;&#125; 工作中常常使用的一种单例模式，安全性好 懒汉式 代码展示 123456789101112// 懒汉式public class Single2 &#123; //类加载时没有对象生成，只有调用了getInstance方法后才会创建对象 //延迟加载程序 private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null) s = new Single2(); return s; &#125;&#125; 常见于面试中，涉及知识点较多 内存图示（饿汉式为例） main进栈，s1对象生成，方法区，single构造函数进入，静态区，single s getInstance进入，堆中开辟一块空间，赋予0x0045地址，静态区中s指向堆中地址。get方法进栈，s1地址指向0x0045，get出栈。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编写工具类及API文档]]></title>
    <url>%2F2018%2F04%2F18%2FJava%E7%BC%96%E5%86%99%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%8F%8AAPI%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[昨天学习了如何编写一个工具类，及如何给他注释再去生成专属于他的API文档。今天我将这个过程以及一些遇到的报错解决整理到博客中。 编写Java工具类（以数组工具类为例） 工具类中包含了一些简单的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** *这是一个可以对数组进行操作的工具类，该类中提供了如最值获取，排序等功能。 * @author Orange * @version 1.0 */ public class ArrayTool &#123; // private ArrayTool()&#123;&#125; /** *获取一个整型数组中的最大值 * @param arr 接收一个 int 类型的数组 * @return 会返回一个该数组中最大值 */ public static int getMax(int[] arr)&#123; selectSort(arr); int max = arr[0]; for(int i=0 ;i&lt;arr.length; i++)&#123; if(arr[i]&gt;max) max = arr[i]; &#125; return max; &#125; /** * 给int数组进行选择排序。 * @param arr 接收一个 int 类型的数组 */ public static void selectSort(int[] arr)&#123; for(int i=0 ;i&lt;arr.length-1; i++)&#123; int number = arr[i]; int index = i; for(int j=i+1;j&lt;arr.length;j++)&#123; if(number&gt;arr[j])&#123; number = arr[j]; index = j; &#125; &#125; if(index != i) swap(arr,i,index); &#125; &#125; //因为 swap 方法是 priavte ，所以只写普通注释就可以了 //给数组中元素进行位置的置换 private static void swap(int[] arr,int a,int b)&#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; /** * 将 int 形式的数组转换成字符串形式。打印形式是[s1,s2,s3,.....] * @param arr 接收一个 int 类型的数组 * @return 返回该 int 数组的字符串表现形式 */ public static String ArrayToString(int[] arr)&#123; String str = &quot;[&quot;; int point = 0; for(int i=0 ;i&lt;arr.length ;i++)&#123; if(i != arr.length-1) str = str + arr[i] + &quot;,&quot;; else str = str + arr[i] + &quot;]&quot;; &#125; return str; &#125; &#125; 注释的添加 Java文档注释|菜鸟教程 javadoc工具软件 javadoc 语法 javadoc [ options ] [ packagenames ] [ sourcefiles ] [ @files ] DOS界面使用javadoc编写API WIN-R 运行 cmd 进入 DOS 界面 通过使用CMD的命令进入包含该java工具类的文件夹 输入：javadoc -d myhelp -author -version ArrayTool.java 效果展示 报错编码GBK的不可映射字符 解决方法 关闭编译器要编写的那个工具类 用记事本打开 Java 源文件 另存为，选择 ANSI 编码 覆盖后，在DOS界面重试 成功后，将编码改回原格式 错误2 生成错误原因：改为ANSI编码后，打开了编译器，汉字都变成了乱码 切记，记事本改完编码后，不要。立即用编辑器打开该文件]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java构造函数及关键字]]></title>
    <url>%2F2018%2F04%2F15%2FJava%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[构造函数 简单说，构造函数就是构建创造对象时调用的函数 创建对象都必须要通过构造函数初始化，一个类如果没有定义过构造过程，会有一个默认空参构造函数。若定义了指定的构造函数，那么类中默认构造函数就会消失。 特点 函数名与类类名相同 不能返回值类型 没有具体返回值 区别 构造函数 对象创建时，会掉用与之相应的构造函数，对对象进行初始化 对象创建时，会调用且仅调用一次 一般函数 对象创建后，需要使用函数功能时才调用 对象创建后，可调用多次 重载 当一个类中出现多个构造函数时，必须以重载形式体现 内存图解 接下来用下面这段代码，来演示内存变化过程12345678910111213141516public class Person &#123; private String name; private int age; Person()&#123;&#125;; Person(String name,int age)&#123; this.name = name; this.age = age; &#125; public void speak()&#123; System.out.println(name+&quot;:&quot;+age); &#125; public static void main(String[] args)&#123; Person person = new Person(&quot;jack&quot;,20); person.speak(); &#125;&#125; 左面是栈内存，右面是堆内存。首先在栈内存运行main函数，创建名字为p的对象，然后栈内存调用了有参构造函数。在堆内存中开辟一片区域，给予其地址，将构造函数中的值寻址赋给堆中变量的值，然后将构造函数弹栈。将堆内存中的地址赋给p。 然后在栈中入栈speak方法，运行后寻址输出变量值this关键字 当成员变量和局部变量重名，可用关键字this区分 this代表对象，一般当前对象，this代表其所在函数所属对象的引用12345678class Person &#123; Person(String name)&#123; this.name = name; &#125; public static void main()&#123; Person p = new Person(name); &#125;&#125; 功能 this也可用于在构造函数中调用其他构造函数 注：只能定义在构造函数第一行，因为初始化动作要先执行 12345678910class Person &#123; Person()&#123;&#125; Person(String name)&#123; this.name = name; &#125; Person(String name,int age) &#123; this(name); this.age = age; &#125;&#125; 当执行主函数中的语句时，调用有参构造函数，此时this.name就是代指对象p 简单来说，哪个对象调用this所在的函数，this就代表哪个对象注意事项 运行下面的代码失败，死循环12345678910111213class Person &#123; Person()&#123; this(jack); &#125; Person(String name)&#123; this(); this.name = name; &#125; Person(String name,int age) &#123; this(name); this.age = age; &#125;&#125; 内存图解 接下来通过下面的代码来演示更加完整的过程12345678910111213141516171819public class Person &#123; private String name; private int age; Person(String name)&#123; this.name = name; &#125; public void speak()&#123; System.out.println(name+&quot;:&quot;+age); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Person p = new Person(&quot;rose&quot;); p.speak(); Person p1 = new Person(&quot;dell&quot;); p1.speak(); &#125;&#125; 首先在栈内存运行main函数，创建名字为p的对象，然后栈内存调用了有参构造函数。在堆内存中开辟一片区域，给予其地址后初始化数值，构造函数中的this起到了作用，指向p对象的地址，将 name=”jack” 传到堆中更改值，然后将构造函数弹栈。将堆内存中的地址赋给p。speak函数入栈也是通过this寻址堆中赋值。 小练习（双人年龄比较） 思路：在Person类中写一个boolean类型方法，巧妙地利用this就可以compare方法中只带一个参数。 123public boolean compare(Person p)&#123; return this.age == p.age ; &#125; 主类中如何使用？ 123Person p1 = new Person();Person p2 = new Person();p1.compare(p2); static关键字特点 static是一个修饰符，用来修饰成员 static修饰成员被所有对象共享 static优先于对象存在（static随类的加载就已经存在了） static修饰的成员多了一种调用格式，可以直接被类名调用。如：类名.静态成员 static修饰的是共享数据 对象中存储的是特有数据成员变量、静态变量区别 区别： 生命周期不同 调用方式不同 别名不同 数据存储位置不同 成员变量： 随对象创建存在，随其回收而释放 只能被对象调用 实例变量 存在堆内存的对象中，也叫对象的特有数据 静态变量： 随着类加载而存在，随着类消失而消失 可以对象调用，也可以类调用 类变量 存放在方法区（也叫共享数据区）的静态区中，也叫对象的共享数据 静态使用注意 静态方法只能调用静态成员（非静态都可以访问） 静态方法不可使用this 或者 super关键字 主函数静态的 内存图解 内存划分 寄存器 本地方法区 方法区 栈内存 堆内存 接下来用一段代码来演示内存变化过程123456789101112131415161718192021222324public class Person &#123; private String name; private int age; static String country = &quot;CN&quot;; Person()&#123;&#125;; Person(String name,int age)&#123; this.name = name; this.age = age ; &#125; public void show()&#123; System.out.println(Person.country+&quot;:&quot;+this.name+&quot;:&quot;+this.age); &#125; public static void method()&#123; System.out.println(Person.country); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Person.method(); Person p = new Person(&quot;jack&quot;,20); p.show(); &#125;&#125; 运行程序的时候，读取StaticDemo类，在方法区存放他的名字，注意还有他的自带的构造函数，然后在他的静态区粘贴上类的名字和代码，栈内存中压栈main，根据上面代码需要调用Person类，将Person类的构造函数show方法粘在方法区，在静态区添加入静态变量和静态方法。栈内存中压栈method，弹栈。继续执行主函数的语句，创建对象在堆内存开辟空间，压栈Person的构造函数，用this指向堆中的地址，赋值给堆内存。Person构造函数弹栈，将堆中地址赋值给p对象，show方法压栈，this指向堆中的地址，弹栈 静态什么时候用静态变量 当分析对象中所具备的成员变量的值都是相同的，这是这个成员就可以被静态修饰。只要数据在对象中都不同的，就是对象的特有数据，必须存在对象中。非静态的若是有相同数据，且对象不需做修改只需要使用，，那么就不需要存储在对象中，定义成静态的就可以了 静态函数 参考一点，该函数功能是否有访问到对象中的特有数据 简单来说，从源代码看该函数功能是否需要访问非静态的成员变量，如果需要，该方法就是非静态的，如果不需要，该方法就可以定义成静态的 非静态需要被对象调用，而仅创建调用非静态但没有访问特有数据的方法，那么该对象的创建是没有意义的。 静态代码块 随类的加载而执行，且只执行一次 作用：给类初始化 构造代码块：给所有对象初始化 构造函数：给对应对象针对性初始化 执行顺序，谁先执行 有对象：静态代码块 &gt; 构造代码块 &gt; 构造函数 无对象：静态代码块 &gt; 构造函数 &gt; 构造代码块 主函数特殊处 格式固定 被JVM所识别，所调用 分析： public 权限最大 static 不需要对象，直接用主函数所属类名调用 void 没有具体返回值 main 不是关键字，只是被JVM所识别固定的名字 String[] args 主函数参数列表，一个数组类型参数，元素都是字符串 接下来我们输出代码测试一下 1234public static void main(String[] args)&#123; System.out.println(args); System.out.println(args.length);&#125; 结果：[Ljava.lang.String;@1540e19d 0]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象总结]]></title>
    <url>%2F2018%2F04%2F12%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[面向对象面向对象的特点 1.符合人们的思想习惯 2.将复杂事情简单化 3.让曾经在过程中的执行者变成指挥者举例 比如说，公司中刚刚接取了一个项目，如果这个事情全部都交给老总做的话，可能会耗时很久很久，所以他就需要去找别人来帮他做。需要去面试选人，也就是寻找几个对象替他去完成工作。这就是面向对象的一种体现。 哪个对象对动作最清楚，定义在哪里成员变量、局部变量的区别 成员变量 成员变量定义在类中，整个类都可以访问 成员变量存在于堆内存的对象中 成员变量随着对象创建而生，随对象消失而亡 成员变量都有默认初始值 局部变量 局部变量定义在函数、语句、局部代码块中，只在所属区域有效 局部变量存在于栈内存的方法中 局部变量随着所属区域的执行而存在，随着所属区域结束而释放 局部变量没有默认初始值（使用前必须进行初始化）匿名对象 1.当对象对方法仅进行一次调用的时候，就可以简化成匿名对象 2.匿名对象可以作为实际参数进行传递对象的内存体现 以下面这段代码为例 123456Car c1 = new Car();Car c2 = new Car();c1.num = 4;c1.color = red;c2.num = 5;c2.color = blue; 栈中运行主函数，创建c1对象，在堆中开辟一个新的区域，将他的地址值传回栈中，他的num初始值为0，color初始值为null 下面这段代码和上面又有什么不同那1234Car c1 = new Car();Car c2 = c1；c1.num = 4;c2.color = blue; 这里将c1赋值给c2，就是将c1地址给c2，所以c2.color = blue，通过寻址找到并更改的color值就是c1地址下的匿名对象 以下面代码，作图演示123new Car().num = 4;new Car().color = red;new Car().show(); 基本数据类型参数传递12345678910class demo&#123; public static void main(String[] args)&#123; int x; show(x); System.out.println(&quot;x=&quot;+x); &#125; public static void show(int x)&#123; x = 4; &#125;&#125; 引用数据类型参数传递123456789101112class demo&#123; int x; public static void main(String[] args)&#123; demo d = new demo(); d.x = 9; show(d); System.out.println(d.x); &#125; public static void show(demo d)&#123; d.x = 4; &#125;&#125; 封装 好处： 将变化隔离 便于使用 提高重用性 提高安全性 封装原则 将不需要对外提供的原则都隐藏起来 把属性都隐藏，提供公共方法对其访问 封装思想 封装：指隐藏对象的属性和实现细节，仅对外提供公共访问方式 private权限修饰符 私有仅仅是封装的一种体现而已，封装不仅仅有私有一种方式]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2F2018%2F04%2F10%2FJava-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E6%9F%A5%E8%A1%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天写一下二进制转换十六进制的程序,改良程序的过程进制转换（以10转16为例） 首先想一下十六进制是多少个二进制位，4个。那么int是多少个字节？多少个二进制位？4个字节，32个二进制位 123456789public void toHex(int num)&#123; int temp; for (int i = 0;i&lt;8 ;i++) &#123; temp = num &amp; 15; System.out.print(temp+&quot; &quot;); num = num &gt;&gt;&gt; 4; &#125; &#125; 上图的结果是12 3 0 0 0 0 0 0，先来讲讲原理，再改良 1234567891011 以 num = 60 为例 0000-0000 0000-0000 0000-0000 0011-1100&amp; 0000-0000 0000-0000 0000-0000 0000-1111------------------------------------------ 0000-0000 0000-0000 0000-0000 0000-1100 0000 0000-0000 0000-0000 0000-0000 0011 ( 1100 ）&amp; 0000-0000 0000-0000 0000-0000 0000-1111------------------------------------------ 0000-0000 0000-0000 0000-0000 0000-0011 结果分别是12 3 0 0 0 0 0 0 先和15（4个低位都是1，其余是0）进行&amp;运算，得到值后，再进行&gt;&gt;&gt;3的运算。这样得到的结果还有12的存在，应该是英文字母的，继续改进 1234567891011public void toHex2(int num)&#123; int temp; for (int i = 0;i&lt;8 ;i++) &#123; temp = num &amp; 15; if (temp&gt;=10) System.out.print((char)(temp-10+&apos;A&apos;)+&quot; &quot;); else System.out.print(temp+&quot; &quot;); num = num &gt;&gt;&gt; 4; &#125; &#125; 在中间的地方加了一个判断，使用了ASCII的知识，temp-10+’A’ 得到的不是字母，所以在前面还要加上char的强制转换 继续改进，现在这些数还是倒序，而且有许多无用位。 1234567891011121314public void toHex3(int num)&#123; char[] chars = new char[]&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;, &apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;; char[] arr = new char[8]; int point = arr.length - 1 ; int temp; while (num!=0)&#123; temp = num &amp; 15; arr[point] = chars[temp]; num = num &gt;&gt;&gt; 4; point --; &#125; System.out.print(arr); &#125; 这里使用了数组的查表法，创建两个char的数组，第一个数组是用来将所获取到的0到15的数字转换为十六进制中的字符，第二个数组用来存储最后16进制的结果 在之前的两个程序中，最后输出的值都是反向的，于是我在这里创建了一个指针point，让他的初始值指向数组最后端的角标，每次输入进一个数后，指针前移一位，这样最后输出的时候直接输出数组就可以输出一个转换正确的16进制值。 进制转换整合 上面的的程序还只能对10-&gt;16转换，可以对其略作修改，使其可以灵活转换各种进制 1234567891011121314public char[] trans(int num,int base,int offse)&#123; char[] chars = new char[]&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;, &apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;; char[] arr = new char[32]; int point = arr.length - 1 ; int temp; while (num!=0)&#123; temp = num &amp; base; arr[point] = chars[temp]; num = num &gt;&gt;&gt; offse; point --; &#125; return arr; &#125; 添加单独方法 1234567891011public char[] toBinary(int num)&#123; //十进制转换二进制 return trans(num,1,1);&#125;public char[] toHexa(int num)&#123; //十进制转换十六进制 return trans(num,15,4);&#125;public char[] toOctal(int num)&#123; //十进制转换八进制 return trans(num,7,3);&#125; 主类测试 12345678910public class tranSystem &#123; public static void main(String[] args)&#123; int num = 854796; tranSystem tra = new tranSystem(); System.out.println(tra.toHexa(num)); System.out.println(tra.toOctal(num)); System.out.println(tra.toBinary(num)); &#125; //上面写的方法添加在这里&#125; Integer.toBinaryString()是java系统自带的转换二进制 查表法 查表法在日常学习中可以有很多应用，如输入数字，输出星期几等等]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 数组常见操作]]></title>
    <url>%2F2018%2F04%2F09%2FJava-%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[今天整理了一些常用的数组操作，如最大值，查找，排序等等 数组最大值值判断12345678public int maxValue(int[] a)&#123; int max = a[0]; for(int i=0;i&lt;a.length;i++)&#123; if(a[i]&gt;max) max = a[i]; &#125; return max; &#125; 下标判断12345678public int maxIndex(int[] a)&#123; int max = 0; for(int i=0; i&lt;a.length;i++)&#123; if(a[i]&gt;a[max]) max = i; &#125; return a[max]; &#125; 数组操作辅助方法交换值123456public void swap(int[] arr,int a,int b)&#123; int temp = 0; temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; 输出链表12345public void printList(int[] arr)&#123; for(int i = 0;i&lt;arr.length;i++) System.out.print(arr[i]+&quot; &quot;); System.out.println(); &#125; 数组选择排序12345678910111213public void chooseSort(int[] arr)&#123; //选择排序 int temp = 0; for(int i=0;i&lt;arr.length-1;i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if(arr[j]&gt;arr[i])&#123; //swap(arr,i,j); temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; 选择排序改进版 改进版的选择排序，设置了角标值和数组值1234567891011121314public void chooseSort2(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++) &#123; int number = arr[i]; int index = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (number &gt; arr[j]) &#123; number = arr[j]; index = j; &#125; &#125; if (index!=i) swap(arr,i,index); &#125; &#125; 数组冒泡排序 冒泡排序，五个数为例，共进行4+3+2+1 10次比较123456789101112public void ppSort(int[] arr)&#123; //便于理解 int temp = 0; for(int i = 0;i&lt;arr.length-1;i++) for (int j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; //swap(arr,j,j+1); temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] =temp; &#125; &#125; &#125; 冒泡排序改进版123456789101112public void ppsort2(int[] arr)&#123; //改进版冒泡 int temp = 0; for (int i = arr.length-1;i&gt;0;i--) for(int j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; //swap(arr,j,j+1); temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] =temp; &#125; &#125; &#125; 查找通过值查找12345678public int findByValue(int[] arr,int key)&#123; //通过值查找 int index = -1; for (int i = 0;i&lt;arr.length;i++)&#123; if(key == arr[i]) index = i + 1; &#125; return index; &#125; 二分查找1234567891011121314151617public int findHalf(int[] arr,int key)&#123; //二分查找 list list = new list(); list.chooseSort2(arr); int max = arr.length-1; int min = 0; int mid ; while(min&lt;=max)&#123; mid = (max + min)&gt;&gt;1; if(key&gt;arr[mid]) min = mid + 1; else if(key&lt;arr[mid]) max = mid - 1; else return mid; &#125; return -1; &#125; 练习题 给定一个有序的数组，如果往该数组中存储一个元素，并保证这个数组还是有序的，那么这个元素的存储的角标该如何获取？ 1234567891011121314151617public int getJiaoBiao(int[] arr,int key)&#123; / list list = new list(); list.chooseSort2(arr); int min =0; int max =arr.length-1; int mid; while(min&lt;=max)&#123; mid = (min+max)&gt;&gt;1; if(key&gt;arr[mid]) min = mid + 1; else if (key&lt;arr[mid]) max = mid - 1; else return mid; &#125; return min; &#125; 在系统自带的Arrays类中，有这个方法，不过和我这个写的不一样，比我的更好一些，我把源码粘贴上来 123456789101112131415161718private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) &#123; int low = fromIndex; int high = toIndex - 1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;&gt; 1; int midVal = a[mid]; if (midVal &lt; key) low = mid + 1; else if (midVal &gt; key) high = mid - 1; else return mid; // key found &#125; return -(low + 1); // key not found. &#125; 不同的是返回值 比如我的答案如果是6，那么他的答案就会是-7，为什么那？ 因为要插入的这个数是不存在于数组中的，所以给他一个负数的位置，那么-7怎么来的？-6-1，因为还有1个值，就是用我的方法得到0的那个值，取了负数还是0，不好分辨，所以就整体取负后再减一 总结说：存在，返回具体的角标位置，不存在的话 返回 -插入点-1]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数组及内存图解]]></title>
    <url>%2F2018%2F04%2F08%2FJava%E5%87%BD%E6%95%B0%E5%8F%8A%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天整理了Java函数，数组，内存加载使用的问题，在这之前我先把昨天剩下的for语句写下来。 for语句 Java for语句基础 \n 回车\t 制表符\b 退格\r 按下回车键 windows系统中回车符其实是由两个符号组成 \r \nlinux 回车符只是 \n 1System.out.println(&quot;\&quot;hello world\&quot;&quot;); 上段代码最后输出结果是 “hello world” 有引号的，\会将他下一个字符转义 break 跳出 作用范围：swich语句 or 循环语句 当break语句单独存在时，下面不要定义其他语句，因为执行不到 123456A:for(int x=0; x&lt;3; x++)&#123; B:for(int y=0; y&lt;6; y++)&#123; System.out.println(x); break A; &#125;&#125; 大家观察一下上面的语句，这就是break的特殊用法，可以将for循环定义名字，break选择性的使用。 continue 继续 作用范围：循环结构 结束本次循环，继续下次循环 continue语句单独存在时，下面不要定义其他语句，因为执行不到 12345for(int x=0; x&lt;9; x++)&#123; if(x%2 == 0) continue; System.out.println(x);&#125; 函数 函数：定义在类中具有特定功能的一段小程序，也称方法。 定义及格式 定义函数格式： 1234修饰符 返回值类型 函数（参数类型 形参1, ... ... ,）&#123; 执行语句; return 返回值;&#125; 无具体返回值时，返回值类型用void，return可以忽略不写 功能 1 定义函数可将代码封装 2 便于对该功能复用 3 函数只有被调用才能执行 两个明确 1 函数功能结果是什么？ 2 实现过程中是否需要未知内容参与运算？ 函数重载 1 同一个类中的同名函数 2 参数个数不同或者是参数类型不同 3 函数重载与返回值无关 4 Java严谨性语言，如果函数出现调用不确定性，会编译失败（比如int返回值却是double参数类型） 数组 Java数组基础 内存 内存的划分 寄存器 本地方法区 方法区 栈内存 堆内存 栈内存 存储的都是局部变量，变量所属作用域一旦结束，该变量就自动释放 堆内存 储存数组和对象（数组就是对象），new 建立的都在堆上 特点： 每个实体都有首地址值 堆内存中每个变量都有默认内存初始值，根据类型不同而不同（int -&gt; 0,double -&gt; 0.0,float -&gt; 0.0f,boolean -&gt; false,char -&gt; ‘\u0000’） 垃圾回收机制 数组运行内存图解一维数组 接下来我就通过这段代码来演示运行时的内存变化 1234567int[] x = new int[3];int[] y = new int[3];x[0] = 9;y[0] = 34;x = y;System.out.println(x[0]);y = null; 栈中运行main然后存入x数组名，堆中分配地址（16进制），找到这个地址，开辟数组大小的空间，并给予其初始值。然后将数组地址传回栈中。 给x[0],y[0]赋值时，就是直接在堆内存中更改数据 x=y 语句的执行实质上就是将y的地址赋给x，下次再调用x的时候，即直接找到y的地址 当y = null; 就是将堆内存 和栈内存的指向关系删去， 12int[] x = new int[3];System.out.println(x[]); 如果直接运行上段代码，所得到的结果是一串字符 [I@1540e19d （我运行后的值） [: 代表数组I：int 实体类型1540e19d：16进制的哈希值（地址） 二维数组 直接来是二维数组的图解123int[][] arr = new int[3][2];arr[1][1] = 89;arr[2][2] = 89; //error 大家看下图，以上图为例，所谓二维数组就是栈内存中存下指向堆内存的地址，这个地址是大小为3的数组，初始值为空，然后再创建3个小的数组，每个小数组还有一个地址，将这些地址对应存到之前大小为3的数组中。 1234int[][] arr = new int[3][2];System.out.println(arr);System.out.println(arr[0]);System.out.println(arr[0][0]); 输出的结果 123[[I@1540e19d[I@677327b60 再来看看另一种定义下的情况 1234int[][] arr = new int[3][];System.out.println(arr);System.out.println(arr[0]);System.out.println(arr[0][0]); 结果如下 123[[I@1540e19dnullException in thread &quot;main&quot; java.lang.NullPointerException]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运算符基础]]></title>
    <url>%2F2018%2F04%2F07%2FJava%E8%BF%90%E7%AE%97%E7%AC%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[今天重温的主要是Java运算符，在这里我把之前已经遗忘的一些点记录下来，以后回顾的时候可以翻阅。 比较运算符^异或： 符号两边的结果相同为False，不同则为True1234True ^ True = False ;False ^ True = True ;True ^ False = True ;False ^ False = False ; ！非： 两次非运算就是原数12!true = false ;!!true = true ; 逻辑运算符&amp;和&amp;&amp;的区别： 让我们先来看一段代码 123int x = 1;if(x&gt;2 &amp;&amp; x&lt;5) System.out.println(); 在上面的情况中，在对 &amp;&amp; 左边的式子进行判断后，得出左边的式子值是false，因为两数相与，只要有一个flase，整体式子的结果就是false。所以停止运算右侧式子，直接给出false的结果。 但是使用 &amp; 运算符的时候，无论左边式子是什么，右边都参与运算。 &amp;&amp; 和 &amp; 运算结果一样，过程有一些小区别&amp; ：无论左边式子是什么，右边都参与运算&amp;&amp; ：当式子左边为false时，右边不参与运算，结果为false |和||的区别 上面我们说了 &amp; 和 &amp;&amp; 的区别，其实原理是一样的 || 和 | 运算结果一样，过程有一些小区别| ：无论左边式子是什么，右边都参与运算|| ：当式子左边为true时，右边不参与运算，结果为true 位运算&amp; 位运算 下面我用一个小例子来演示 12345676 &amp; 3 = ?内存中 0000-0000 0000-0000 0000-0000 0000-0110&amp; 0000-0000 0000-0000 0000-0000 0000-0011----------------------------------------- 0000-0000 0000-0000 0000-0000 0000-0010∴ 6 &amp; 3 = 2 6 &amp; 3 在内存中变化的实质是，转换为2进制，各位相对应的进行 &amp; 运算 应用场景： 取0100 0000 1100 0101的后四位，如何进行操作？ 答 ：用0000 0000 0000 1111与其进行 &amp; 运算。 | 位运算 原理同上 例如 6 | 3 = 7 ^ 位运算 原理同上 1234567891011126 ^ 3 = ?内存中(简化) 0110 ^ 0011 ------ 0101∴ 6 ^ 3 = 5继续 ^ 35 ^ 3 = ?演算后 5 ^ 3 = 6 不知道大家发没发现这个运算的一些小秘密，那就是一个数连续两次与相同的数进行异或运算后，结果会是最初的数。用公式写就是： a ^ b ^ b = a 那么这个究竟可以用作干什么那？可以用于文件的加密！ ~ 反码 大家可以在自己的电脑上试一下下面的代码，看看是不是自己猜测的值 12int a = 2;System.out.println(~a); 结果是 -3 ，很多人可能都以为反码的意思就是将a的二进制10取反为01，猜测结果是1 为什么不是这样的运算过程那？ 原理这就要从计算机常用的几个码说起了。首先，java存储的是有符号数，在计算机中，有符号数通常是使用补码存储的，java也不例外。先来看看什么叫原码，反码，补码。 原码原码就是符号位加上真值的绝对值,即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:1[+1]原 = 0000 0001 反码正数的反码是其本身负数的反码是在其原码的基础上,符号位不变，其余各个位取反.例如：1[+1] = [00000001]原 = [00000001]反 补码正数的补码就是其本身负数的补码是在反码的基础上+1。例如:1[+1] = [00000001]原 = [00000001]反 = [00000001]补 分析所以回到一开始的问题，int a = 2 a在计算机中是以补码存储的。 对于2这个正数来说，补码、反码、原码都是相同的，又由于是数值型，在这里我先用八位bit来表示一下：12原码:0000 0010反码:0000 0010 补码:0000 0010 取反取反过程是在补码的基础上进行的，由于是按位取反，无论符号位还是数值位都要取反，所以结果如下: 1取反后的补码: 1111 1101 换算为值那么取反后的补码的实际值是多少呢？我们需要先把他转化为原码，过程如下: 1反码 = 1111 1101 - 1 = 1111 1100 原码 = 反码符号位不变，其余取反 = 1000 0011 所以，最后的值-3 &lt;&lt; 左移 这个符号之前并没有听说过，在这次学习中进行了掌握（开始我还以为是C++的cout那） 1234563 &lt;&lt; 2 = ?内存中0000-0000 0000-0000 0000-0000 0000-0011结果0000-0000 0000-0000 0000-0000 0000-1100∴ 3 &lt;&lt; 2 = 12 上面的运算实质是 3的2进制 整题左移两位，多余的舍弃，空位用0补 一个数进行左移运算时，左移n位，即是该数乘以2的n次幂 &gt;&gt; 右移 原理几乎一样，只有略微的不同原来最高位是什么，用什么补空位（因为最高位为1时是负数） 右移n位，即是该数除以2的n次幂1234-12 &gt;&gt; 2 = ?答： -3 12 &gt;&gt; 2 = ?答： 3 &gt;&gt;&gt; 无符号右移 高位空位，全部填0，用0补位1234-12 &gt;&gt;&gt; 2 = ?答： 3 12 &gt;&gt;&gt; 2 = ?答： 3 应用 请用效率最高的方法求出 2*8 的值。 1System.out.println(2&lt;&lt;3); 两个整数值互换（不使用第三方变量） 1234567891011方法1：（不建议使用，如果数值过大，可能丢失精度）int a = 3, b = 5;a = a + b;b = a - b;a = a - b方法2：（利用异或位运算）int a = 3, b = 5;a = a ^ b;b = a ^ b;a = a ^ b; 三元运算符 （条件表达式）？表达式1：表达式2 若条件为true ，结果为表达式1若条件为false，结果为表达式21234练习：在x , y中取 值较大的整数int x = 3, y = 4;int max = ( x&gt;y )? x : y;System.out.println(max); swich 和 if else 与 三元运算符 三元运算符必须有结果，if else可有，可不有结果。当if else有具体运算结果时，可以使用三元运算符。 1234567891011121314151617swich使用示范： int x = 3; swich(x) &#123; case 1: System.out.println(x); break; case 2: System.out.println(x); break; case 3: System.out.println(x); break; case default: System.out.println(x); break; &#125; if： 对几个具体值进行判断 对区间判断 对运算结果boolean类型表达式判断 swich： 对几个具体值进行判断 值的个数通常是固定的 对几个固定值判断，建议使用swich，swich将答案存在内存中，效率高]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 链表实现]]></title>
    <url>%2F2018%2F04%2F06%2FJava-%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[分享一下我用java实现的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public class LinkList&lt;T&gt; &#123; private Node&lt;T&gt; head; //头节点 private Node&lt;T&gt; tail; //尾节点 /** * 构造空链表 */ public LinkList()&#123; head = tail = null; &#125; /** * 链表内部的节点类 */ private static class Node&lt;T&gt;&#123; T data; //节点的数据 Node&lt;T&gt; next; //该节点指向下一个节点的指针 Node(T data)&#123; this.data = data; this.next = null; &#125; &#125; /** * 为空链表增加头节点 */ public void addHead(T point)&#123; this.head = new Node&lt;T&gt;(point); if(tail == null)&#123; tail = head; &#125; &#125; /** * 为链表增加尾节点 */ public void addTail(T point)&#123; tail = new Node&lt;T&gt;(point); head.next = tail; &#125; /** * 插入节点（头插法） */ public void addNode(T point)&#123; if(this.head==null) //添加头节点 addHead(point); else if(this.tail==this.head) //在头节点后添加尾节点 addTail(point); else&#123; Node&lt;T&gt; newNode = new Node&lt;T&gt;(point); newNode.next = head.next; head.next = newNode; &#125; &#125; /** * 删除节点（通过数据值） */ public void deleteNode(T data)&#123; Node&lt;T&gt; curr = head ,pre = null; boolean flag = false; //判断要删除的节点是否存在 while(curr != null)&#123; if(curr.data.equals(data))&#123; if (curr==head)&#123; //删除头节点 System.out.println(&quot;delete the head Node&quot;); head = curr.next; flag = true; &#125;else if (curr==tail)&#123; //删除尾节点 System.out.println(&quot;delete the tail Node&quot;); tail = pre; pre.next = null; flag = true; &#125;else &#123; //删除中间节点 System.out.println(&quot;delete the center Node&quot;); pre.next = curr.next; flag = true; &#125; &#125; pre = curr; curr = curr.next; &#125; if (flag == false) System.out.println(&quot;链表中不存在该数据&quot;); &#125; /** * 查找链表中的元素（通过位置） */ public void findKth(T point)&#123; Node&lt;T&gt; curr = head , pre = null; int k = 1; boolean flag = false; while (curr != null)&#123; if(point.equals(k))&#123; System.out.println(&quot;第&quot;+k+&quot;位的值是&quot;+curr.data); flag = true; &#125; pre = curr; curr = curr.next; k++; &#125; if(flag==false) System.out.println(&quot;查找的位置在链表中不存在&quot;); &#125; /** * 查找链表中的元素（通过值） */ public void findByValue(T data)&#123; Node&lt;T&gt; curr = head ; int k = 1; boolean flag = false; while(curr!=null)&#123; if(curr.data==data)&#123; System.out.println(&quot;查找的值在链表中的第&quot;+k+&quot;位&quot;); flag = true; &#125; curr = curr.next; k++; &#125; if(flag==false) System.out.println(&quot;查找的值在链表中不存在&quot;); &#125; /** * 输出链表 */ public void printlnLink()&#123; Node&lt;T&gt; curr = this.head; if(curr==null)&#123; System.out.println(&quot;linklist is null&quot;); &#125;else&#123; while(curr!=null)&#123; System.out.print(curr.data+&quot; &quot;); curr = curr.next; &#125;System.out.println(); &#125; &#125; public static void main(String[] args)&#123; LinkList linkList = new LinkList&lt;Integer&gt;(); linkList.addNode(5); linkList.addNode(8); linkList.addNode(10); linkList.addNode(6); linkList.addNode(9); System.out.println(&quot;TailNode: &quot;+linkList.tail.data); linkList.deleteNode(8); linkList.printlnLink(); linkList.findByValue(5); linkList.findKth(10); System.out.print(&quot;&quot;); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java易错知识点]]></title>
    <url>%2F2018%2F04%2F06%2FJava%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[最近在看Java基础知识的视频，因为距离大二学习基础知识的时光有些久远了，并且当时也并没有进行总结，所以写下这个博客权当做笔记，方便温故而知新。 强制转换1234567891011第一种情况 byte a = 1; a = 3 + 4; System.out.println(a); 第二种情况 byte a = 1; byte b = 3; byte c = 4; a = b + c; System.out.println(a); 在这两种情况下，最后运行的值有什么不同那？ 第一个的值最后为7；第二个运行后运行错误，显示可能损失精度。 第一种情况下，因为3和4是int值，a是byte值，当a=3+4时，运算符对左右两边进行了一个判断，如果右边的数在byte的范围内，则自动将其强制转换，赋值给a。 第二种情况下，b、c都是变量，系统不可以自动将其强制转换，因为他们可能是一个大于byte范围的数。 算数运算符12345678910111213141516第一种情况 int x = 3, y; y = x++; System.out.println(x); System.out.println(y); 第二种情况 int x = 3, y; y = ++x; System.out.println(x); System.out.println(y); 第三种情况 int a = 3; a = a++; System.out.println(a); 运行结果分别是什么？ 123x = 4 y = 3x = 4 y = 4a = 3 第一种情况涉及到了运算符的原理，系统是如何对 y=x++ 这个式子进行处理的那，先将 x 原先的值3存储起来，再对x进行++运算，最后进行=运算的时候将预存的x的值赋给y。 第二种情况主要式子是 y=++x ，这次是直接进行 ++x 的运算，再将他赋给y。 第三种情况和第一种情况大致相同，为了方便理解，我将 a = a++ 在内存中的处理过程写成程序。通过下面的代码就能够了解为什么最后的结果是3了。 1234int a = 3;temp = a;a++;a = temp; +=运算问题123short s = 3;s += 4;s = s + 4; 第二个式子和第三个式子有什么不同？ 第二个式子可以运行成功，第三个式子不可以。在这里4是int值，+=是一个运算符，他会对右边的数进行判断，是否在short的范围内再自动进行强制转换，赋值给s。而第三个式子=的右面面对的是变量s，必须手动进行强制转换。 %运算问题12a = -5 % 2;b = 5 % -2; a和b的值分别是多少？ a = -1，b = 1 取模运算只有 %左边是负数的情况下对结果有影响]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo博客]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[经过了好一段时间的折腾，终于成功搭建好了博客。我就在这里分享一些使用Hexo+Github搭建的心得。既是为了分享，也是为了防止自己遗忘，备份之用。 搭建前准备工作 1.安装node.js 2.安装git 3.安装hexo （右键git bash 运行$ npm install -g hexo） 本地搭建静态博客 1.新建一个文件夹 如MyBlog 2.生成git模板 在MyBlog文件夹内，右键git bash输入$ hexo init 3.运行npm install 4.运行npm server 5.http://localhost:4000 可以看到本地搭建的博客 将博客关联github 在github上创建名字为XXX.github.io项目(XXX为用户名) 打开本地MyBlog文件夹内的_config.yml配置文件 ,拉到最底下，更改为 1234deploy: type: git repository: https://github.com/OrangeTop/OrangeTop.github.io.git branch: master 第一次使用git需要配置ssh,引号处填写自己的邮箱 1git bash $ ssh-keygen -t rsa -C "your_email@youremail.com" 然后一路回车即可成功生成.ssh文件 在C:\users\用户名.ssh文件夹中，打开id_rsa.pub，全部复制。然后回到github网站，进入setting选择SSH and GPG–&gt;New SSh Keytitle随意填，Key粘贴 1验证:git bash $ ssh -T git@github.com 上传本地仓库， 右键git bash。 (引号处注意填写自己的信息) 12$ git config --global user.name &quot;your name&quot; $ git config --global user.email &quot;your_email@youremail.com&quot; 继续部署，中途需要输入用户名密码 123$ npm install hexo-deployer-git --save$ hexo g$ hexo d 最后在浏览器输入OrangeTop.github.io 即可看见博客 The First Blog 进入MyBlog文件夹右键git bash123456789101112//创建新的博客，文件在source-&gt;_posts文件夹下hexo new &quot;新的文件名&quot;//运行hexo，访问本地localhost:4000可预览hexo s//进入MyBlog文件夹下的public文件夹cd public//本地生成静态文件hexo g//返回MyBlog文件夹cd ..//将本地静态文件推送至githubhexo d 报错解决 下载hexo报错 12345$ npm install -g hexonpm ERR! Unexpected end of JSON input while parsing near &apos;...&quot;commander&quot;:&quot;*&quot;&#125;,&quot;opt&apos;npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\75173\AppData\Roaming\npm-cache\_logs\2018-03-27T13_25_30_385Z-debug.log 解决方法 1234更换为淘宝镜像npm --registry https://registry.npm.taobao.org install express 检验是否更换成功npm config get registry 若不成功，继续 1234清理缓存npm cache clean –force重新安装npm install -g hexo 使用一段时间后，hexo d上传失败，ssh连接github失败 1234打开C:\Windows\System32\drivers\etc目录下的hosts文件再最后面加上下面两行192.30.253.112 github.com192.30.253.113 github.com 参考文章 教你搭一个博客 Hexo博客搭建教程]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2F2018%2F03%2F28%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[尼采说： Was mich nicht umbringt, macht mich stärker.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
