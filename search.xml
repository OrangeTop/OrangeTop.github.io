<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java-IO流]]></title>
    <url>%2F2018%2F05%2F16%2FJava-IO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[输入流和输出流相对于内存设备而言. 将外设中的数据读取到内存中：输入 将内存的数写入到外设中：输出 字节流的两个顶层父类： InputStream OutputStream. 字符流的两个顶层父类： Reader Writer 这些体系的子类都以父类名作为后缀。 而且子类名的前缀就是该对象的功能。 字符流 字符流的由来： 其实就是：字节流读取文字字节数据后，不直接操作而是先查指定的编码表。获取对应的文字。 在对这个文字进行操作。简单说：字节流+编码表 FileWriter使用方法 需求：将一些文字存储到硬盘一个文件中。流程在代码注释中。 创建一个可以往文件中写入字符数据的字符输出流对象，如第14行代码 既然是往一个文件中写入文字数据，那么在创建对象时，就必须明确该文件(用于存储数据的目的地)。 如果文件不存在，则会自动创建；如果文件存在，则会被覆盖。 为什么调用Writer对象中的write(string)方法，写入数据后，文件并没有显示写入的数据？ 其实数据只是写入到临时存储缓冲区中，还需要进行刷新 flush(); close();关闭流，关闭资源。在关闭前会先调用flush刷新缓冲中的数据到目的地。 12345678910111213141516171819202122232425262728public class FileWriterDemo &#123; //换行，unix windows 不一样 ,所以使用这个 private static final String LINE_SEPARATOR = System.getProperty("line.separator"); public static void main(String[] args) throws IOException &#123; //创建一个可以往文件中写入字符数据的字符输出流对象。 /* * 如果构造函数中加入true，可以实现对文件进行续写！ */ FileWriter fw = new FileWriter("demo.txt",true); //调用Writer对象中的write(string)方法，写入数据 fw.write("abcde"+LINE_SEPARATOR+"hahaha"); //fw.write("xixi"); //进行刷新，将数据直接写到目的地中。 fw.flush(); // 关闭流，关闭资源。在关闭前会先调用flush刷新缓冲中的数据到目的地。 fw.close(); //关闭流后，无法再进行写操作// fw.write("haha");// java.io.IOException: Stream closed &#125;&#125; 处理异常 最好使用try，catch。在外部初始化创建 fileWriter，new在try代码块内部 finally中判断是否为空，然后写关闭的语句，给它也进行try，catch 1234567891011121314151617181920212223242526public class IOExceptionDemo &#123; public static void main(String[] args) &#123; FileWriter fw = null; try &#123; fw = new FileWriter("k:\\demo.txt"); fw.write("abcde" + LINE_SEPARATOR + "hahaha"); &#125; catch (IOException e) &#123; System.out.println(e.toString()); &#125; finally &#123; if (fw != null) try &#123; fw.close(); &#125; catch (IOException e) &#123; // code.... throw new RuntimeException("关闭失败"); &#125; &#125; &#125;&#125; FileReader 需求：读取一个文本文件。将读取到的字符打印到控制台 12345678FileReader fr = new FileReader("demo.txt");int ch = 0;while((ch=fr.read())!=-1)&#123; System.out.println((char)ch);&#125;//如果读完已有值后，再读取文件，会返回-1 第二种读取方式： 以数组为单位的读取 12345678假设demo.txt中有 abcde 五个字母char[] buf = new char[3];//将读取到的字符存储到数组中int num = fr.read(buf);System.out.println(num+":"+new String(buf)); //abcint num1 = fr.read(buf);System.out.println(num1+":"+new String(buf)); //dec 为什么一共只有五个字母，第二次读取时却是 ”dec“ ？ 因为是存在缓冲区，第一次abc没有清除，第二次是de覆盖了ab 1234567FileReader fr = new FileReader("demo.txt");char[] buf = new char[1024];int len = 0;while((len=fr.read(buf))!=-1)&#123; System.out.println(new String(buf,0,len));//读取buf，从0读到len&#125; 练习：复制文件 练习：将c盘的一个文本文件复制到d盘 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CopyTextTest_2 &#123; private static final int BUFFER_SIZE = 1024; public static void main(String[] args) &#123; //读取一个已有的文本文件，使用字符读取流和文件相关联。 FileReader fr = null; //创建一个目的，用于存储读到数据。 FileWriter fw = null; try &#123; fr = new FileReader("IO流_2.txt"); fw = new FileWriter("copytest_2.txt"); //创建一个临时容器，用于缓存读取到的字符。 char[] buf = new char[BUFFER_SIZE];//这就是缓冲区。 //定义一个变量记录读取到的字符数，(其实就是往数组里装的字符个数 ) int len = 0; while((len=fr.read(buf))!=-1)&#123; fw.write(buf, 0, len); //读取buf，从0开始，len结束 &#125; &#125; catch (Exception e) &#123; throw new RuntimeException("读写失败"); &#125;finally&#123; if(fw!=null) try &#123; fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if(fr!=null) try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 缓冲区 这就好比去超市，没有缓冲区就是买一样东西一结帐，有缓冲区就是拿着筐或者推着车，买完再结帐，可以大幅度提高效率 不过如果车过大会堵塞出口，那样的话就可以在车子里面放几个筐，结账用筐，也会提高效率 BufferWriter12345678910111213141516171819public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWriter("buf.txt"); //为了提高写入的效率。使用了字符流的缓冲区。 //创建了一个字符写入流的缓冲区对象，并和指定要被缓冲的流对象相关联 BufferedWriter bufw = new BufferedWriter(fw); //使用缓冲区的写入方法将数据先写入到缓冲区中。 for(int x=1; x&lt;=4; x++)&#123; bufw.write("abcdef"+x); bufw.newLine(); //使用缓冲区的刷新方法将数据刷目的地中。 bufw.flush(); &#125; //关闭缓冲区。其实关闭的就是被缓冲的流对象。 bufw.close();&#125; BufferReader123456789101112131415FileReader fr = new FileReader("buf.txt"); BufferedReader bufr = new BufferedReader(fr);FileWriter fw = new FileWriter("buf_copy.txt");BufferedWriter bufw = new BufferedWriter(fw);String line = null;while((line=bufr.readLine())!=null)&#123; bufw.write(line); bufw.newLine(); bufw.flush();&#125; bufw.close();bufr.close(); 自定义MyBufferReader1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 自定义的读取缓冲区。其实就是模拟一个BufferedReader. * * 分析： * 缓冲区中无非就是封装了一个数组， * 并对外提供了更多的方法对数组进行访问。 * 其实这些方法最终操作的都是数组的角标。 * * 缓冲的原理： * 其实就是从源中获取一批数据装进缓冲区中。 * 在从缓冲区中不断的取出一个一个数据。 * * 在此次取完后，在从源中继续取一批数据进缓冲区。 * 当源中的数据取光时，用-1作为结束标记。 */public class MyBufferedReader extends Reader &#123; private Reader r; //定义一个数组作为缓冲区。 private char[] buf = new char[1024]; //定义一个指针用于操作这个数组中的元素。当操作到最后一个元素后，指针应该归零。 private int pos = 0; //定义一个计数器用于记录缓冲区中的数据个数。 当该数据减到0，就从源中继续获取数据到缓冲区中。 private int count = 0; MyBufferedReader(Reader r)&#123; this.r = r; &#125; /** * 该方法从缓冲区中一次取一个字符。 * @return * @throws IOException */ public int myRead() throws IOException&#123; if(count==0)&#123; count = r.read(buf); pos = 0; &#125; if(count&lt;0) return -1; char ch = buf[pos++]; count--; return ch; &#125; public String myReadLine() throws IOException&#123; StringBuilder sb = new StringBuilder(); int ch = 0; while((ch = myRead())!=-1)&#123; if(ch=='\r') continue; if(ch=='\n') return sb.toString(); //将从缓冲区中读到的字符，存储到缓存行数据的缓冲区中。 sb.append((char)ch); &#125; if(sb.length()!=0) return sb.toString(); return null; &#125; public void myClose() throws IOException &#123; r.close();&#125; 装饰设计模式 对一组对象的功能进行增强时，就可以使用该模式进行问题的解决。 缓冲区的设计就是基于装饰设计模式实现的 然而装饰和继承都能实现一样的特点：进行功能的扩展增强。哪个好那？ 装饰和继承对比 假设有一个继承体系 123Writer |--TextWriter：用于操作文本 |--MediaWriter：用于操作媒体。 想要对操作的动作进行效率的提高，需要加入缓冲技术。 按照面向对象，可以通过继承对具体的进行功能的扩展。 12345678Writer |--TextWriter：用于操作文本 |--BufferTextWriter：加入了缓冲技术的操作文本的对象。 |--MediaWriter：用于操作媒体。 |--BufferMediaWriter:但是这样做好像并不理想，如果这个体系进行功能扩展，又多了流对象。那么这个流要提高效率，是不是也要产生子类呢？是。这时就会发现只为提高功能，进行的继承，导致继承体系越来越臃肿。不够灵活。 既然加入的都是同一种技术–缓冲。前一种是让缓冲和具体的对象相结合。 可不可以将缓冲进行单独的封装，哪个对象需要缓冲就将哪个对象和缓冲关联。 12345678910Writer |--TextWriter：用于操作文本 |--MediaWriter：用于操作媒体。 |--BufferWriter：用于提高效率。 class BufferWriter extends Writer&#123; BufferWriter(Writer w) &#123; &#125;&#125; 装饰比继承灵活 特点：装饰类和被装饰类都必须所属同一个接口或者父类。 LineNumberReader 可以增添行号 12345678910111213public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader("IO流_2.txt"); LineNumberReader lnr = new LineNumberReader(fr); String line = null; lnr.setLineNumber(100); while((line=lnr.readLine())!=null)&#123; System.out.println(lnr.getLineNumber()+":"+line); &#125; lnr.close();&#125; 字节流12345678910111213141516171819202122232425public static void demo_read() throws IOException &#123; //1，创建一个读取流对象。和指定文件关联。 FileInputStream fis = new FileInputStream("bytedemo.txt"); //建议使用这种读取数据的方式 byte[] buf = new byte[1024]; int len = 0; while((len=fis.read(buf))!=-1)&#123; System.out.println(new String(buf,0,len)); &#125; fis.close();&#125;public static void demo_write() throws IOException &#123; //1，创建字节输出流对象。用于操作文件. FileOutputStream fos = new FileOutputStream("bytedemo.txt"); //2,写数据。直接写入到了目的地中。 fos.write("abcdefg".getBytes()); fos.close();//关闭资源动作要完成。 &#125; 练习 复制一个Mp3文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class CopyMp3Test &#123; /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; copy_2(); &#125; //fis.available()：文件的字节数 //如果文件字节数特别大，那么速度会很慢 //不建议使用 public static void copy_3() throws IOException &#123; FileInputStream fis = new FileInputStream("c:\\0.mp3"); FileOutputStream fos = new FileOutputStream("c:\\3.mp3"); byte[] buf = new byte[fis.available()]; fis.read(buf); fos.write(buf); fos.close(); fis.close(); &#125; public static void copy_2() throws IOException &#123; FileInputStream fis = new FileInputStream("c:\\0.mp3"); BufferedInputStream bufis = new BufferedInputStream(fis); FileOutputStream fos = new FileOutputStream("c:\\2.mp3"); BufferedOutputStream bufos = new BufferedOutputStream(fos); int ch = 0; while((ch=bufis.read())!=-1)&#123; bufos.write(ch); &#125; bufos.close(); bufis.close(); &#125; public static void copy_1() throws IOException &#123; FileInputStream fis = new FileInputStream("c:\\0.mp3"); FileOutputStream fos = new FileOutputStream("c:\\1.mp3"); byte[] buf = new byte[1024]; int len = 0; while((len=fis.read(buf))!=-1)&#123; fos.write(buf,0,len); &#125; fos.close(); fis.close(); &#125;&#125; 键盘录入 运行下面代码后，在控制台输入一个字母，按回车运行，是不是发现多出来一个 10 ？ 是的，这个是“ \n ”,也就是刚才的回车。 12345678910public static void readKey() throws IOException &#123; InputStream in = System.in; int ch = in.read();//阻塞式方法。 System.out.println(ch); int ch1 = in.read();//阻塞式方法。 System.out.println(ch1);&#125; 练习 获取用户键盘录入的数据，并将数据变成大写显示在控制台上 如果用户输入的是over，结束键盘录入。 12345678910111213141516171819202122232425262728public static void readKey2() throws IOException &#123; //1，创建容器。 StringBuilder sb = new StringBuilder(); //2，获取键盘读取流。 InputStream in = System.in; //3，定义变量记录读取到的字节，并循环获取。 int ch = 0; while((ch=in.read())!=-1)&#123; //在存储之前需要判断是否是换行标记 ,因为换行标记不存储。 if(ch=='\r') continue; if(ch=='\n')&#123; String temp = sb.toString(); if("over".equals(temp)) break; System.out.println(temp.toUpperCase()); sb.delete(0, sb.length()); &#125; else //将读取到的字节存储到StringBuilder中。 sb.append((char)ch); &#125;&#125; 转换流123456789101112131415161718192021222324252627/* 这是方便理解的做法//字节流InputStream in = System.in;OutputStream out = System.out;//将字节转成字符的桥梁。装换流。 InputStreamReader isr = new InputStreamReader(in);OutputStreamWriter osw = new OutputStreamWriter(out);//字符流。BufferedReader bufr = new BufferedReader(isr);BufferedWriter bufw = new BufferedWriter(osw);*///更简洁BufferReader bufr = new BufferReader(new InputStream(System.in));BufferWriter bufr = new BufferWriter(new OutputStream(System.out));String line = null;while((line=bufr.readLine())!=null)&#123; if("over".equals(line)) break; bufw.write(line.toUpperCase()); bufw.newLine(); bufw.flush();&#125; 1、需求：将键盘录入的数据写入到一个文件中。 12BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(newFileOutputStream("a.txt"))); 2、需求：将一个文本文件内容显示在控制台上。 12BufferedReader bufr = new BufferedReader(new InputStreamReader(newFileInputStream("a.txt")));BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out)); 3、需求：将一个文件文件中的内容复制到的另一个文件中。 12BufferedReader bufr = new BufferedReader(new InputStreamReader(newFileInputStream("a.txt")));BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(newFileOutputStream("b.txt"))); 根据不同的需求，改变源的不同位置即可 编码解码 file 流中的read write都是默认编码，如果需要指定编码，则选择其父类 InputStreamReader 、OutputStreamWriter OutputStreamWriter接收一个字节输出流对象，既然是操作文件，那么该对象应该是FileOutputStream 12345OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("uu.txt"),"UTF-8");//BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("uu.txt"),"UTF-8"));osw.write("你好");osw.close(); 什么时候使用转换流呢？ 1、源或者目的对应的设备是字节流，但是操作的却是文本数据，可以使用转换作为桥梁。提高对文本操作的便捷。 2、一旦操作文本涉及到具体的指定编码表时，必须使用转换流 。 流的操作规律 之所以要弄清楚这个规律，是因为流对象太多，开发时不知道用哪个对象合适。 想要知道开发时用到哪些对象。只要通过四个明确即可。 1、明确源和目的(汇) 12源：InputStream Reader目的：OutputStream Writer 2、明确数据是否是纯文本数据。 12345源：是纯文本： Reader 否： InputStream目的：是纯文本： Writer 否： OutputStream 到这里，就可以明确需求中具体要使用哪个体系。 3、明确具体的设备。 12345源设备： 硬盘： File 键盘： System.in 内存： 数组 网络： Socket流 12345目的设备： 硬盘： File 控制台：System.out 内存： 数组 网络： Socket流 4、是否需要其他额外功能。 12341、是否需要高效(缓冲区); 是，就加上buffer.2、转换。 File对象 可以将一个已存在的，或者不存在的文件或者目录封装成file对象。 123456File f1 = new File("c:\\a.txt");File f2 = new File("c:\\","a.txt");File f = new File("c:\\");File f3 = new File(f,"a.txt");File f4 = new File("c:"+File.separator+"abc"+File.separator+"a.txt");System.out.println(f4); 方法 1、获取 获取文件名称 1.2 获取文件路径 1.3 获取文件大小 1.4 获取文件修改时间 12345678910File file = new File("a.txt");String name = file.getName();String absPath = file.getAbsolutePath();//绝对路径（开头有盘符）String path = file.getPath(); //相对路径（开头无盘符）（找不到父目录）long len = file.length();long time = file.lastModified(); //毫秒值Date date = new Date(time); //Date对象格式化DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);String str_time = dateFormat.format(date); 2、创建与删除 123456789101112131415//和输出流不一样，如果文件不存在，则创建，如果文件存在，则不创建。 boolean b = file.createNewFile(); System.out.println("b="+b);boolean b = file.delete();System.out.println("b="+b);File dir = new File("abc");boolean b = dir.mkdir();//make directory System.out.println("b="+b);System.out.println(dir.delete()); //慎用，不走回收站File dir = new File("abc\\q\\e\\c\\z\\r\\w\\y\\f\\e\\g\\s");dir.mkdirs();//创建多级目录System.out.println(dir.delete()); //运行后，仅删除 S 文件夹 3、判断 123456File f = new File("aaa"); boolean b = f.exists(); //是否存在 System.out.println("b="+b);// 最好先判断是否存在。 System.out.println(f.isFile()); //是否是文件System.out.println(f.isDirectory());//是否是目录 4、重命名 123456//可以从C到D盘 重命名//即为剪切C盘的文件，复制到D盘File f1 = new File("c:\\9.mp3");File f2 = new File("d:\\aa.mp3");boolean b = f1.renameTo(f2);System.out.println("b="+b); 根目录方法12345678File[] files = File.listRoots();for(File file : files)&#123; System.out.println(file);&#125;File file = new File("d:\\");System.out.println("getFreeSpace:"+file.getFreeSpace()); //空闲容量System.out.println("getTotalSpace:"+file.getTotalSpace()); //总容量System.out.println("getUsableSpace:"+file.getUsableSpace());//可使用容量 获取目录内容 获取当前目录下的文件以及文件夹的名称，包含隐藏文件 调用list方法的File对象中封装的必须是目录,否则会发生NullPointerException 如果访问的系统级目录也会发生空指针异常。 如果目录存在但是没有内容，会返回一个数组，但是长度为0. 123456789public static void listDemo() &#123; File file = new File("c:\\"); String[] names = file.list(); System.out.println(names.length); for(String name : names)&#123; System.out.println(name); &#125;&#125; 过滤器 显示后缀.java 的文件，使用 File类的 list方法 12345678public class FilterByJava implements FilenameFilter &#123; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(".java"); &#125;&#125; 显示未隐藏的文件，使用 listFiles 方法 12345678910111213141516171819public class FilterByHidden implements FileFilter &#123; @Override public boolean accept(File pathname) &#123; return !pathname.isHidden(); &#125;&#125;public static void listDemo() &#123; File dir = new File("c:\\"); File[] files = dir.listFiles(new FilterByHidden()); for(File file : files)&#123; System.out.println(file); &#125;&#125; 如果想过滤后缀，但是每次改过滤器太复杂，可以重新设计过滤器 1234567891011121314public class SuffixFilter implements FilenameFilter &#123; private String suffix ; public SuffixFilter(String suffix) &#123; super(); this.suffix = suffix; &#125; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(suffix); &#125;&#125; 这样ListDemo 类中就可以更改想要的后缀 12String[] names = dir.list(new SuffixFilter(".txt"));String[] names = dir.list(new SuffixFilter(".java"));]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-其余对象API]]></title>
    <url>%2F2018%2F05%2F15%2FJava-%E5%85%B6%E4%BD%99%E5%AF%B9%E8%B1%A1API%2F</url>
    <content type="text"><![CDATA[System类 System：类中的方法和属性都是静态的。 常用方法currentTimeMillis 获取当前时间的毫秒值。 1public static long currentTimeMillis(); 与1970.1.1午夜时间的差 Properties 获取系统的属性信息，并存储到了Properties集合中。 properties集合中存储都是String类型的键和值。 最好使用它自己的存储和取出的方法来完成元素的操作。 12345678910111213public static void demo_1()&#123; Properties prop = System.getProperties(); Set&lt;String&gt; nameSet = prop.stringPropertyNames(); for(String name : nameSet)&#123; String value = prop.getProperty(name); System.out.println(name+"::"+value); &#125;&#125; 在linux、windows上换行符号是不一样的 123456//如果这样写的话，这个换行符在哪个系统中都不会出问题System.out.println(System.getProperty("hello"+"line_separator"+"world");//如果多次调用太麻烦，就可以将他在文件中用final定义private static final String LINE_SEPARATOR = System.getProperty("line.separator");System.out.println("hello"+LINE_SEPARATOR+" world"); Runtime类 Runtime：没有构造方法摘要，说明该类不可以创建对象。 又发现还有非静态的方法。说明该类应该提供静态的返回该类对象的方法 而且只有一个，说明Runtime类使用了单例设计模式。 1234567891011public static void main(String[] args) throws IOException, InterruptedException &#123; Runtime r = Runtime.getRuntime();// execute: 执行。 xxx.exe Process p = r.exec("notepad.exe");// r.exec("D:\\abc\\asd\\xxxx.exe"); Thread.sleep(5000); //延迟 p.destroy(); //杀死进程，只能杀掉他开启的&#125; Math类 Math：提供了操作数学运算的方法。都是静态的 常用的方法： ceil()：返回大于参数的最小整数。（如18.6 返回19） floor()：返回小于参数的最大整数。（如18.6 返回18） round()：返回四舍五入的整数。 （如18.6 返回19） pow(a,b)：a的b次方。 random()：返回大于0.0且小于1.0的一个伪随机数 12345678910111213for (int i = 0; i &lt; 10; i++) &#123; double d1 = Math.ceil(Math.random()*10); //返回 1 到 10 的数值 double d2 = Math.ceil(Math.random()*10); //返回 0 到 9 的数值 double d3 = (int)(Math.random()*10+1); //返回 1 到 10 的数值 System.out.println(d1);&#125;//Random也有自己的对象Random r = new Random();for (int i = 0; i &lt; 10; i++) &#123; double d4 = (int)(r.nextDouble()*6+1); int d5 = r.nextInt(6); //限定数值大于0 小于6 System.out.println(d5);&#125; Date类 月份：0–11 （代表12个月） 日期对象、毫秒值之间的转换 毫秒值–&gt;日期对象 ： 1，通过Date对象的构造方法 new Date(timeMillis); 2，还可以通过setTime设置。 因为可以通过Date对象的方法对该日期中的各个字段(年月日等)进行操作。 日期对象–&gt;毫秒值： 2，getTime方法。 因为可以通过具体的数值进行运算。 123System.out.println(System.currentTimeMillis());Date d = new Date(1526459420372L); //因为数值太大，所以加上LSystem.out.println(d); 将日期对象进行格式化 将日期对象–&gt;日期格式的字符串 使用的是DateFormat类中的format方法 12345678910111213141516public static void methodDemo() &#123; Date date = new Date(); //获取日期格式对象。具体着默认的风格。 FULL LONG等可以指定风格。 DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG); dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);// System.out.println(dateFormat); //如果风格是自定义的如何解决呢？ dateFormat = new SimpleDateFormat("yyyy--MM--dd"); String str_date = dateFormat.format(date); System.out.println(str_date);&#125; 将日期格式的字符串–&gt;日期对象 使用的是Date Format类中的parse()方法。 12345678910111213public static void methodDemo_3() throws ParseException &#123; String str_date1 = "2018年5月16日"; DateFormat dateFormat1 = DateFormat.getDateInstance(DateFormat.LONG); String str_date2 = "2018---6---6"; DateFormat dateFormat2 = new SimpleDateFormat("yyyy---MM---dd"); Date date1 = dateFormat1.parse(str_date1); Date date2 = dateFormat2.parse(str_date2); System.out.println(date1); System.out.println(date2);&#125; 练习 计算2018-04-11与2018-05-16中间相差多少天 思路： 日期字符串转日期对象 日期对象转毫秒值 毫秒值相减，取绝对值 将结果转换成天数 1234567891011121314151617181920public class DateTest &#123; public static void main(String[] args) throws ParseException &#123; String str1 = "2018-04-11"; String str2 = "2018-05-16"; int day = datetest(str1, str2); System.out.println(day); &#125; public static int datetest(String str1,String str2) throws ParseException &#123; DateFormat dateFormat = DateFormat.getDateInstance(); Date date1 = dateFormat.parse(str1); Date date2 = dateFormat.parse(str2); long date = Math.abs(date2.getTime()-date1.getTime()); int day = getDay(date); return day; &#125; public static int getDay(long date)&#123; int day = (int)(date/1000/60/60/24); return day; &#125;&#125; calendar类 Date类中已经过时的类，都是在calendar中被替换 1234567891011121314public static void showDate(Calendar c) &#123; int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH)+1; //表示月份的数字是0-11 int day = c.get(Calendar.DAY_OF_MONTH); int week = c.get(Calendar.DAY_OF_WEEK); //这里的周日为美国的周一 System.out.println(year+"年"+month+"月"+day+"日"+getWeek(week));&#125;public static String getWeek(int i) &#123; String[] weeks = &#123;"","星期日","星期一","星期二","星期三","星期四","星期五","星期六"&#125;; return weeks[i];&#125; calendar中的add方法，偏移日期 123Calendar c = Calendar.getInstance();c.set(2018, 11, 20);c.add(Calendar.MONTH, 2);]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-集合框架]]></title>
    <url>%2F2018%2F05%2F10%2FJava-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[概述 集合类的由来： 对象用于封装特有数据，对象多了需要存储，如果对象的个数不确定。就使用集合容器进行存储。 集合特点： 用于存储对象的容器。 集合的长度是可变的。 集合中不可以存储基本数据类型值。 体系 集合容器因为内部的数据结构不同，有多种具体容器。不断的向上抽取，就形成了集合框架。 框架的顶层就是Collection接口： List：有序(存入和取出的顺序一致),元素都有索引(角标)，元素可以重复。 Set：元素不能重复,无序。 功能(Collection接口) 添加 12boolean add(E e);boolean addAll(Collection coll); 判断 123boolean remove(object obj):boolean removeAll(Collection coll);void clear(); 删除 123boolean contains(object obj):boolean containsAll(Colllection coll);boolean isEmpty();//判断集合中是否有元素。 获取 123456789int size():Iterator iterator():取出元素的方式：迭代器。该对象必须依赖于具体容器，因为每一个容器的数据结构都不同。所以该迭代器对象是在容器中进行内部实现的。对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可，也就是iterator方法。Iterator接口就是对所有的Collection容器进行元素取出的公共接口。其实就是抓娃娃游戏机中的夹子！ 其他 12boolean retainAll(Collection coll);//取交集。Object[] toArray();//将集合转成数组。 ​ 方法演示 展示一下如何使用这些方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class CollectionDemo &#123; /** * @param args */ public static void main(String[] args) &#123; Collection coll = new ArrayList(); // show(coll); Collection c1 = new ArrayList(); Collection c2 = new ArrayList(); show(c1,c2); &#125; public static void show(Collection coll)&#123; //1,添加元素。add. coll.add("abc1"); coll.add("abc2"); coll.add("abc3"); System.out.println(coll); //2，删除元素。remove coll.remove("abc2");//会改变集合的长度 //清空集合. //coll.clear(); System.out.println(coll.contains("abc3")); System.out.println(coll); &#125; public static void show(Collection c1,Collection c2)&#123; //给c1添加元素。 c1.add("abc1"); c1.add("abc2"); c1.add("abc3"); c1.add("abc4"); //给c2添加元素。 c2.add("abc1"); c2.add("abc2"); c2.add("abc3"); c2.add("abc4"); c2.add("abc5"); System.out.println("c1:"+c1); System.out.println("c2:"+c2); //演示addAll// c1.addAll(c2);//将c2中的元素添加到c1中。 //演示removeAll// boolean b = c1.removeAll(c2);//将两个集合中的相同元素从调用removeAll的集合中删除。// System.out.println("removeAll:"+b); //演示containsAll// boolean b = c1.containsAll(c2);// System.out.println("containsAll:"+b); //演示retainAll boolean b = c1.retainAll(c2);//取交集，保留和指定的集合相同的元素，而删除不同的元素。 //和removeAll功能相反 。 System.out.println("retainAll:"+b); System.out.println("c1:"+c1); &#125; &#125; ​ 迭代器 演示迭代器方法： 1234567891011121314151617181920212223public static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add("abc1"); coll.add("abc2"); coll.add("abc3"); coll.add("abc4"); // System.out.println(coll); // 使用了Collection中的iterator()方法。 调用集合中的迭代器方法，是为了获取集合中的迭代器对象。// Iterator it = coll.iterator(); // while(it.hasNext())&#123;// System.out.println(it.next());// &#125; //这样写也可以 for(Iterator it = coll.iterator(); it.hasNext(); )&#123; System.out.println(it.next()); &#125; &#125;&#125; 迭代器图解 List List：有序(存入和取出的顺序一致),元素都有索引(角标)，元素可以重复。 特有的常见方法：有一个共性特点就是都可以操作角标。 1234567891011121314151，添加 void add(index,element); void add(index,collection);2，删除； Object remove(index):3，修改： Object set(index,element);4，获取： Object get(index); int indexOf(object); int lastIndexOf(object); List subList(from,to); list集合是可以完成对元素的增删改查。 ListIterator 在迭代器过程中，不要使用集合操作元素，容易出现异常。 否则会报错（java.util.ConcurrentModificationException) 可以使用Iterator接口的子接口ListIterator来完成在迭代中对元素进行更多的操作。 它可以实现在迭代过程中完成对元素的增删改查。 注意：只有list集合具备该迭代功能 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; List list = new ArrayList(); list.add("abc1"); list.add("abc2"); list.add("abc3"); System.out.println("list:"+list); ListIterator it = list.listIterator(); while(it.hasNext())&#123; Object obj = it.next(); if(obj.equals("abc2"))&#123; it.set("abc9"); &#125; &#125; System.out.println("hasNext:"+it.hasNext()); //判断是否有上一个数据 System.out.println("hasPrevious:"+it.hasPrevious()); //反向迭代数据 while(it.hasPrevious())&#123; System.out.println("previous:"+it.previous()); &#125; System.out.println("list:"+list);&#125; List常用子类特点 Vector：内部是数组数据结构，是同步的。增删，查询都很慢！ ArrayList：内部是数组数据结构，是不同步的。替代了Vector。查询的速度快。 LinkedList：内部是链表数据结构，是不同步的。增删元素的速度很快。 Vector 的Enumeration方法和迭代器功能相同，但名字过长 LinkedList jdk1.6的方法更新 1234567891011getFirst();.//获取但不移除，如果链表为空，抛出NoSuchElementException.getLast();JDK1.6peekFirst();//获取但不移除，如果链表为空，返回null.peekLast():removeFirst();//获取并移除，如果链表为空，抛出NoSuchElementException.removeLast();JDK1.6pollFirst();//获取并移除，如果链表为空，返回null.pollLast(); 存储自定义对象12345678910111213141516171819202122public class ArrayListTest &#123; public static void main(String[] args) &#123; Person p1 = new Person("lisi1",21); ArrayList al = new ArrayList(); al.add(p1); al.add(new Person("lisi2",22)); al.add(new Person("lisi3",23)); al.add(new Person("lisi4",24)); Iterator it = al.iterator(); while(it.hasNext())&#123; //在这里进行向下转型，以使用子类特有方法 Person p = (Person) it.next(); System.out.println(p.getName()+"--"+p.getAge()); &#125; &#125; &#125; ​ 链表练习 用链表简单模拟一个堆栈及队列的输入输出过程 123456789101112131415161718192021222324252627282930313233import java.util.Iterator;import java.util.LinkedList;public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList link = new LinkedList(); link.addFirst("abc1"); link.addFirst("abc2"); link.addFirst("abc3"); link.addFirst("abc4");// System.out.println(link);// System.out.println(link.getFirst());//获取第一个但不删除。// System.out.println(link.getFirst()); // System.out.println(link.removeFirst());//获取元素但是会删除。// System.out.println(link.removeFirst()); while(!link.isEmpty())&#123; System.out.println(link.removeLast()); &#125; System.out.println(link);// Iterator it = link.iterator();// while(it.hasNext())&#123;// System.out.println(it.next());// &#125; &#125;&#125; Set Set:元素不可以重复，是无序。Set接口中的方法和Collection一致。 HashSet HashSet: 内部数据结构是哈希表 ，是不同步的。 如何保证该集合的元素唯一性呢？ 是通过对象的hashCode和equals方法来完成对象唯一性的！ 如果对象的hashCode值不同，那么不用判断equals方法，就直接存储到哈希表中。 如果对象的hashCode值相同，那么要再次判断对象的equals方法是否为true。 如果为true，视为相同元素，不存。如果为false，那么视为不同元素，就进行存储。 记住：如果元素要存储到HashSet集合中，必须覆盖hashCode方法和equals方法。一般情况下，如果定义的类会产生很多对象，比如人，学生，书，通常都需要覆盖equals，hashCode方法。建立对象判断是否相同的依据。 12345678910111213141516//Person类有name，年龄//重写hashCode，equalspublic int hashCode() &#123; return name.hashCode()+age*27; return 100;&#125;public boolean equals(Object obj) &#123; //判断是否是同一个对象 if(this == obj) return true; //判断是否属于Person类 if(!(obj instanceof Person)) throw new ClassCastException("类型错误"); Person p = (Person)obj; return this.name.equals(p.name) &amp;&amp; this.age == p.age;&#125; 练习 将Person类中去除相同元素 1234567891011121314151617181920//前提：Person中public static ArrayList getSingleElement(ArrayList al) &#123; //1,定义一个临时容器。 ArrayList temp = new ArrayList(); //2,迭代al集合。 Iterator it = al.iterator(); while(it.hasNext())&#123; Object obj = it.next(); //3,判断被迭代到的元素是否在临时容器存在。 if(!temp.contains(obj))&#123; temp.add(obj); &#125; &#125; return temp;&#125; LinkedHashSet 与HashSet区别就是HashSet无序，LinkedHashSet有序， TreeSet TreeSet可以对Set集合中的元素进行排序。是不同步的。 判断元素唯一性的方式：就是根据比较方法的返回结果是否是0，是0，就是相同元素，不存。 TreeSet对元素进行排序的方式一： 让元素自身具备比较功能，就需要实现Comparable接口。覆盖compareTo方法。 12345678910111213141516171819//Person中的方法public int compareTo(Object o) &#123; //向下转型前最好进行健壮性增强 Person p = (Person)o; int temp = this.age-p.age; return temp==0?this.name.compareTo(p.name):temp; /* if(this.age&gt;p.age) return 1; if(this.age&lt;p.age) return -1; else&#123; return this.name.compareTo(p.name); &#125; */&#125; 如果不要按照对象中具备的自然顺序进行排序。如果对象中不具备自然顺序。怎么办？ 可以使用TreeSet集合第二种排序方式二： 让集合自身具备比较功能，定义一个类实现Comparator接口，覆盖compare方法。 将该类对象作为参数传递给TreeSet集合的构造函数。 12345678910111213141516/** * 创建了一个根据Person类的name进行排序的比较器。 */public class ComparatorByName implements Comparator &#123; @Override public int compare(Object o1, Object o2) &#123; Person p1 = (Person)o1; Person p2 = (Person)o2; int temp = p1.getName().compareTo(p2.getName()); return temp==0?p1.getAge()-p2.getAge(): temp; //return 1; 这样写的话，注销前面的就意味着按输入顺序来 &#125;&#125; 内部实现用的二叉树，打个比方，返回正数为右子树，负数为左子树 泛型 jdk1.5出现的安全机制。 好处： 1、将运行时期的问题ClassCastException转到了编译时期。 2、避免了强制转换的麻烦。 &lt;&gt;:什么时候用？ 当操作的引用数据类型不确定的时候。就使用&lt;&gt;。将要操作的引用数据类型传入即可. 其实&lt;&gt;就是一个用于接收具体引用数据类型的参数范围。 在程序中，只要用到了带有&lt;&gt;的类或者接口，就要明确传入的具体引用数据类型 。 泛型技术是给编译器使用的技术,用于编译时期。确保了类型的安全。 擦除补偿 运行时，会将泛型去掉，生成的class文件中是不带泛型的,这个称为泛型的擦除。 为什么擦除呢？ 因为为了兼容运行的类加载器。 泛型的补偿： 在运行时，通过获取元素的类型进行转换动作。不用使用者在强制转换了。 泛型类 在jdk1.5后，使用泛型来接收类中要操作的引用数据类型。 泛型类。什么时候用？ 当类中的操作的引用数据类型不确定的时候，就使用泛型来表示。 123456789101112//主类调用此类时，需为其赋上数据类型public class Tool&lt;QQ&gt;&#123; private QQ q; public QQ getObject() &#123; return q; &#125; public void setObject(QQ object) &#123; this.q = object; &#125;&#125; 泛型方法 泛型方法的使用 1234567891011121314151617181920212223242526272829303132public class Tool&lt;QQ&gt;&#123; private QQ q; public QQ getObject() &#123; return q; &#125; public void setObject(QQ object) &#123; this.q = object; &#125; /** * 将泛型定义在方法上。 * @param str */ public &lt;W&gt; void show(W str)&#123; System.out.println("show : "+str.toString()); &#125; public void print(QQ str)&#123; System.out.println("print : "+str); &#125; /** * 当方法静态时，不能访问类上定义的泛型。如果静态方法使用泛型， * 只能将泛型定义在方法上。 * @param obj */ public static &lt;Y&gt; void method(Y obj)&#123; System.out.println("method:"+obj); &#125;&#125; 通配符 泛型的通配符：? 未知类型。 1234567891011121314151617181920212223public static void main(String[] args) &#123; ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;(); al.add(&quot;abc&quot;); al.add(&quot;hehe&quot;); ArrayList&lt;Integer&gt; al2 = new ArrayList&lt;Integer&gt;(); al2.add(5); al2.add(67); printCollection(al); printCollection(al2);&#125;/*** 迭代并打印集合中元素。* @param al*/public static void printCollection(Collection&lt;?&gt; al) &#123; Iterator&lt;?&gt; it = al.iterator(); while(it.hasNext())&#123; System.out.println(it.next().toString()); &#125;&#125; 泛型的限定 上限 ? extends E 接收E类型或者E的子类型对象 一般存储对象的时候用。比如 添加元素 addAll. 下限 ? super E 接收E类型或者E的父类型对象。 一般取出对象的时候用。比如比较器。 123456789public static void printCollection(Collection&lt;? extends Person&gt; al) &#123; Iterator&lt;? extends Person&gt; it = al.iterator(); while(it.hasNext())&#123; Person p = it.next(); System.out.println(p.getName()+":"+p.getAge()); &#125;&#125; 什么时候用上限？ 一般在存储元素的时候都是用上限，因为这样取出都是按照上限类型来运算的。不会出现类型安全隐患。 什么时候用下限呢？ 通常对集合中的元素进行取出操作时，可以使用下限。如TreeSet的比较器 集合选择技巧需要唯一吗？？ 需要：Set 需要制定顺序： 需要： TreeSet 不需要：HashSet 但是想要一个和存储一致的顺序(有序):LinkedHashSet 不需要：List 需要频繁增删吗？ 需要：LinkedList 不需要：ArrayList 如何记录各容器的结构和所属体系呢？？ List ArrayList LinkedList Set HashSet TreeSet 后缀名就是该集合所属的体系，前缀名就是该集合的数据结构。看到array：就要想到数组，就要想到查询快，有角标. 看到Link：就要想到链表，就要想到增删快，就要想要 add get remove方法及头插尾插法 看到hash：就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashCode方法和equals方法。 看到tree：就要想到二叉树，就要想要排序，就要想到两个接口Comparable，Comparator 。 而且通常这些常用的集合容器都是不同步的。 Map 一次添加一对元素。Collection 一次添加一个元素。 Map也称为双列集合，Collection集合称为单列集合。 其实map集合中存储的就是键值对。 map集合中必须保证键的唯一性。 常用方法123456789101112131415161，添加。 value put(key,value):返回前一个和key关联的值，如果没有返回null.2，删除。 void clear():清空map集合。 value remove(key):根据指定的key删除这个键值对。 3，判断。 boolean containsKey(key): boolean containsValue(value): boolean isEmpty();4，获取。 value get(key):通过键获取值，如果没有该键返回null。 当然可以通过返回null，来判断是否包含指定键。 int size(): 获取键值对的个数。 重点方法 取出map中所有元素 12345678910111213//取出map中的所有元素。//原理，通过keySet方法获取map中所有的键所在的Set集合，在通过Set的迭代器获取到每一个键，//在对每一个键通过map集合的get方法获取其对应的值即可。public static void keySetDemo(Map&lt;Integer,String&gt; map)&#123; Set&lt;Integer&gt; keySet = map.keySet(); Iterator&lt;Integer&gt; it = keySet.iterator(); while(it.hasNext())&#123; Integer key = it.next(); String value = map.get(key); System.out.println(key+":"+value);&#125; 取出map中所有元素–&gt;第二种方法 12345678910111213141516/** 通过Map转成set就可以迭代。* 找到了另一个方法。entrySet。* 该方法将键和值的映射关系作为对象存储到了Set集合中，而这个映射关系的类型就是Map.Entry类型(结婚证)*/public static void keySetDemo(Map&lt;Integer,String&gt; map)&#123; Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator(); while(it.hasNext())&#123; Map.Entry&lt;Integer, String&gt; me = it.next(); Integer key = me.getKey(); String value = me.getValue(); System.out.println(key+"::::"+value);&#125; 常用子类 Hashtable :内部结构是哈希表，是同步的。不允许null作为键，null作为值。 Properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合 。 |–HashMap : 内部结构是哈希表，不是同步的。允许null作为键，null作为值。 |–TreeMap : 内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。 ​ 练习一 将学生对象和学生的归属地通过键与值存储到map集合中。 123456789101112131415161718192021public static void hashMapMethod()&#123; HashMap&lt;Student,String&gt; hm = new HashMap&lt;Student,String&gt;(); hm.put(new Student("lisi",38),"北京"); hm.put(new Student("zhaoliu",24),"上海"); hm.put(new Student("xiaoqiang",31),"沈阳"); hm.put(new Student("wangcai",28),"大连"); //需要对student类进行hashCode、equals方法的重写 //否则相同的student也会被传进去 hm.put(new Student("zhaoliu",24),"铁岭"); //Set&lt;Student&gt; keySet = hm.keySet(); //Iterator&lt;Student&gt; it = keySet.iterator(); Iterator&lt;Student&gt; it = hm.keySet().iterator(); while(it.hasNext())&#123; Student key = it.next(); String value = hm.get(key); System.out.println(key.getName()+":"+key.getAge()+"---"+value); &#125;&#125; 如果需要进行排序的话，使用TreeMap 12345678910111213141516171819202122public static void treeMapDemo() &#123; TreeMap&lt;Student,String&gt; tm = new TreeMap&lt;Student,String&gt;(new ComparatorByName()); tm.put(new Student("lisi",38),"北京"); tm.put(new Student("zhaoliu",24),"上海"); tm.put(new Student("xiaoqiang",31),"沈阳"); tm.put(new Student("wangcai",28),"大连"); tm.put(new Student("zhaoliu",24),"铁岭"); Iterator&lt;Map.Entry&lt;Student, String&gt;&gt; it = tm.entrySet().iterator(); while(it.hasNext())&#123; Map.Entry&lt;Student,String&gt; me = it.next(); Student key = me.getKey(); String value = me.getValue(); System.out.println(key.getName()+":"+key.getAge()+"---"+value); &#125;&#125; 如果需要按输入顺序存储的话，LinkedHashMap 练习二12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* * 练习: * "fdgavcbsacdfs" 获取该字符串中，每一个字母出现的次数。 * 要求打印结果是：a(2)b(1)...; * 思路： * 对于结果的分析发现，字母和次数之间存在着映射的关系。而且这种关系很多。 * 很多就需要存储，能存储映射关系的容器有数组和Map集合。 * 关系一方式有序编号吗？没有！ * 那就是使用Map集合。 又发现可以保证唯一性的一方具备着顺序如 a b c ... * 所以可以使用TreeMap集合。 * * 这个集合最终应该存储的是字母和次数的对应关系。 * * 1，因为操作的是字符串中的字母，所以先将字符串变成字符数组。 * 2，遍历字符数组，用每一个字母作为键去查Map集合这个表。 * 如果该字母键不存在，就将该字母作为键 1作为值存储到map集合中。 * 如果该字母键存在，就将该字母键对应值取出并+1，在将该字母和+1后的值存储到map集合中， * 键相同值会覆盖。这样就记录住了该字母的次数. * 3，遍历结束，map集合就记录所有字母的出现的次数。 * */public class MapTest &#123; public static void main(String[] args) &#123; String str = "fdg+avAdc bs5dDa9c-dfs"; String s = getCharCount(str); System.out.println(s); &#125; public static String getCharCount(String str) &#123; //将字符串变成字符数组 char[] chs = str.toCharArray(); //定义map集合表。 Map&lt;Character,Integer&gt; map = new TreeMap&lt;Character,Integer&gt;(); for (int i = 0; i &lt; chs.length; i++) &#123; if(!(chs[i]&gt;='a' &amp;&amp; chs[i]&lt;='z' || chs[i]&gt;='A' &amp;&amp; chs[i]&lt;='Z'))// if(!(Character.toLowerCase(chs[i])&gt;='a' &amp;&amp; Character.toLowerCase(chs[i])&lt;='z')) continue; //将数组中的字母作为键去查map表。 Integer value = map.get(chs[i]); int count = 1; //判断值是否为null. if(value!=null)&#123; count = value+1; &#125; map.put(chs[i], count); &#125; return mapToString(map); &#125; private static String mapToString(Map&lt;Character, Integer&gt; map) &#123; StringBuilder sb = new StringBuilder(); //取出map中所有元素，更改格式存储 Iterator&lt;Character&gt; it = map.keySet().iterator(); while(it.hasNext())&#123; Character key = it.next(); Integer value = map.get(key); sb.append(key+"("+value+")"); &#125; return sb.toString(); &#125;&#125; 工具类Collections Collections是集合框架的工具类， 里面的方法都是静态的。 对list集合进行指定顺序的排列 12345//因为这个排序方法是基于比较器Comparable的，所以使用泛型//这样继承了Comparable的类及其父类都可以使用该方法public static &lt;T extends Comparable&lt;? super T&gt;&gt; void Sort(List&lt;T&gt; list)&#123; //代码&#125; 折半查找 binarySearch 最值 max 逆序 替换 replace 全部替换 fill 将list随机洗牌 shuffle 给非同步集合加锁 同步方法怎么实现的那？ 123456789101112131415161718192021222324252627282930class MyCollections&#123; public static List synList(List list)&#123; return new MyList(list); &#125; private class MyList implements List&#123; private List list; private static final Object lock = new Object(); MyList(List list)&#123; this.list = list; &#125; public boolean add(Object obj)&#123; synchronized(lock) &#123; return list.add(obj); &#125; &#125; public boolean remove(Object obj)&#123; synchronized(lock) &#123; return list.remove(obj); &#125; &#125; &#125;&#125; 那么该如何调用这个方法那？ 123List list = new ArrayList();//非同步的。list = MyCollections.synList(list);//返回一个同步的list. ArraystoString toString 经典实现 123456789101112131415//toString的经典实现。public static String myToString(int[] a)&#123; int iMax = a.length - 1; if (iMax == -1) return "[]"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) &#123;//中间省略条件判断，提高了效率。 b.append(a[i]); if (i == iMax) return b.append(']').toString(); b.append(", "); &#125;&#125; asList asList 数组转 List 集合 12345678910111213141516171819202122232425262728293031323334353637public static void demo_1() &#123; /* * 重点：List asList(数组)将数组转成集合。 * * 好处：其实可以使用集合的方法操作数组中的元素。 * * 注意：数组的长度是固定的，所以对于集合的增删方法是不可以使用的 * 否则会发生UnsupportedOperationException * */ String[] arr = &#123;"abc","haha","xixi"&#125;; boolean b = myContains(arr, "xixi"); System.out.println("contains:"+b); List&lt;String&gt; list = Arrays.asList(arr); boolean b1 = list.contains("xixi"); System.out.println("list contaisn:="+b1); //list.add("hiahia");//UnsupportedOperationException System.out.println(list);&#125;public static void demo_2() &#123; /* * 如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储。 * * 如果数组中的元素是基本类型数值，那么会将该数组作为集合中的元素进行存储。 * */ int[] arr = &#123;31,11,51,61&#125;; List&lt;int[]&gt; list = Arrays.asList(arr); System.out.println(list);&#125; toArray 集合转数组 12345678910111213141516171819202122232425 /** 集合转成数组呢？* * 使用的就是Collection接口中的toArray方法。* * 集合转成数组：可以对集合中的元素操作的方法进行限定。不允许对其进行增删。*/ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc1"); list.add("abc2"); list.add("abc3"); /* * toArray方法需要传入一个指定类型的数组。 * 长度该如何定义呢？ * 如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组。 * 如果长度大于集合的size，那么该方法就会使用指定的数组，存储集合中的元素，其他位置默认为null。 * * 所以建议，最后长度就指定为，集合的size。 */ String[] arr = list.toArray(new String[list.size()]); System.out.println(Arrays.toString(arr)); JDK5 特性ForEach概述123456foreach语句：格式：for(类型 变量 ：Collection集合|数组)&#123; &#125; 代码演示 1234567891011121314151617181920212223public static void main(String[] args)&#123; List&lt;String&gt; list =new ArrayList&lt;String&gt;(); list.add(&quot;abc1&quot;); list.add(&quot;abc2&quot;); list.add(&quot;abc3&quot;); for(String s : list)&#123; //简化书写。 System.out.println(s); &#125; int[] arr = &#123;3,1,5,7,4&#125;; for(int i : arr)&#123; System.out.println(i); &#125; // Iterator&lt;String&gt; it = list.iterator(); // while(it.hasNext())&#123;// System.out.println(it.next());// &#125;&#125; 传统for、高级for区别 传统for可以完成对语句执行很多次，因为可以定义控制循环的增量和条件。 高级for是一种简化形式。 它必须有被遍历的目标。该目标要是数组，要么是Collection单列集合。 对数数组的遍历如果仅仅是获取数组中的元素，可以使用高级for。 如果要对数组的角标进行操作建议使用传统for。 注意事项 可以使用高级for遍历map集合吗？ 不能直接用，但是可以将map转成单列的set，就可以用了。 12345678910111213141516171819Map&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(); map.put(3,"zhagsan"); map.put(1,"wangyi"); map.put(7,"wagnwu"); map.put(4,"zhagsansan"); for(Integer key : map.keySet())&#123; String value = map.get(key); System.out.println(key+"::"+value); &#125; for(Map.Entry&lt;Integer,String&gt; me : map.entrySet())&#123; Integer key = me.getKey(); String value = me.getValue(); System.out.println(key+":"+value); &#125; 函数可变参数 函数的可变参数。 其实就是一个数组，但是接收的是数组的元素。 自动将这些元素封装成数组。简化了调用者的书写。 注意：可变参数类型，必须定义在参数列表的结尾。 123456789101112131415161718192021222324public static void main(String[] args) &#123; int sum = newAdd(5,1,4,7,3); System.out.println("sum="+sum); int sum1 = newAdd(5,1,2,7,3,9,8,7,6); System.out.println("sum1="+sum1);&#125;public static int newAdd(int... arr)&#123; int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; sum+=arr[i]; &#125; return sum;&#125;注意！！！！public static int newAdd1(int... arr,int a)&#123; 会报错，因为arr吃掉了所有值&#125;public static int newAdd2(int a，int... arr)&#123; 这样就没事了&#125; 静态导入12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;import java.util.List;import static java.util.Collections.*;//静态导入，其实导入的是类中的静态成员。//import static java.util.Collections.max;//静态导入，其实导入的是类中的静态成员。import static java.lang.System.*;public class StaticImportDemo &#123; /** * @param args * 注意：如果两个类中有相同名字的方法，并且都会被使用 * 一定不能静态导入，否则程序会不知道用哪个方法 */ public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc3"); list.add("abc7"); list.add("abc1"); out.println(list); //collection.sort(list); sort(list); //静态导入后可以简写 String max = max(list); System.out.println("max="+max); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基本数据类型包装类]]></title>
    <url>%2F2018%2F05%2F10%2FJava-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[基本数据类型对象包装类 为了方便操作基本数据类型值，将其封装成了对象，在对象中定义了属性和行为丰富了该数据的操作 用于描述该对象的类就成为基本数据类型对象包装类 12345678byte Byteshort Shortint Integerlong Longfloat Floatdouble Doublechar Characterboolean Boolean 类型转换 该包装对象主要用于基本类型和字符串之间的转换 123456789基本类型---&gt;字符串 1、基本数据类型+"" 2、用String类中的静态方法 valueOf(基本类型数值) 3、用Integer方法的 valueOf(基本数据类型)字符串--&gt;基本类型 1、使用包装类中的静态方法 xxx parseXxx("xxx类型的字符串") 注意：只有Character类型没有该方法 2、如果字符串被Integer进行对象的封装，可使用另一个非静态的方法 intValue(); 将一个Integer对象转成基本数据类型值 进制转换 整数具备不同的进制体现 十进制–&gt;其他进制 1234Integer.toBinaryString(); //转换二进制Integer.toOctalString(); //转换八进制Integer.toHexString(); //转换十六进制Integer.toString(数，进制数); //转换任意进制 其他进制–&gt;十进制 1Integer.parseInt(&quot;需要转换的数据&quot;,进制数) 观察下面代码运行结果 1234567Integer a = new Integer("3");Integer b = new Integer(3);System.out.println(a==b); //falseSystem.out.println(a.equals(b)); //trueInteger c = new Integer(100);System.out.println(a.compareTo(c)); //-1System.out.println(c.compareTo(a)); //1 自动装拆箱 简化书写 1啊 注意事项 14 14分 练习 对一个字符串中的数值进行从小到大的排序 思路： 1，排序，我很熟。可是我只熟int。 2，如何获取到这个字符串中的这些需要排序的数值？？？发现这个字符串中其实都是空格来对数值进行分隔的。所以就想到用字符串对象的切割方法将大串变成多个小串。 3，数值最终变成小字符串，怎么变成一个int数呢？？？字符串–&gt;基本类型 可以使用包装类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class WrapperTest &#123; private static final String SPACE_SEPARATOR = " "; public static void main(String[] args) &#123; String numStr = "20 78 9 -7 88 36 29"; System.out.println(numStr); numStr = sortStringNumber(numStr); System.out.println(numStr); &#125; public static String sortStringNumber(String numStr) &#123; //1,将字符串变成字符串数组。 String[] str_arr = stringToArray(numStr); //2,将字符串数组变成int数组。 int[] num_arr = toIntArray(str_arr); //3,对int数组排序。 mySortArray(num_arr); //4,将排序后的int数组变成字符串。 String temp = arrayToString(num_arr); return temp; &#125; public static String arrayToString(int[] num_arr) &#123; StringBuilder sb = new StringBuilder(); for(int x = 0; x&lt;num_arr.length; x++)&#123; if(x!=num_arr.length-1) sb.append(num_arr[x]+SPACE_SEPARATOR); else sb.append(num_arr[x]); &#125; return sb.toString(); &#125; public static void mySortArray(int[] num_arr) &#123; Arrays.sort(num_arr); &#125; public static int[] toIntArray(String[] str_arr) &#123; int[] arr = new int[str_arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = Integer.parseInt(str_arr[i]); &#125; return arr; &#125; public static String[] stringToArray(String numStr) &#123; String[] str_arr = numStr.split(SPACE_SEPARATOR); return str_arr; &#125;&#125; ​]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-String及相关类]]></title>
    <url>%2F2018%2F05%2F08%2FJava-String%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[特点 字符串是一个初始化的对象 字符串一旦初始化就不可以被改变 12345678910111213//创建一个字符串对象在常量池中//池中没有就建立，有就使用String str = "abc";String str1 = "abc";System.out.println(str == str1); //true//str2 是在堆内存中创建的一个String对象//创建两个对象一个new一个字符串对象在堆内存中String str2 = new String("abc");System.out.println(str == str2); //falseSystem.out.println(str.equals(str2)); //true//String类中的equals方法复写了Object中的//其实就是比较字符串内容 构造函数12345678910111213String str = new String();//等价于 String str = "";//不等价于 String str = null; byte[] arr = &#123;97,66,67,68&#125;;String s1 = new String(arr);System.out.println("s1 = "+s1);//运行结果：s1 = aBCDchar[] chars = &#123;'q','w','e','r','t'&#125;;String s2 = new String(chars,1,3);System.out.println("s2 = "+s2);//运行结果：s2 = wer; 常见功能获取 获取字符串长度 1int length(); 根据位置获取字符 1char charAt(int index); 根据字符获取在字符串中第一次出现的位置 1234int indexOf(int ch);int indexOf(int ch,int fromIndex);//从指定位置查找int indexOf(String str);int indexOf(String str,int fromIndex); 根据字符获取在字符串中最后一次出现的位置 1234int lastIndexOf(int ch);int lastIndexOf(int ch,int fromIndex); //从指定位置反向搜索int lastIndexOf(String str);int lastIndexOf(String str,int fromIndex); 获取字符串的一部分，也叫子串 123注意：起始索引包括，结束索引不包括String substring(int beginIndex,int endIndex);String substring(int beginIndex);​ 转换 将字符串转换成字符串数组（字符串的切割） 1String[] split(String regex); 涉及正则表达式 将字符串转换成字符数组 1char[] toCharArray(); 将字符串转换成字节数组 12byte[] getBytes();注意：一个汉字占两个字节，且这两个字节的最高位都是1 将字符串的字母转成大小写 12String toUpperCase(); 转大写String toLowerCase(); 转小写 将字符串内容替换 12String replace(char oldch,char newch);String replace(String s1,String s2); 将字符串两端空格去除 1String trim(); 将字符串进行连接 1String concat(String); 判断 判断两个字符串内容是否相同 123boolean equals(Object obj);忽略大小写比较内容：boolean equalsIgnoreCase(String str); 字符串是否包含指定字符串 1boolean contains(String str); 字符串是否以指定字符串开头，或者结尾 12boolean startsWith(String);boolean endWith(String); ​ 比较 按字典顺序比较两个字符串 1compareTo(String); intern方法 返回字符串对象的规范化表示形式 12String s1 = new String("abc");String s2 = s1.intern(); ​ 练习题练习一 1、计算一个子串在整串中出现的次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Basic_1 &#123; public static void main(String[] args)&#123; String str = "nbaasdnbaanbanba"; String key = "nba"; //第一种方法会生成较多常量 int count = getKeyStringCount(str,key); //第二种方法较好 int count1 = getKeyStringCount_2(str,key ); System.out.println(count); System.out.println(count1); &#125; private static int getKeyStringCount_2(String str, String key) &#123; int count = 0; int index = 0; //从index处开始判断是否还含有子串 while((index = str.indexOf(key, index))!=-1)&#123; count++; //index加上刚才查找到的子串长度，从这里继续查 index = index + key.length(); &#125; return count; &#125; /** * 获取子串在整串中出现的个数 * @param str * @param key * @return */ private static int getKeyStringCount(String str, String key) &#123; //定义计数器 int count = 0; //记录变量key出现的位置 int index = 0; //循环判断是否还含有子串，有则加1 while((index = str.indexOf(key))!=-1) &#123; //将字符串切割掉刚才查找过的位置 str = str.substring(index+key.length()); count ++; &#125; return count; &#125;&#125; 练习二 2、模拟一个与trim功能一致的方法（去除字符串两边空白） 1234567891011121314151617181920public class Basic_4 &#123; public static void main(String[] args)&#123; String str = " as s "; System.out.println(str); str = myTrim(str); System.out.println(str); &#125; public static String myTrim(String str)&#123; int start = 0,end = str.length()-1; while (start&lt;=end &amp;&amp; str.charAt(start)==' ')&#123; start++; &#125; while (start&lt;=end &amp;&amp; str.charAt(end)==' ')&#123; end--; &#125; //注意：该方法结果包括起始索引，不包括结束索引 str = str.substring(start, end+1); return str; &#125;&#125; ​ StringBuffer类 StringBuffer：就是字符串缓冲区，用于存储数据的容器 可变数组原理：初始为16，超出后，长度翻倍至32，不够再增加 特点 1、长度可变的 2、可以存储不同类型数据 3、最终要转成字符串使用 4、可以对字符串修改 功能 1、添加 12StringBuffer append(data);StringBuffer insert(index,data); 2、删除 12StringBuffer delete(start,end);//删除头，不删除尾StringBuffer delete(index); //删除指定位置元素 3、查找 123char charAt(index);int indexOf(string);int lastOf(string); 4、修改 12StringBuffer replace(start,end,string);void setCharAt(index,chars); ​ StringBuilder类 JDK1.5后出现了功能和StringBuffer一模一样的对象，就是StringBuilder 不同的是： StringBuffer 是线程同步的，建议多线程使用 StringBuilder是线程不同步的，建议单线程使用，提高效率 JDK升级： 简化书写 增加效率 增加安全性 练习 将一个 int 数组转字符串 1234567891011public static String arrayToString(int[] arr)&#123; StringBuilder sb = new StringBuilder(); sb.append('['); for (int i = 0; i &lt; arr.length; i++) &#123; if(i!=arr.length-1) sb.append(arr[i]+','); else sb.append(arr[i]+']'); &#125; return sb.toString(); &#125; 针对本题，使用String和StringBuilder的区别？ 使用String每次变化都会产生一个新的字符串常量池中的一个成员 使用StringBuilder是不断的把字符串变成数组往容器里装]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-主题美化]]></title>
    <url>%2F2018%2F05%2F08%2FHexo-%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[博客搭建已经好久了，这段时间对next主题也根据个人的意愿进行了一些美化，就在这里记载下来 首页不显示全文 进入hexo博客项目的themes/next目录 打开_config.yml文件（主题配置文件） 搜索”auto_excerpt” 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 将enable的值从false改为true，再 hexo g hexo d就可以了 增加搜索功能 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑站点配置文件（hexo博客项目下的config_yml） 12345search: path: search.xml field: post format: html limit: 10000 博客里使用 Ctrl + F 进行搜索 添加顶部加载条 打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: 12&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 标签图标替换 将标签 # 更换为 修改模板 /themes/next/layout/_macro/post.swig12搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 鼠标点击小红心 将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 链接文本设置为蓝色 将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。 找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 访问量及阅读统计为NexT主题添加文章阅读量统计功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-多线程]]></title>
    <url>%2F2018%2F05%2F05%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述 进程：计算机中的程序关于某数据集合的一次运行活动，是系统进行资源分配和调度的基本单位。 线程：就是进程中的一个负责程序执行的控制单元（执行路径）。 一个进程中可以有多个执行路径，称之为多线程。 一个进程中至少要有一个线程 开启多个线程是为了同时运行多部分代码 每一个线程都有自己运行的内容，这个内容可以称为线程要执行的任务 利弊 多线程操作，可以让多个任务并行执行，a任务等待硬盘响应时，让b任务去用cpu，所以，多线程不能提高单任务的运行速度，但是可以提高多个可以并发的任务速度。 好处：解决多部分同时运行的问题 弊端：线程过多会导致效率的降低 JVM多线程分析 JVM启动时就启动了多个线程，至少有两个可以分析出来 1.执行main函数的线程 该线程的任务代码都定义在main函数中 2.负责垃圾回收的线程 创建线程创建方式一 继承 Thread 类 1、定义一个类继承 Thread 类 2、必须覆盖 Thread 类的 run 方法 3、直接创建 Thread 的子类对象创建线程 4、调用 start 方法开启线程并调用线程的任务 run 方法执行 12345678910111213141516171819202122232425262728293031323334/*创建线程的目的是开启一条执行路径，去运行指定的代码和其他代码同时运行而运行的代码就是这个执行路径的任务JVM创建的主线程的任务都定义在主函数中而自定义的线程，他的任务在哪儿？Thread类用于描述线程，线程是需要任务的，所以Thread类也对任务的描述这个任务就通过Thread类中的run方法来体现也就是说，run方法就是封装自定义线程运行任务的函数，run方法中定义就是线程要运行的任务代码*/public class Demo extends Thread&#123; private String name; public Demo(String name)&#123; this.name = name; &#125; public void run()&#123; show(); &#125; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.println(name+&quot;...i:&quot;+i); &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(&quot;小白&quot;); Demo b = new Demo(&quot;black&quot;); a.start(); b.start(); //a.run(); //b.run(); &#125;&#125; 在上述代码的结尾，调用run和start函数有什么区别？ 调用start函数是多线程的，调用run函数还是按顺序主线程进行的 线程名称 想要展示出当前运行对象线程名称需要使用Thread类的currentThread方法 123456789101112131415161718192021222324252627public class Demo extends Thread&#123; private String name; public Demo(String name)&#123; super(); this.name = name; //super(name); &#125; public void run()&#123; show(); &#125; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.print(name+&quot;...i:&quot;+i); System.out.println(&quot;ThreadName&quot;+Thread.currentThread().getName()); &#125; &#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(&quot;小白&quot;); Demo b = new Demo(&quot;black&quot;); a.start(); b.start(); System.out.println(&quot;here&quot;+&quot;...&quot;+Thread.currentThread().getName());// a.run();// b.run(); &#125;&#125; 运行后可以试着4.5行注释掉，6行解除注释试一下，发现可以自己给线程名称赋值了 图解 开启了多线程后，栈内存就和之前不一样了，以前面代码为示例 如果在上文倒数第三行加上一句代码“System.out.println(4/0);” 观察运行结果，发现main函数已经抛出异常终止了，其余两线程仍能正常进行 线程的状态 创建方式二 实现Runnable接口 1、定义类实现Runnable接口 2、覆盖接口中的run方法，将编程的任务代码封装到run方法中 3、通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递 4、调用线程对象的start方法开启线程 第三步的原因 因为线程的任务都封装在Runnable接口子类对象的run方法中，所以要在线程对象创建时就必须明确要运行的任务 123456789101112131415161718192021222324public class Demo implements Runnable&#123; //准备扩展Demo类的功能，让其中的内容可以作为多线程执行 //通过接口的方式完成 private String name; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.println(Thread.currentThread().getName()+&quot;...&quot;+i); &#125; @Override public void run() &#123; show(); &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(); Demo b = new Demo(); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); System.out.println(&quot;here&quot;+&quot;...&quot;+Thread.currentThread().getName()); &#125;&#125; 方式二细节方式二优点 实现Runnable接口的好处 1、将线程的任务从线程的子类中分离出来，进行了单独的封装，按照面向对象的思想将任务封装成了对象 2、避免了Java单继承的局限性 所以创建线程的第二种方式比较常用 卖票示例 在火车站一共有100张票，4个窗口同时卖票，用多线程来描述 运行图中左侧代码后发现，并不是想象中的卖100张，而是变成了4*100张，可以选择将ticket类中的num值变成静态变量，但这不是最好的选择。 另外还有人说可以不在堆中创建那么多的对象，只创建一个对象，进行4次线程开启，这是不可取的，多次启动一个线程是非法的。 12345678910111213141516171819202122 class Ticket implements Runnable&#123; private int num = 100; public void run()&#123; while(true)&#123; if(num&gt;0) System.out.println(num--); &#125; &#125; &#125; class TicketDemo&#123; public static void main(String[] args)&#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 通过继承的方式创建没有达到我们的目的，于是就采用上述代码中接口的方式创建 线程安全隐患 以车站卖票为示例，如果当车票只剩一张时，t1进入临时堵塞状态，有执行资格不具备执行权，推给t2执行，t2也临时堵塞一下，继续往后推，然后假设t3，t4也是临时堵塞，那他们现在都具备执行资格，没有执行权，然后t1卖出一张票，票数为0，但是t2.3.4都已经进入循环，可以卖票，于是分别卖出了第0.-1.-2张票。这对于铁路局来说是不允许的，有安全隐患。 有人说为什么我运行很多次都没有出现这种错误那，因为这只是有一定可能发生的，为了看起来更清晰，可以人为的方式，使产生安全隐患概率增加 12345678910111213141516class Ticket implements Runnable&#123; private int num = 100; public void run()&#123; while(true)&#123; if(num&gt;0)&#123; try&#123; Thread.sleep(10); &#125;catch(InterruptedException)&#123; //解决异常代码 &#125; System.out.println(num--); &#125; &#125; &#125;&#125; &#125; 将ticket类改成这样，在运行主类，发现会出现之前所说的安全隐患 线程安全问题产生原因 1、多个线程在操作共享数据 2、操作共享数据的线程代码有多条 当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算，就会导致线程安全问题的产生 解决思路（同步） 就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程不可以参与运算的，必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算 在Java中用同步代码块就可以解决这个问题 1234同步代码块格式：synchronized(对象)&#123; 需要被同步的代码；&#125; 所以更改代码后变为这样 123456789101112131415161718class Ticket implements Runnable&#123; private int num = 100; Object obj = new Object(); public void run()&#123; while(true)&#123; synchronized(obj)&#123; if(num&gt;0)&#123; try&#123; Thread.sleep(10); &#125;catch(InterruptedException)&#123; //解决异常代码 &#125; System.out.println(num--); &#125; &#125; &#125; &#125; &#125; 这次再去运行一下发现不会有问题 这很像锁，可以比喻成火车上的卫生间，一个人进去后，门锁上，门上有提示“有人”，别人就进不来，只有里面的人出去才可以。 同步的好处：解决了线程的安全问题 同步的弊端：相对降低了效率，因为同步外的线程都会判断同步锁同步前提 同步的前提：同步中必须有多个线程并使用同一个锁 1234567891011 private int num = 100; public void run()&#123; Object obj = new Object(); //注意：上面这句代码的位置和之前不同 while(true)&#123; synchronized(obj)&#123; //代码 &#125; &#125; &#125;&#125; 运行上面的代码后发现并没有解决安全问题，是因为这样写相当于有四个锁，把二三行代码换位置即可 同步函数 需求：两个储户去银行存款，每次100，存三次 1234567891011121314151617181920212223242526272829303132333435public class Bank &#123; private int sum; //private Object obj = new Object(); public synchronized void add(int num) &#123; //synchronized(obj)&#123; sum = sum + num; try &#123; //延时，增加出错可能性 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(sum); //&#125; &#125;&#125;public class Cus implements Runnable&#123; private String name; public Bank b = new Bank(); @Override public void run() &#123; for (int i=0; i&lt;3; i++) &#123; b.add(100); &#125; &#125;&#125;public class BankDemo &#123; public static void main(String[] args)&#123; Cus a = new Cus(); Thread t1 = new Thread(a); Thread t2 = new Thread(a); t1.start(); t2.start(); &#125;&#125; “多个线程在操作共享数据（sum），操作共享数据代码有多条（不算trycatch两条）”这两点都符合，所以有线程安全隐患 像上面这种情况，可以使用同步代码块，不过还有更简洁的方式就是在函数中加上同步关键字 验证同步函数锁 同步函数锁固定是this，同步代码块锁是任意的对象 开发中建议使用同步代码块 下面是验证时的代码（以双线程卖票为示例）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Ticket implements Runnable &#123; private int num = 100; boolean flag = true; public void run() &#123; if (flag) &#123; while (true) &#123; synchronized (this) &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;..emmm..&quot; + num--); &#125; &#125; &#125; &#125; else &#123; while (true) show(); &#125; &#125; public synchronized void show() &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;......&quot; + num--); &#125; &#125;&#125;public class SynFunctionLockDemo &#123; public static void main(String[] args)&#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t.flag = false; t2.start(); &#125;&#125; 验证静态同步函数锁 静态的同步函数使用的锁是 该函数所属的字节码文件对象 可以用getClass方法获取，也可以用 当前类名.class 表示 验证的代码和上面的大同小异，将this改为this.getClass或者Ticket.class再试试 单例模式涉及的多线程问题安全隐患分析 会出现安全隐患的是懒汉式，也就是延迟加载单例模式 123456789public class Single2 &#123; private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null) s = new Single2(); return s; &#125;&#125; 仔细想一下，他符合了会出现隐患的两个因素，线程0在进行（s==null）判断后，进入临时堵塞状态，然后线程1进行null的判断，进入临时堵塞状态。这时线程0创建了s对象，返回s，线程1又创建了一个对象，现在就有两个对象，不能保证唯一了，这就出现大问题了。 解决方法 加同步代码块解决安全问题，外面再加一次判断是解决效率问题 12345678910111213public class Single2 &#123; private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null)&#123; synchronized(Single2.class)&#123; if(s==null) s = new Single2(); &#125; &#125; return s; &#125; &#125; 死锁 常见情景之一：同步的嵌套 12 run函数里拿着obj的锁想进this的锁，show函数里拿着this锁想进obj 简单死锁代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MyLock &#123; //写两个锁 public static final Object MyLockA = new Object(); public static final Object MyLockB = new Object();&#125;import static bxdDay_13.MyLock.MyLockA;import static bxdDay_13.MyLock.MyLockB;public class DeadLock implements Runnable&#123; public boolean flag; //有参构造函数，创建对象时附带flag状态 public DeadLock(boolean flag)&#123; this.flag = flag; &#125; @Override public void run() &#123; if (flag)&#123; synchronized (MyLockA)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;if LockA&quot;); synchronized (MyLockB)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;if LockB&quot;); &#125; &#125; &#125;else &#123; synchronized (MyLockB)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;else LockB&quot;); synchronized (MyLockA)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;else LockA&quot;); &#125; &#125; &#125; &#125;&#125;public class DeadLockTest &#123; public static void main(String[] args)&#123; DeadLock a = new DeadLock(true); DeadLock b = new DeadLock(false); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); &#125;&#125; 运行上面的代码，观察结果,线程1拿到了B锁，线程2拿到了A锁，他们都想继续，可是互不相让，死锁了 12Thread-1 else LockBThread-0 if LockA 如果试了多次都是没有成功死锁，那就在 if语句 及 else语句 后面各加一句 while(true) 线程间通信 多个线程在处理资源，但是任务却不同 同步前提：多个线程使用同一个锁 接下来用一个例子演示一下 需求：有一个资源库存放数据，一条线程在向里面输入，还有一条在向外输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//资源类public class Resource &#123; public String name; public String sex;&#125;//输入类public class Input implements Runnable &#123; Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; synchronized (r) &#123; if (x == 0) &#123; r.name = &quot;小白&quot;; r.sex = &quot;女女女&quot;; &#125; else &#123; r.name = &quot;black&quot;; r.sex = &quot;malemale&quot;; &#125; x = (++x) % 2; &#125; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; synchronized (r) &#123; System.out.println(&quot;name:&quot; + r.name + &quot;...&quot; + &quot;sex:&quot; + r.sex); &#125; &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args)&#123; //创建资源 Resource r = new Resource(); //创建任务 Input in = new Input(r); Output out = new Output(r); //创建线程，执行路径 Thread t1 = new Thread(in); Thread t2 = new Thread(out); //开启线程 t1.start(); t2.start(); &#125;&#125; 上面的代码中输入设置的是输入两个人名，需要注意的地方是，输入和输出类中加的锁是一样的，都是r，这个在测试类中，创建in、out对象时，要给他们传一样的参数。否则同步锁无用！ 但是这样的代码运行后还是不太好，因为输出的都是大片相同的人名，想让他们输入一个就输出一个，就需要使用线程的等待唤醒机制了。 等待唤醒机制 涉及方法 wait()：让线程处于冻结状态，被wait的线程会被存储到线程池中 notify()：唤醒线程池中的一个线程（任意） nitifyAll()：唤醒线程池中的所有线程 这些方法都必须定义在同步中，因为这些方法是用于操作线程状态的方法，必须要明确到底操作的是哪个锁上的线程 观察api文档后，为什么操作线程的方法wait、notify、notifyAll定义在Object类中那？ 因为这些方法是监视器的方法，监视器其实就是锁，锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//资源类public class Resource &#123; public String name; public String sex; public boolean flag = false;&#125;//输入类public class Input implements Runnable &#123; Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; synchronized (r) &#123; if (r.flag) &#123; try &#123; r.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (x == 0) &#123; r.name = &quot;小白&quot;; r.sex = &quot;女女女&quot;; &#125; else &#123; r.name = &quot;black&quot;; r.sex = &quot;malemale&quot;; &#125; r.flag = true; r.notify(); &#125; x = (++x) % 2; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; synchronized (r) &#123; if (!r.flag) &#123; try &#123; r.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;name:&quot; + r.name + &quot;...&quot; + &quot;sex:&quot; + r.sex); r.flag = false; r.notify(); &#125; &#125; &#125;&#125; 思路：输入数据之前判断一下是否有数据，如果有数据，控制输入的线程等待，先让控制输出的线程输出，输出数据后，将flag更改为false，意味着资源中数据为空，可以继续输入，然后再将控制输入的线程唤醒,自己（控制输出的线程）等待。这样就可以实现输入一个数据再输出一个数据了。 注意：输入输出的锁都是 r，等待唤醒中的线程池都是基于这个锁（也就是 r） 代码优化 上面的代码虽然最后实现了功能，但是封装性差,我们可以把输入，输出的方法定义在资源类中，在输入输出类中调用输入输出的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//资源类public class Resource &#123; private String name; private String sex; private boolean flag = false; //输入方法 public synchronized void set(String name,String sex)&#123; if (this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name; this.sex = sex; this.flag = true; this.notify(); &#125; //输出方法 public synchronized void out()&#123; if (!this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;name:&quot; + name + &quot;...&quot; + &quot;sex:&quot; + sex); this.flag = false; this.notify(); &#125;&#125;//输入类public class Input implements Runnable &#123; private Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; if (x == 0) &#123; r.set(&quot;小白&quot;,&quot;女女女&quot; ); &#125; else &#123; r.set(&quot;black&quot;, &quot;malemale&quot;); &#125; x = (++x) % 2; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; private Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; r.out(); &#125; &#125;&#125; 对共享资源修改的语句都写在了资源类中，可以给他们加同步锁，但是还是在方法中加上同步关键字看上去更简洁，这样他们加的锁还是同一个锁—&gt; this 。 生产者消费者问题 假设生产者生产产品，消费者消费产品，和上面进出资源的问题差不多 问题一 这里直接开始4个线程的，两个生产者，两个消费者，运行一下，会发现有错误，比如一个生产者生产完一件产品，消费者连着两次消费这一件产品。这类问题产生的原因是什么那？ t0、t1是生产者 t2、t3是消费者，让我们按照代码的顺序走一遍。 t0进行判断，生产产品（1），t0等待，t1进行判断，t1等待。t2进行判断，消费产品（1），t2等待，t3进行判断，t3等待。唤醒t0，t0没有进行判断，生产产品（2），t0等待。然后需要唤醒一个线程，但是这时线程池中有三个在等待，如果唤醒的是t1，t1没有进行判断直接生产产品（3），t1等待，唤醒t2，t2消费了产品（3），如果再唤醒t3，t3没有进行判断，就会再消费产品（3） 问题1产生原因：if判断标记，只有一次，会导致不该运行的线程运行了，出现了数据错误的情况 解决方法：将资源类中的输入输出方法的 if 判断改为 while 循环，这样就不会唤醒后跳过判断了，不过这样又会产生一个新的问题 问题二 问题2：4个线程都处在等待状态，没人去唤醒他们 产生原因：notify只能唤醒一个线程，如果本方唤醒本方，无意义，而且while+notify会导致死锁 解决办法：将资源类中的输入输出方法的唤醒改为全部唤醒（notifyAll）1234567891011121314151617181920212223242526272829303132333435//这里就只贴上资源类的代码了，其他类代码的写法和上面差不多//还需要有生产者类，消费者类 实现Runnable接口，和Test类//资源类public class Resource &#123; private String name; private int count = 1; private boolean flag = false; public synchronized void set(String name)&#123; while (this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); this.flag = true; this.notifyAll(); &#125; public synchronized void out()&#123; while (!this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); this.flag = false; this.notifyAll(); &#125;&#125; 问题三 解决了第二个问题后，已经不会报错了，但是还有些小弊端，使用notifyAll方法的时候会唤醒所有等待线程，但是如果唤醒了本方等待线程会降低效率，能不能只唤醒对方线程那？ 解决方法：使用jdk1.5新特性中的Lock Condition，可以创建多个监视器，该问题中，创建两个即可。关于Lock，Condition可以看该文章偏靠后的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;//资源类public class Resource &#123; private String name; private int count = 1; private boolean flag = false; public Lock lock = new ReentrantLock(); //通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者 public Condition producer_con = lock.newCondition(); public Condition consumer_con = lock.newCondition(); public void set(String name)&#123; //生产者 t0 t1 lock.lock(); try &#123; while (flag) &#123; try &#123; //该生产者线程进入等待状态 producer_con.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); flag = true; //唤醒随机一个消费者 consumer_con.signal(); &#125;finally &#123; //如果抛出异常，必须将关锁写在finally中 lock.unlock(); &#125; &#125; public void out()&#123; //消费者 t2 t3 lock.lock(); try &#123; while (!flag) &#123; try &#123; //该消费者进入等待状态 consumer_con.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); flag = false; //唤醒随机一个生产者 producer_con.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; locks包Lock接口 java.util.concurrent.locks.Lock Lock替代了同步代码块或者同步函数，将同步的隐式锁操作变成显式锁操作，同时更为灵活，可以一个锁加上多个监视器。 方法： lock()：获取锁 unlock()：释放锁，通常需要定义在finally代码块中 1234567//同步代码块对于锁的操作是隐式的Object obj = new Object();void show()&#123; synchronized(obj)&#123; ...code... &#125;&#125; 12345678//同步和锁被封装成了对象，并将操作锁的隐式方式定义到了该对象中//将隐式动作变为了显式动作。Lock lock = new ReentrantLock();void show()&#123; lock.lock();//获取锁 ...code... lock.unlock();//释放锁&#125; 如果上面代码第六行位置会抛异常的话，一定要将释放锁写在finally里123456789Lock lock = new ReentrantLock(); void show()&#123; lock.lock();//获取锁 try&#123; ...code... &#125;finally&#123; lock.unlock();//释放锁 &#125; &#125; Condition接口 Condition接口出现替代Object中的wait notify notifyAll等方法，将他们单独进行了封装，变成了Condition监视器对象，可以与任意锁进行组合 方法： await()：等待 signal()：唤醒 signalAll()：全部唤醒 1234567891011121314151617//旧版功能演示//在没有Lock，Condition之前，生产消费者问题只能创建一个监视器Object obj = new Object();synchronzied(obj)&#123; obj.wait(); obj.notify(); obj.notifyAll();&#125;//新版功能演示Lock lock = new ReectrantLock();//生产者的锁Condition producter_con = lock.newCondition();//消费者的锁Condition consumer_con = lock.newCondition();producter_con.await();producter_con.signal();producter_con.signalAll(); 范例123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class BoundedBuffer &#123; final Lock lock = new ReentrantLock();//锁对象 final Condition notFull =lock.newCondition();//写线程条件 final Condition notEmpty = lock.newCondition();//读线程条件 final Object[] items = new Object[100];//缓存队列 //下面是操作上面数组的变量（前两个指针） int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/; public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length)//如果队列满了 notFull.await();//阻塞写线程 items[putptr] = x;//赋值 if (++putptr == items.length) putptr = 0;//如果写索引写到队列的最后一个位置了，那么置为0 ++count;//个数++ notEmpty.signal();//唤醒读线程 &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0)//如果队列为空 notEmpty.await();//阻塞读线程 Object x = items[takeptr];//取值 if (++takeptr == items.length) takeptr = 0;//如果读索引读到队列的最后一个位置了，那么置为0 --count;//个数-- notFull.signal();//唤醒写线程 return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 这是一个处于多线程工作环境下的缓存区，缓存区提供了两个方法，put和take，put是存数据，take是取数据，内部有个缓存队列，具体变量和方法说明见代码，这个缓存区类实现的功能：有多个线程往里面存数据和从里面取数据，其缓存队列(先进先出后进后出)能缓存的最大数值是100，多个线程间是互斥的，当缓存队列中存储的值达到100时，将写线程阻塞，并唤醒读线程，当缓存队列中存储的值为0时，将读线程阻塞，并唤醒写线程，这也是ArrayBlockingQueue的内部实现。 下面分析一下代码的执行过程： 1、一个写线程执行，调用put方法； 2、判断count是否为100，显然没有100； 3、继续执行，存入值； 4、判断当前写入的索引位置++后，是否和100相等，相等将写入索引值变为0，并将count+1； 5、仅唤醒读线程阻塞队列中的一个； 6、一个读线程执行，调用take方法； 7、…… 8、仅唤醒写线程阻塞队列中的一个 如果不用多个 Condition ，只有一个Condition或者使用的同步代码块的内容时，当存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。 线程终止wait和sleep区别 wait可指定也可不指定时间，sleep必须指定时间 同步中时，对cpu的执行权和锁的处理不同 wait：释放执行权，释放锁 sleep：释放执行权，不释放锁 终止线程方式 停止线程： stop方法：不推荐使用 run方法结束 怎么控制线程中的任务结束那？ 任务中都会有循环结构，只要控制住循环就可以结束任务，控制循环通常就用定义标记来完成 123456789101112//通过在主函数中调用setFlag方法，即可终止线程public class StopThread implements Runnable&#123; private boolean flag = true; public void run()&#123; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; public void setFlag()&#123; flag = false; &#125;&#125; 但是使用这种方法也有一定的弊端，如果线程处于冻结状态无法读取标记，程序就不能停下来了 1234567891011//这样的程序无法终止public synchronized void run()&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; 可以使用interrupt()方法将线程从冻结状态强制恢复到运行状态中来，让线程具备cpu的执行资格，但是强制动作会发生InterruptedException异常，记得要处理 123456789101112131415161718192021222324252627282930313233343536373839public class StopThread implements Runnable&#123; private boolean flag = true; public synchronized void run()&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); //也可以选择在这里更改标记 //flag = false; &#125; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; public void setFlag()&#123; flag = false; &#125;&#125;public class StopThreadDemo &#123; public static void main(String[] args)&#123; StopThread s = new StopThread(); Thread t1 = new Thread(s); Thread t2 = new Thread(s); t1.start(); t2.start(); int num = 1; for(;;)&#123; if(++num == 50)&#123; //这里加上了interrupt方法 t1.interrupt(); t2.interrupt(); s.setFlag(); break; &#125; System.out.println(Thread.currentThread().getName()); &#125; &#125;&#125; 守护线程 setDaemon可以将线程变为守护线程（后台线程） 后台线程在运行时与前台线程无差别，前台线程终止时必须手动终止，如果前台线程都终止了，后台线程自动终止线程小方法join join方法也会抛出中断异常1234567891011121314//有线程t0、t1t0.start();t0.join();t1.start();System.out.println(&quot; &quot;);//运行结果一定是t0线程运行完，//运行main线程，再运行t1线程//情况2t0.start();t1.start();t0.join();System.out.println(&quot; &quot;); //运行结果：t0，t1互相抢占cpu，main等t0执行完再执行 线程优先值 可以给线程分配不同优先级的值，会让他们在执行中被执行几率增加 123456//t0为线程名t0.setPriority(Thread.MAX_PROIORITY);//为了方便，设置三个final值//MAX_PROIORITY = 10//MIN_PROIORITY = 0;//NORM_PROIORITY = 5; 两道多线程面试题 判断下面的程序是否能成功运行，如果不能，报错在哪一行 123456public class Test implements Runnable&#123; public void run(Thread t)&#123;&#125;&#125;//最后报错在第一行，第二行是子类的特有方法//在这个接口的实现类中没有覆盖run方法//报错解决：使用abstract修饰类或者覆盖run方法 判断下面程序，运行结果是什么？123456789101112131415public class ThreadTest &#123; public static void main(String[] main)&#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;我是任务里面的 &quot;); &#125; &#125;)&#123; public void run() &#123; System.out.println(&quot;我是子类里面的 &quot;); &#125; &#125;.start(); &#125;&#125;//现在的运行结果是“我是子类里面的”//如果注释掉8.9.10行，结果是“我是任务里面的”]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-异常]]></title>
    <url>%2F2018%2F05%2F03%2FJava-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[概述 异常：运行时期发生的不正常情况 在java中用类的形式对不正常情况进行了描述和封装对象 描述不正常的情况的类，被称为异常类 以前正常流程代码和问题处理代码相结合，现在将正常流程代码、问题处理代码分离，提高阅读性 其实异常就是java通过面向对象的思想将问题封装为对象，用异常类对其描述 不同类用问题用不同的类进行具体的描述，比如角标越界，空指针等等。 体系 问题很多，意味着描述的类也很多，将其共性进行向上抽取，形成了异常体系 最终问题就分成了两大类 Throwable：（直译：可抛的）问题发生应该就可以抛出，让调用者知道并处理 1、一般不可处理的 Error 2、可以处理的 Exception 该体系的特点就在于 Throwable 及其所有的子类都具有可抛性 可抛性是怎么体现的那？ 通过throws throw 这两个关键字所操作的类和对象都具备可抛性 该体系特点： 子类的后缀名都是用其父类名作为后缀，阅读性很强 Error JVM抛出的严重性问题，这种问题发生一般不针对性处理，直接修改程序 123456public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[1024*1024*800]; //java.lang.OutOfMemoryError: Java heap space &#125;&#125; Exception 分为两种： 编译时受检测异常：Exception和其子类都是，除了特殊子类RuntimeExcetion 这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。 编译不检测异常（运行时异常）：RuntimeExcetion和其子类 这种问题的发生，让功能无法继续，运算也无法进行，更多是因为调用的原因导致的，或者引发程序内部状态改变，导致的异常。这种问题一般不处理，直接编译通过，在运行时，调用者调用时引发异常从而程序强制停止，此时调用者即可对异常进行修正。 过程 运到识别的问题，对象进行封装 把问题抛给调用者 123456789101112131415161718public class Demo &#123; public int method(int[] arr,int index)&#123; if(arr == null) throw new NullPointerException(&quot;你咋空指针了&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;兄台，数组越界了，角标是：&quot;+index); return arr[index]; &#125;&#125;public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[3]; Demo d = new Demo(); d.method(arr, 30); &#125;&#125; 自定义异常 对于角标是整数不存在，可以用角标越界表示，对于负数角标的情况，准备用负数角标异常表示，但是这在Java中没有定义过，那就按照Java异常的创建思想，面向对象，将负数角标进行自定义描述，并封装成对象，这种自定义问题描述称为自定义异常。 注意：如果让一个类称为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性。才可以被两个关键字所操作 throws throw 12345678910111213141516171819202122232425262728 class FuShuIndexException extends Exception&#123; FuShuIndexException()&#123;&#125; FuShuIndexException(String msg)&#123; Super(msg); &#125; &#125; class Demo&#123; public int method(int[] arr,int index) throws FuShuIndexException&#123; if(arr==null) throw new NullPointerException(&quot;数组的引用不能为空&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;数组角标越界=&quot; + index); if(index &lt; 0) throw new FuShuIndexException(); return arr[index]; &#125; &#125; public class ExceptionDemo &#123; public static void main(String[] args) throws FuShuIndexException &#123; int[] arr = new int[3]; Demo d = new Demo(); d.method(arr, -1); &#125; &#125; 自定义的异常，要么继承Exception,要么继承RuntimeException 抛出 throw throw和throws区别： throws使用在函数上，抛出的是异常类，可以跑出多个，用逗号隔开 throw使用在函数内，抛出的是异常对象 捕捉 catch 可以对异常进行针对性处理的方式 12345678具体格式： try&#123; //需要被检测异常的代码 &#125;catch(异常类 变量)&#123; //该变量用于接收发生的异常对象 //真正处理该异常的代码 &#125;finally&#123; //一定会被执行的代码 &#125; 下面是演示代码 12345678910111213141516171819202122232425262728public class Demo &#123; public int method(int[] arr,int index)&#123; if(arr == null) throw new NullPointerException(&quot;你咋空指针了&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;兄台，数组越界了，角标是：&quot;+index); return arr[index]; &#125;&#125;public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[3]; Demo d = new Demo(); try &#123; int num = d.method(null, 30); System.out.println(num); &#125;catch (NullPointerException e)&#123; System.out.println(e.toString()); &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;message:&quot;+e.getMessage()); System.out.println(&quot;String:&quot;+e.toString()); //e.printStackTrace();//Jvm默认处理机制就是调用异常这个方法 System.out.println(&quot;越界&quot;); &#125;/*catch (Exception e)&#123; //多catch，父类的catch放在最下面 &#125;*/ &#125;&#125; finally代码块 除了在catch中强制关闭JVM的情况下，finally中的语句都会被执行 123456789101112131415161718/* 情况1： 运行结果：finally*/try &#123; //需要被检测异常的代码&#125;catch (NullPointerException e)&#123; //处理异常的代码 return;&#125;finally&#123; //通常用于关闭（释放）资源 System.out.println(&quot;finally&quot;);&#125;System.out.println(&quot;Over&quot;);/* 情况2：去掉第9行的return后，运行 结果：finally Over*/ try catch finally 代码组合特点 1、try catch finally 2、try catch（多个） 没有必要资源需要释放时，可以不用定义finally 3、try finally 异常无法直接处理，但是资源需要关闭 123456try&#123; //开启资源 throw new Exception;&#125;finally&#123; //关闭资源&#125; 异常处理原则 1、函数内部如果抛出需要检测的异常，函数上必须要声明，否则必须在函数内用trycatch捕捉，否则编译失败 2、如果调用到了声明异常的函数，要么trycatch，要么throws，否则编译失败 3、什么时候catch，什么时候throws那？ 功能内容可以解决，用catch 解决不了，用throws告诉调用者，由调用者解决 4、一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理，内部有几个需要检测的异常，就抛几个异常，抛出几个，就catch几个 异常应用 用Java描述老师上课，需要电脑，电脑会出现蓝屏冒烟两种故障 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class LanPingException extends Exception &#123; LanPingException(String msg)&#123; super(msg); &#125;&#125;public class MaoYanException extends Exception &#123; MaoYanException(String msg)&#123; super(msg); &#125;&#125; public class Computer &#123; private int state = 0; public void run() throws LanPingException, MaoYanException &#123; if (state == 1) throw new LanPingException(&quot;蓝屏&quot;); if (state == 2) throw new MaoYanException(&quot;冒烟&quot;); System.out.println(&quot;computer run&quot;); &#125; public void reset()&#123; state = 0; System.out.println(&quot;电脑重启&quot;); &#125;&#125;public class Teacher &#123; private String name; private Computer comp; public Teacher(String name)&#123; this.name = name; comp = new Computer(); &#125; public void prolect() throws MaoYanException&#123; try &#123; comp.run(); System.out.println(name+&quot;讲课&quot;); &#125;catch (LanPingException e)&#123; e.getMessage(); comp.reset(); prolect(); &#125;catch (MaoYanException e)&#123; System.out.println(e.toString()); practice(); throw e; &#125; &#125; public void practice()&#123; System.out.println(&quot;电脑坏了，大家练习&quot;); &#125;&#125;public class Demo &#123; public static void main(String[] args)&#123; Teacher t = new Teacher(&quot;cheng&quot;); try &#123; t.prolect(); &#125; catch (MaoYanException e) &#123; System.out.println(&quot;......&quot;); &#125; &#125;&#125; 数据库连接出现异常怎么解决那 123456789101112131415class NoAddException extends Exception&#123;&#125;void addData(Data d) throws NoAddException&#123; 连接数据库 try&#123; 添加数据，出现异常 &#125;catch(NoAddException e)&#123; //处理代码 throw new NoAddException(); &#125;finally&#123; 关闭数据库 &#125;&#125; 注意事项 1、子类在覆盖父类方法的时候，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常，或者该异常的子类 2、如果父类抛出多个异常，子类只能抛出父类异常的子集 简而言之：子类覆盖父类方法时，只能抛出父类异常或异常子类或子集 注意：若父类方法没抛出异常，子类覆盖时绝对不能抛出异常，只能try]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-Object类]]></title>
    <url>%2F2018%2F05%2F03%2FJava-Object%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类 Object ：所有类的根类 Object 是抽取而来的，具备着所有对象都具备的共性内容 常用的共性内容： equals 方法 hashCode 方法 getClass 方法 toString 方法equals方法 equals 实现对象上差别可能性最大的相等关系，即，对于任何非空引用值 x 和 y ，当且仅当 x 和 y引用同一个对象时，此方法才返回 true （x==y 具有值 true） 12345678910111213141516public class Person &#123; private int age; public Person(int age)&#123; this.age = age; &#125;&#125;public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); Person p2 = new Person(20); Person p3 = p1; System.out.println(p1==p2); System.out.println(p1.equals(p2)); System.out.println(p1.equals(p3)); &#125;&#125; equals 方法重写，比较成员变量值 123456789101112131415161718public class Person &#123; private int age; public Person(int age)&#123; this.age = age; &#125; /* 一般都会覆盖此方法，根据对象的特有内容，建立判断对象是否相同的依据 */ public boolean equals(Object obj)&#123;//会将参数中的对象进行向上转型 //为了提高程序鲁棒性，进行判断 if (!(obj instanceof Person))&#123; throw new ClassCastException(&quot;类型错误&quot;); &#125; //为了使用子类的私有方法，进行向下转型 Person p = (Person) obj; return this.age == p.age; &#125;&#125; hashCode方法 先演示一下功能，发现运行后的结果很相似，发现hashCode的结果是16进制地址值的10进制数。 1234567891011public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); System.out.println(p1); System.out.println(p1.hashCode()); System.out.println(Integer.toHexString(p1.hashCode())); //Person@1540e19d //356573597 //1540e19d &#125;&#125; hashCode可以进行重写，在person类中加入如下的代码，ObjectDemo运行的结果会发生变化 123456public int hashCode()&#123; return age; &#125; //Person@14 //20 //14 getClass方法 字节码文件是经过编译器预处理过的一种文件，是JAVA的执行文件存在形式，它本身是二进制文件，但是不可以被系统直接执行，而是需要虚拟机解释执行，由于被预处理过，所以比一般的解释代码要快，但是仍然会比系统直接执行的慢 人中抽出Person，class抽取出Class（字节码文件类名）12345678910public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); Person p2 = new Person(40); Class claz1 = p1.getClass(); Class claz2 = p2.getClass(); System.out.println(claz1.equals(claz2)); //true &#125;&#125; toString方法 这是一个改写字符串方法 1234567public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); System.out.println(p1); System.out.println(p1.getClass().getName()+&quot;@&quot;+Integer.toHexString(p1.hashCode())); &#125;&#125; 运行结果：Person@1540e19d Person@1540e19d 其实这就是没改写前方法的功能，我们也可以自己进行改写 123public String toString()&#123; return &quot;Person:&quot;+age; &#125; 这样改写后输出 p1 的结果就是 Person:20]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类]]></title>
    <url>%2F2018%2F04%2F27%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类概述 内部类 如其名，就是类的内部定义的一个类 内部类访问特点 内部类可以直接访问外部类的成员 外部类要访问内部类，必须建立内部类的对象 一般用于类的设计 分析事物时，发现该事物描述中还有事物，而且这个事物还在访问被描述的事物，这时就把含有的事物定义成内部类来描述 修饰符 如何直接访问外部类中的内部类的成员1234567891011121314public class Outer &#123; private int num = 3; public class Inner &#123; void show()&#123; System.out.println(&quot;num = &quot;+num); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; Outer.Inner in = new Outer().new Inner(); in.show(); &#125;&#125; static 如果内部类是静态的，该如何访问内部类方法123456789101112131415161718192021public class Outer &#123; private int num = 3; public static class Inner &#123; void show()&#123; System.out.println(&quot;num = &quot;+num); &#125; //如果内部类中定义了静态成员，该内部类必须也是静态的 static void fun()&#123; System.out.println(&quot;fun&quot;); &#125; &#125; &#125; public class Test &#123; public static void main(String[] args)&#123; //如果内部类是静态的，相当于一个外部类 Outer.Inner in = new Outer.Inner(); in.show(); //如果内部类是静态的，成员是静态的 Outer.Inner.fun(); &#125; &#125; 细节 观察如下代码判断运行结果 123456789101112131415161718192021public class Outer &#123; private int num = 3; public class Inner &#123; int num = 4; public void show()&#123; int num = 5; System.out.println(num); System.out.println(this.num); System.out.println(Inner.this.num); System.out.println(Outer.this.num); &#125; &#125; public void method()&#123; new Inner().show(); &#125; &#125;public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125; &#125; 结果是：5 4 4 3 为什么内部类能直接访问外部类中成员那？ 那是因为内部类持有了外部类的引用。 外部类名.this 局部内部类 内部类可以存放在局部位置上 内部类在局部变量位置上只能访问局部中被final修饰的局部变量12345678910111213141516171819public class Outer &#123; private int num = 3; public void method()&#123; //如果不加final，会报错 final int x = 9; public class Inner &#123; public void show()&#123; System.out.println(x); &#125; &#125; Inner in = new Inner(); in.show(); &#125; &#125; public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125; &#125; 匿名内部类 匿名内部类，就是内部类的简写格式 前提：内部类必须继承或实现一个外部类或接口 匿名用户类：其实就是一个用户匿名子对象 格式：new 父类or接口 (){ 子类内容 通常使用场景之一： 当函数参数是接口类型时，而且接口中的方法不超过三个，可以用匿名内部类作为实际参数进行传递123456789101112131415161718192021222324interface inter&#123; public void show1(); public void show1();&#125;class Outer&#123; public void method()&#123; /*可以这么写 new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125;*/ //也可以这么写 inter in = new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125; /*居然还可以这么写 new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125;.show1(); */ &#125;&#125; 小细节静态问题 试试能不能编译如下代码 1234567891011public class InnerClassDemo &#123; class Inner&#123; &#125; public static void main(String[] args)&#123; new Inner(); &#125; public void method()&#123; new Inner(); &#125;&#125; ‘InnerClassDemo.this’ cannot be referenced from a static context 为什么 method 也写了同样的内容却没有报错？ 因为 main 是静态的，只能直接调用静态成员 转型问题 运行如下代码，将注释1取消注释，观察结果，再注释掉1，取消掉注释2，观察结果 123456789101112131415161718192021222324public class Outer &#123; public void method()&#123; /*注释1 new Object()&#123; public void show()&#123; System.out.println(&quot;i can run&quot;); &#125; &#125;.show(); */ /*注释2 Object obj = new Object()&#123; public void show()&#123; System.out.println(&quot;i can run&quot;); &#125; &#125;; obj.show(); */ &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125;&#125; 为什么第一次编译运行正确，第二次编译错误？ 因为匿名内部类这个子类对象被向上转型为 object 类型，这样就不能再使用子类特有的方法了]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多态]]></title>
    <url>%2F2018%2F04%2F27%2FJava%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[对象的多态性 以代码为示例 1234567891011121314151617public class Animals &#123; public void speak()&#123; System.out.println(&quot;i am animals&quot;); &#125;&#125;public class Cat extends Animals&#123; public void speak()&#123; System.out.println(&quot;i am cat&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; //一个对象，两种形态 Animals cat = new Cat(); cat.speak(); &#125;&#125; 运行后的结果为”i am cat” 猫这类事物既具备猫的形态，又具备动物形态，这就是对象的多样性，简单说，一个对象对应着多种类型 多态在代码中的体现 父类或者接口的引用指向了其子类的对象 多态的好处 提高了代码扩展性，前期定义的代码可以使用后期的内容。 123456789101112131415161718192021222324252627282930313233public abstract class Animals &#123; public abstract void eat();&#125;public class Cat extends Animals&#123; public void eat()&#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse()&#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125;public class Dog &#123; public void eat()&#123; System.out.println(&quot;啃骨头&quot;); &#125; public void guardDoor()&#123; System.out.println(&quot;看门&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; Cat c1 = new Cat(); Dog d1 = new Dog(); Dog d2 = new Dog(); method(c1); method(d1); method(d2); &#125; public static void method(Animals a)&#123; a.eat(); &#125;&#125; 如上图所示代码，如果很多只猫，很多只狗，为了代码复用性，需要在主类中定义一个方法，可是如果动物种类很多，是否要定义不同参数的许多方法那，答案是不用的，只需要定义个参数为Animals对象的即可 多态的局限性及前提 前期定义的内容，不能调用后期子类定义的特有内容 多态的前提 必须有关系，继承，实现 要有覆盖 多态转型 123456789101112131415//自动类型提升，猫对象提升了动物类型，但特有功能无法访问//作用就是限制对猫特有功能的访问//专业讲就是 向上转型，将子类型隐藏，就不用使用子类的特有方法Animals a = new Cat();a.eat();//如果还想访问具体动物的特有功能//可以进行向下转型Cat c = (Cat)a;//向下转型目的：为了使用子类中的特有方法c.eat();c.catchMouse();//错误示例Animals a1 = new Dog();Cat c1 = (Cat)a1; //ClassCastException类型转换异常 注意：对于转型来说，自始至终都是子类对象在做着类型的变化 类型判断 还是以之前的代码为示例，如果method方法内想进行输出猫，狗的特有功能该怎么做那？123456789101112public void method(Animals a)&#123; a.eat(); if(a instanceof Cat)&#123; //instanceof：用于判断对象的具体类型，只能用于引用数据类型判断 //通常在向下转型前用于健壮性的判断 Cat c = Cat(a); c.catchMouse(); &#125;else if(a instanceof dog)&#123; Dog d = Dog(a); d.guardDoor(); &#125;&#125; 多态时成员特点成员变量 编译时：参考引用型变量所属的类中是否有调用的成员变量，有则编译通过，没有则编译失败 运行时：参考引用型变量所属的类中是否有调用的成员变量，并运行该所属类中的成员变量 编译和运行都参考左边，如 animals a = new Cat(); 成员函数（非静态） 编译时：参考引用型变量所属的类中是否有调用的函数，有则编译通过，没有则编译失败 运行时：参考对象所属的类中是否有调用的函数， 简单说：编译看左边，运行看右边 1234567891011121314public class Father &#123; public void show()&#123; System.out.println(&quot;i am father&quot;); &#125;&#125;public class Son extends Father&#123; public void show() &#123; System.out.println(&quot;i am son&quot;); &#125;&#125;public class Test()&#123; Father f = new Son(); f.show();&#125; 运行后的结果 i am son 静态函数 编译时：参考引用型变量所属的类中是否有调用的静态方法，有则编译通过，没有则编译失败 运行时：参考对象所属的类中是否有调用的静态方法 简单说：编译和运行都看左边 其实对于静态方法，是不需要对象的，直接类名调用即可 1234567891011121314public class Father &#123; public static void show()&#123; System.out.println(&quot;i am father&quot;); &#125; &#125; public class Son extends Father&#123; public static void show() &#123; System.out.println(&quot;i am son&quot;); &#125; &#125; public class Test()&#123; Father f = new Son(); f.show(); &#125; 运行结果为 i am father]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承及接口]]></title>
    <url>%2F2018%2F04%2F21%2FJava%E7%BB%A7%E6%89%BF%E5%8F%8A%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[继承 什么时候继承？ 当类中存在所属关系时，就定义继承。狗和狼都是犬科，所以他们都可以继承犬科 所属关系：is a 关系 谁是谁中的一种 优点 提高代码复用性 让类与类之间产生了联系，为多态提供了前提 缺点 打破封装性 解决方法看下面的final关键字 注意 Java中支持单继承，不直接支持多继承，但对C++中多继承进行了改良 单继承：一个子类只能有一个父类 多继承：一个子类可以有多个父类（Java不直接支持，但是改良了） 因为如果多个父类中有相同成员，会产生调用的不确定性（Java中通过”多实现”的方式） Java支持多重继承 继承体系 C继承B，B继承A，就会出现继承体系 如何使用 创建该子类中的顶层类，了解该体系的基本使用功能 创建体系中的最子类对象，完成功能的使用 子父类中成员特点 子父类中，成员的特点体现 成员变量 成员函数 构造函数 成员变量 本类中成员和局部变量同名用this区分 子父类中的成员变量用super区分 this super 用法很相似 this 代表一个本类对象的引用 super 代表一个父类空间 子类不能直接访问父类中私有的内容 成员变量内存图解 以如下代码为例123456789101112131415public class Father&#123; int num = 4;&#125;public class extends Son&#123; int num = 5; void show()&#123; System.out.println(this.num+super.num); &#125;&#125;public class Demo&#123; public static void main(Sting[] args)&#123; Son s = new Son(); s.show(); &#125;&#125; 运行Demo类，main方法进栈，执行下一句话，创建一个子类对象，因为它是继承的父类，所以方法区需要先加载父类函数及构造方法，再加载子类构造方法。接下来在堆中开辟空间，给予地址，num值在父类子类中都有体现，所以存储时num值系统会通过关键字标注好。show方法入栈，this关键字指向son的num，super关键字指向father的num。 成员函数特点（覆盖） 当子父类中出现成员函数一模一样的情况，会运行子类的函数，这种现象就是覆盖操作，这是函数在子父类中的特性。 函数两个特性 重载：同一个类中 overload 覆盖：子类中，也成为重写，复写 override 注意事项： 子类方法覆盖父类方法时，子类权限必须大于等于父类权限才可以引发覆盖 静态只能覆盖静态，或被静态覆盖 什么时候使用覆盖操作？ 当对一个类进行子类的扩展时，子类需要保留父类的功能声明，但是要定义子类中该功能的特有内容时，就使用覆盖操作完成 成员函数特点应用 观察下面的代码，Phone类拥有两个方法，现在需要在他的基础上更改增加show方法的功能，就可以采用成员函数覆盖的方法 为什么不更改原代码的函数？为了安全起见，如果出错，那样很难复原。1234567891011121314151617181920212223public class Phone&#123; public void call()&#123;&#125; public void show()&#123; System.out.println(&quot;number&quot;); &#125;&#125;public class newPhone extends Phone&#123; public void call()&#123; super.call()； &#125; public void show()&#123; super.show(); System.out.println(&quot;name&quot;); System.out.println(&quot;picture&quot;); &#125;&#125;public class Demo&#123; public static void main()&#123; newPhone p = new newPhone(); p.call(); p.show(); &#125;&#125; 子父类中的构造函数子类的实例化过程 看下图代码，运行主函数后会是怎么样的结果 123456789101112131415public class Father &#123; Father()&#123; System.out.print(&quot;Father&quot;); &#125;&#125;public class Son extends Father &#123; public Son()&#123; System.out.print(&quot;Son&quot;); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; new Student(); &#125;&#125; 运行结果FatherSon，有Son我们理解，调用的是Son类，可是为什么有Father啊 特点 在子类构造对象时，发现访问子类构造参数时，父类也运行了，Why？ 在子类的构造函数第一行有一个默认的隐式语句。super(); 子类中所有的构造函数默认都会访问父类中的空参构造函数 细节 为什么子类实例化的时候，要访问父类中的构造函数那？ 那是因为子类继承了父类，获取到了父类中的内容（属性），所以在使用父类内容之前要先看父类是如何对自己的内容进行初始化的。所以子类在构造对象时，就必须访问父类中的构造函数。为了完成这个必须的动作，就在子类的构造函数中加入了super语句。如果父类中没有定义空参数构造函数，那么子类的构造函数必须用super明确要调用父类中的那个构造函数。 super语句必须要定义子类构造函数第一行。因为父类的初始化动作要先完成 如下面代码所示，子类构造函数中如果使用this调用了本类构造函数时，那么super没有了，因为super和this都只能定义在第一行，不过可以保证的是，子类中肯定会有其他构造函数访问父类的构造函数和数据 12345678910111213141516public class Father &#123; Father()&#123; System.out.print(&quot;F&quot;); &#125; &#125;public class Son extends Father &#123; Public Son()&#123; super(); System.out.print(&quot;Son1&quot;); &#125; public Son(int x)&#123; this(); //super(); System.out.print(&quot;Son2&quot;); &#125;&#125; 所有的类在创建时其实都是继承的object类,如下图的Demo类，注释掉的内容都是自动生成的隐式 123456789class Demo //extends object()&#123; /* Demo()&#123; super(); return; &#125; */&#125; 图解 以下面代码为示,123456789101112131415161718192021222324252627282930313233public class Father &#123; Father()&#123; //super(); show(); //return; &#125; public void show()&#123; System.out.println(&quot;Father show&quot;); &#125;&#125;public class Son extends Father&#123; int num = 8; public Son()&#123; super(); //-&gt;通过super初始化父类内容时，子类的成员变量并未显示初始化。 //等super()父类初始化结束后，才对子类成员变量初始化 return; &#125; public void show() &#123; System.out.println(&quot;Son show &quot;+num); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Son s = new Son(); s.show(); &#125;&#125;/*运行结果：Son show 0 Son show 8*/ 过程 一个对象的实例化过程 1、JVM会读取指定路径下的Person.class文件，并加载进内存，并会加载Person的父类（如果有直接父类的情况下） 2、在堆内存中开辟空间，分配地址 3、并在对象空间中，对对象中的属性进行默认初始化 4、调用相应的构造函数进行初始化 5、在构造函数中，第一行会先调用父类中构造函数进行初始化 6、父类在初始化完毕后，再对子类的属性进行显示初始化 7、再进行子类函数的构造初始化 8、初始化完毕后，将地址值赋给引用变量 final关键字 1、final是一个修饰符，可以修饰类，方法，变量 2、final修饰的类不可以被继承，该类为最终类 3、final修饰的方法不可以被覆盖 4、final修饰的变量是一个常量，只能赋值一次 为什么使用final修饰变量？ 其实在程序中如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差，所以应该给这个数据起个名称。而且这个变量名称的值不能变化，所以加上final固定 final应用 如下面的圆周率想定义后不被人修改，即可加上final修饰 注：被修饰后变量即是常量，表示方法为 “所有单词都大写，如果多个单词，中间用_连接” 注：final修饰的变量必须手动进行初始化，且前面一般加上static，方便调用123456class Circle&#123; static final double PI = 3.14; void method()&#123; System.out.println(PI); &#125; &#125; 抽象类 抽象：笼统，模糊，不具体 特点 1、方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰。抽象方法必须定义在抽象类中，该类也必须被abstract修饰 2、抽象类不可以被实例化，不可以被new 创建对象。因为调用抽象方法无意义 3、抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化，否则这个子类还是抽象类 细节 1、抽象类中有构造函数吗？ 有，用于给子类对象初始化 2、抽象类可以不定义抽象方法吗？ 可以，但是很少见，目的是不让该类创建对象。AWT的适配器对象就是这种类。通常这个类中的方法有方法体，但是没有内容 3、抽象关键字不可以和哪些关键字共存？ private 抽象方法需要被覆盖，加上私有不能覆盖 static 加上静态后可以用类调用方法，但是抽象方法运行无意义 final final修饰后不能被继承，抽象类或方法就没有用了 4、抽象类与一般类的异同点？ 抽象类和一般类都是用来描述事物的，都在内存定义了成员 一般类有足够信息描述事物，抽象类描述事物信息一般都不足 一般类中不能定义抽象方法，抽象类中可定义抽象方法或非抽象方法 一般类能被实例化，抽象类不可以被实例化 5、抽象类一定是父类吗？ 是的，因为需要子类覆盖其方法后，才可以对子类实例化 接口定义 当一个抽象类中的方法都是抽象类的时候，可以将该抽象类用另一种形式定义和表示，就是接口 interface。 定义接口使用的关键字不是class 是interface 接口当中常见的成员：（这些成员都有固定的修饰符，都是公共权限） 全局常量：public static final 抽象方法：public static 实现 类与类之间是继承方式，类与接口之间是实现方式 1234567891011121314151617181920public interface Demo&#123; public static final int NUM = 1; public static void show1(); public static void show2();&#125;public class DemoImpl implements Demo&#123; public void show1() &#123;&#125; public void show2() &#123;&#125;&#125;public class Test&#123; public static void main(String[] args)&#123; DemoImpl d = new DemoImpl(); //下面三行语句都正确 System.out.println(d.NUM); System.out.println(DemoImpl.NUM); System.out.println(Demo.NUM); &#125;&#125; 接口不可以实例化，只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化，否则，这个就是一个抽象类 多实现 Java中不直接支持多继承，因为会出现调用的不确定性，所以Java将多继承机制进行改良，在Java中变成了多实现 一个类支持多个接口 一个类在继承另一个类的同时，还可以实现多个接口 123456789101112131415161718public interface A&#123; public abstract void show1();&#125;public interface B&#123; public abstract void show2();&#125;public class Q&#123; public void method() &#123;&#125;&#125;//Test类继承Q类意味着他们属于一个体系//实现A,B接口是为了扩展功能class Test extends Q implements A,B&#123; public void show1() &#123;&#125; public void show2() &#123;&#125;&#125; 接口的出现避免了单继承的局限性，一个类 注意 接口与接口之间是继承关系，而且接口之间可以多继承 Java不能多继承的原因是因为方法体导致的运行不确定性，不过接口无方法体，所以接口可以多继承 接口类型的引用，都是指向自己类型子类的对象 特点 接口是对外暴露的规则 接口是程序的功能扩展 接口的出现降低耦合性 接口可以用来多实现 类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口 接口与接口之间可以有继承关系 接口抽象类区别 相同点：都是向上不断抽取而来 不同点： 抽象类： 抽象类需要被继承，且只能单继承 抽象类可以定义抽象方法和非抽象方法，子类继承后可以直接使用抽象方法 抽象类继承是 is a 关系，是在定义该体系的基本共性内容 接口： 接口需要被实现，可以多实现 接口只能定义抽象方法，必须由子类去实现 借口实现是 like a 关系，在定义体系的额外功能]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java单例模式]]></title>
    <url>%2F2018%2F04%2F21%2FJava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式 解决问题：可以保证一个类在对象中唯一性 必须对于多个实例使用同一个配置信息对象时，就需要保证该对象唯一性 如何保证对象唯一性？ 不允许其他程序使用new创建对象 在该类创建一个本地实例 对外提供一个方法让其他程序可以获取该对象 步骤： 私有化该类构造函数 通过new在本类中创建一个本类对象 定义一个公有的方法，将创建的对象返回 饿汉式 代码展示 12345678910111213141516//饿汉式public class Single &#123; //类加载进来时，对象就已经生成了 private static Single s = new Single(); private Single()&#123;&#125; public static Single getInstance()&#123; return s; &#125;&#125;public class Demo&#123; `public static void main(String[] args)&#123; Single s1 = Single.getInstance(); Single s2 = Single.getInstance(); System.out.println(s1 == s2); &#125;&#125; 工作中常常使用的一种单例模式，安全性好 懒汉式 代码展示 123456789101112// 懒汉式public class Single2 &#123; //类加载时没有对象生成，只有调用了getInstance方法后才会创建对象 //延迟加载程序 private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null) s = new Single2(); return s; &#125;&#125; 常见于面试中，涉及知识点较多 内存图示（饿汉式为例） main进栈，s1对象生成，方法区，single构造函数进入，静态区，single s getInstance进入，堆中开辟一块空间，赋予0x0045地址，静态区中s指向堆中地址。get方法进栈，s1地址指向0x0045，get出栈。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编写工具类及API文档]]></title>
    <url>%2F2018%2F04%2F18%2FJava%E7%BC%96%E5%86%99%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%8F%8AAPI%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[昨天学习了如何编写一个工具类，及如何给他注释再去生成专属于他的API文档。今天我将这个过程以及一些遇到的报错解决整理到博客中。 编写Java工具类（以数组工具类为例） 工具类中包含了一些简单的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** *这是一个可以对数组进行操作的工具类，该类中提供了如最值获取，排序等功能。 * @author Orange * @version 1.0 */ public class ArrayTool &#123; // private ArrayTool()&#123;&#125; /** *获取一个整型数组中的最大值 * @param arr 接收一个 int 类型的数组 * @return 会返回一个该数组中最大值 */ public static int getMax(int[] arr)&#123; selectSort(arr); int max = arr[0]; for(int i=0 ;i&lt;arr.length; i++)&#123; if(arr[i]&gt;max) max = arr[i]; &#125; return max; &#125; /** * 给int数组进行选择排序。 * @param arr 接收一个 int 类型的数组 */ public static void selectSort(int[] arr)&#123; for(int i=0 ;i&lt;arr.length-1; i++)&#123; int number = arr[i]; int index = i; for(int j=i+1;j&lt;arr.length;j++)&#123; if(number&gt;arr[j])&#123; number = arr[j]; index = j; &#125; &#125; if(index != i) swap(arr,i,index); &#125; &#125; //因为 swap 方法是 priavte ，所以只写普通注释就可以了 //给数组中元素进行位置的置换 private static void swap(int[] arr,int a,int b)&#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; /** * 将 int 形式的数组转换成字符串形式。打印形式是[s1,s2,s3,.....] * @param arr 接收一个 int 类型的数组 * @return 返回该 int 数组的字符串表现形式 */ public static String ArrayToString(int[] arr)&#123; String str = &quot;[&quot;; int point = 0; for(int i=0 ;i&lt;arr.length ;i++)&#123; if(i != arr.length-1) str = str + arr[i] + &quot;,&quot;; else str = str + arr[i] + &quot;]&quot;; &#125; return str; &#125; &#125; 注释的添加 Java文档注释|菜鸟教程 javadoc工具软件 javadoc 语法 javadoc [ options ] [ packagenames ] [ sourcefiles ] [ @files ] DOS界面使用javadoc编写API WIN-R 运行 cmd 进入 DOS 界面 通过使用CMD的命令进入包含该java工具类的文件夹 输入：javadoc -d myhelp -author -version ArrayTool.java 效果展示 报错编码GBK的不可映射字符 解决方法 关闭编译器要编写的那个工具类 用记事本打开 Java 源文件 另存为，选择 ANSI 编码 覆盖后，在DOS界面重试 成功后，将编码改回原格式 错误2 生成错误原因：改为ANSI编码后，打开了编译器，汉字都变成了乱码 切记，记事本改完编码后，不要。立即用编辑器打开该文件]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java构造函数及关键字]]></title>
    <url>%2F2018%2F04%2F15%2FJava%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[构造函数 简单说，构造函数就是构建创造对象时调用的函数 创建对象都必须要通过构造函数初始化，一个类如果没有定义过构造过程，会有一个默认空参构造函数。若定义了指定的构造函数，那么类中默认构造函数就会消失。 特点 函数名与类类名相同 不能返回值类型 没有具体返回值 区别 构造函数 对象创建时，会掉用与之相应的构造函数，对对象进行初始化 对象创建时，会调用且仅调用一次 一般函数 对象创建后，需要使用函数功能时才调用 对象创建后，可调用多次 重载 当一个类中出现多个构造函数时，必须以重载形式体现 内存图解 接下来用下面这段代码，来演示内存变化过程12345678910111213141516public class Person &#123; private String name; private int age; Person()&#123;&#125;; Person(String name,int age)&#123; this.name = name; this.age = age; &#125; public void speak()&#123; System.out.println(name+&quot;:&quot;+age); &#125; public static void main(String[] args)&#123; Person person = new Person(&quot;jack&quot;,20); person.speak(); &#125;&#125; 左面是栈内存，右面是堆内存。首先在栈内存运行main函数，创建名字为p的对象，然后栈内存调用了有参构造函数。在堆内存中开辟一片区域，给予其地址，将构造函数中的值寻址赋给堆中变量的值，然后将构造函数弹栈。将堆内存中的地址赋给p。 然后在栈中入栈speak方法，运行后寻址输出变量值this关键字 当成员变量和局部变量重名，可用关键字this区分 this代表对象，一般当前对象，this代表其所在函数所属对象的引用12345678class Person &#123; Person(String name)&#123; this.name = name; &#125; public static void main()&#123; Person p = new Person(name); &#125;&#125; 功能 this也可用于在构造函数中调用其他构造函数 注：只能定义在构造函数第一行，因为初始化动作要先执行 12345678910class Person &#123; Person()&#123;&#125; Person(String name)&#123; this.name = name; &#125; Person(String name,int age) &#123; this(name); this.age = age; &#125;&#125; 当执行主函数中的语句时，调用有参构造函数，此时this.name就是代指对象p 简单来说，哪个对象调用this所在的函数，this就代表哪个对象注意事项 运行下面的代码失败，死循环12345678910111213class Person &#123; Person()&#123; this(jack); &#125; Person(String name)&#123; this(); this.name = name; &#125; Person(String name,int age) &#123; this(name); this.age = age; &#125;&#125; 内存图解 接下来通过下面的代码来演示更加完整的过程12345678910111213141516171819public class Person &#123; private String name; private int age; Person(String name)&#123; this.name = name; &#125; public void speak()&#123; System.out.println(name+&quot;:&quot;+age); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Person p = new Person(&quot;rose&quot;); p.speak(); Person p1 = new Person(&quot;dell&quot;); p1.speak(); &#125;&#125; 首先在栈内存运行main函数，创建名字为p的对象，然后栈内存调用了有参构造函数。在堆内存中开辟一片区域，给予其地址后初始化数值，构造函数中的this起到了作用，指向p对象的地址，将 name=”jack” 传到堆中更改值，然后将构造函数弹栈。将堆内存中的地址赋给p。speak函数入栈也是通过this寻址堆中赋值。 小练习（双人年龄比较） 思路：在Person类中写一个boolean类型方法，巧妙地利用this就可以compare方法中只带一个参数。 123public boolean compare(Person p)&#123; return this.age == p.age ; &#125; 主类中如何使用？ 123Person p1 = new Person();Person p2 = new Person();p1.compare(p2); static关键字特点 static是一个修饰符，用来修饰成员 static修饰成员被所有对象共享 static优先于对象存在（static随类的加载就已经存在了） static修饰的成员多了一种调用格式，可以直接被类名调用。如：类名.静态成员 static修饰的是共享数据 对象中存储的是特有数据成员变量、静态变量区别 区别： 生命周期不同 调用方式不同 别名不同 数据存储位置不同 成员变量： 随对象创建存在，随其回收而释放 只能被对象调用 实例变量 存在堆内存的对象中，也叫对象的特有数据 静态变量： 随着类加载而存在，随着类消失而消失 可以对象调用，也可以类调用 类变量 存放在方法区（也叫共享数据区）的静态区中，也叫对象的共享数据 静态使用注意 静态方法只能调用静态成员（非静态都可以访问） 静态方法不可使用this 或者 super关键字 主函数静态的 内存图解 内存划分 寄存器 本地方法区 方法区 栈内存 堆内存 接下来用一段代码来演示内存变化过程123456789101112131415161718192021222324public class Person &#123; private String name; private int age; static String country = &quot;CN&quot;; Person()&#123;&#125;; Person(String name,int age)&#123; this.name = name; this.age = age ; &#125; public void show()&#123; System.out.println(Person.country+&quot;:&quot;+this.name+&quot;:&quot;+this.age); &#125; public static void method()&#123; System.out.println(Person.country); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Person.method(); Person p = new Person(&quot;jack&quot;,20); p.show(); &#125;&#125; 运行程序的时候，读取StaticDemo类，在方法区存放他的名字，注意还有他的自带的构造函数，然后在他的静态区粘贴上类的名字和代码，栈内存中压栈main，根据上面代码需要调用Person类，将Person类的构造函数show方法粘在方法区，在静态区添加入静态变量和静态方法。栈内存中压栈method，弹栈。继续执行主函数的语句，创建对象在堆内存开辟空间，压栈Person的构造函数，用this指向堆中的地址，赋值给堆内存。Person构造函数弹栈，将堆中地址赋值给p对象，show方法压栈，this指向堆中的地址，弹栈 静态什么时候用静态变量 当分析对象中所具备的成员变量的值都是相同的，这是这个成员就可以被静态修饰。只要数据在对象中都不同的，就是对象的特有数据，必须存在对象中。非静态的若是有相同数据，且对象不需做修改只需要使用，，那么就不需要存储在对象中，定义成静态的就可以了 静态函数 参考一点，该函数功能是否有访问到对象中的特有数据 简单来说，从源代码看该函数功能是否需要访问非静态的成员变量，如果需要，该方法就是非静态的，如果不需要，该方法就可以定义成静态的 非静态需要被对象调用，而仅创建调用非静态但没有访问特有数据的方法，那么该对象的创建是没有意义的。 静态代码块 随类的加载而执行，且只执行一次 作用：给类初始化 构造代码块：给所有对象初始化 构造函数：给对应对象针对性初始化 执行顺序，谁先执行 有对象：静态代码块 &gt; 构造代码块 &gt; 构造函数 无对象：静态代码块 &gt; 构造函数 &gt; 构造代码块 主函数特殊处 格式固定 被JVM所识别，所调用 分析： public 权限最大 static 不需要对象，直接用主函数所属类名调用 void 没有具体返回值 main 不是关键字，只是被JVM所识别固定的名字 String[] args 主函数参数列表，一个数组类型参数，元素都是字符串 接下来我们输出代码测试一下 1234public static void main(String[] args)&#123; System.out.println(args); System.out.println(args.length);&#125; 结果：[Ljava.lang.String;@1540e19d 0]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象总结]]></title>
    <url>%2F2018%2F04%2F12%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[面向对象面向对象的特点 1.符合人们的思想习惯 2.将复杂事情简单化 3.让曾经在过程中的执行者变成指挥者举例 比如说，公司中刚刚接取了一个项目，如果这个事情全部都交给老总做的话，可能会耗时很久很久，所以他就需要去找别人来帮他做。需要去面试选人，也就是寻找几个对象替他去完成工作。这就是面向对象的一种体现。 哪个对象对动作最清楚，定义在哪里成员变量、局部变量的区别 成员变量 成员变量定义在类中，整个类都可以访问 成员变量存在于堆内存的对象中 成员变量随着对象创建而生，随对象消失而亡 成员变量都有默认初始值 局部变量 局部变量定义在函数、语句、局部代码块中，只在所属区域有效 局部变量存在于栈内存的方法中 局部变量随着所属区域的执行而存在，随着所属区域结束而释放 局部变量没有默认初始值（使用前必须进行初始化）匿名对象 1.当对象对方法仅进行一次调用的时候，就可以简化成匿名对象 2.匿名对象可以作为实际参数进行传递对象的内存体现 以下面这段代码为例 123456Car c1 = new Car();Car c2 = new Car();c1.num = 4;c1.color = red;c2.num = 5;c2.color = blue; 栈中运行主函数，创建c1对象，在堆中开辟一个新的区域，将他的地址值传回栈中，他的num初始值为0，color初始值为null 下面这段代码和上面又有什么不同那1234Car c1 = new Car();Car c2 = c1；c1.num = 4;c2.color = blue; 这里将c1赋值给c2，就是将c1地址给c2，所以c2.color = blue，通过寻址找到并更改的color值就是c1地址下的匿名对象 以下面代码，作图演示123new Car().num = 4;new Car().color = red;new Car().show(); 基本数据类型参数传递12345678910class demo&#123; public static void main(String[] args)&#123; int x; show(x); System.out.println(&quot;x=&quot;+x); &#125; public static void show(int x)&#123; x = 4; &#125;&#125; 引用数据类型参数传递123456789101112class demo&#123; int x; public static void main(String[] args)&#123; demo d = new demo(); d.x = 9; show(d); System.out.println(d.x); &#125; public static void show(demo d)&#123; d.x = 4; &#125;&#125; 封装 好处： 将变化隔离 便于使用 提高重用性 提高安全性 封装原则 将不需要对外提供的原则都隐藏起来 把属性都隐藏，提供公共方法对其访问 封装思想 封装：指隐藏对象的属性和实现细节，仅对外提供公共访问方式 private权限修饰符 私有仅仅是封装的一种体现而已，封装不仅仅有私有一种方式]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2F2018%2F04%2F10%2FJava-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E6%9F%A5%E8%A1%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天写一下二进制转换十六进制的程序,改良程序的过程进制转换（以10转16为例） 首先想一下十六进制是多少个二进制位，4个。那么int是多少个字节？多少个二进制位？4个字节，32个二进制位 123456789public void toHex(int num)&#123; int temp; for (int i = 0;i&lt;8 ;i++) &#123; temp = num &amp; 15; System.out.print(temp+&quot; &quot;); num = num &gt;&gt;&gt; 4; &#125; &#125; 上图的结果是12 3 0 0 0 0 0 0，先来讲讲原理，再改良 1234567891011 以 num = 60 为例 0000-0000 0000-0000 0000-0000 0011-1100&amp; 0000-0000 0000-0000 0000-0000 0000-1111------------------------------------------ 0000-0000 0000-0000 0000-0000 0000-1100 0000 0000-0000 0000-0000 0000-0000 0011 ( 1100 ）&amp; 0000-0000 0000-0000 0000-0000 0000-1111------------------------------------------ 0000-0000 0000-0000 0000-0000 0000-0011 结果分别是12 3 0 0 0 0 0 0 先和15（4个低位都是1，其余是0）进行&amp;运算，得到值后，再进行&gt;&gt;&gt;3的运算。这样得到的结果还有12的存在，应该是英文字母的，继续改进 1234567891011public void toHex2(int num)&#123; int temp; for (int i = 0;i&lt;8 ;i++) &#123; temp = num &amp; 15; if (temp&gt;=10) System.out.print((char)(temp-10+&apos;A&apos;)+&quot; &quot;); else System.out.print(temp+&quot; &quot;); num = num &gt;&gt;&gt; 4; &#125; &#125; 在中间的地方加了一个判断，使用了ASCII的知识，temp-10+’A’ 得到的不是字母，所以在前面还要加上char的强制转换 继续改进，现在这些数还是倒序，而且有许多无用位。 1234567891011121314public void toHex3(int num)&#123; char[] chars = new char[]&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;, &apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;; char[] arr = new char[8]; int point = arr.length - 1 ; int temp; while (num!=0)&#123; temp = num &amp; 15; arr[point] = chars[temp]; num = num &gt;&gt;&gt; 4; point --; &#125; System.out.print(arr); &#125; 这里使用了数组的查表法，创建两个char的数组，第一个数组是用来将所获取到的0到15的数字转换为十六进制中的字符，第二个数组用来存储最后16进制的结果 在之前的两个程序中，最后输出的值都是反向的，于是我在这里创建了一个指针point，让他的初始值指向数组最后端的角标，每次输入进一个数后，指针前移一位，这样最后输出的时候直接输出数组就可以输出一个转换正确的16进制值。 进制转换整合 上面的的程序还只能对10-&gt;16转换，可以对其略作修改，使其可以灵活转换各种进制 1234567891011121314public char[] trans(int num,int base,int offse)&#123; char[] chars = new char[]&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;, &apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;; char[] arr = new char[32]; int point = arr.length - 1 ; int temp; while (num!=0)&#123; temp = num &amp; base; arr[point] = chars[temp]; num = num &gt;&gt;&gt; offse; point --; &#125; return arr; &#125; 添加单独方法 1234567891011public char[] toBinary(int num)&#123; //十进制转换二进制 return trans(num,1,1);&#125;public char[] toHexa(int num)&#123; //十进制转换十六进制 return trans(num,15,4);&#125;public char[] toOctal(int num)&#123; //十进制转换八进制 return trans(num,7,3);&#125; 主类测试 12345678910public class tranSystem &#123; public static void main(String[] args)&#123; int num = 854796; tranSystem tra = new tranSystem(); System.out.println(tra.toHexa(num)); System.out.println(tra.toOctal(num)); System.out.println(tra.toBinary(num)); &#125; //上面写的方法添加在这里&#125; Integer.toBinaryString()是java系统自带的转换二进制 查表法 查表法在日常学习中可以有很多应用，如输入数字，输出星期几等等]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 数组常见操作]]></title>
    <url>%2F2018%2F04%2F09%2FJava-%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[今天整理了一些常用的数组操作，如最大值，查找，排序等等 数组最大值值判断12345678public int maxValue(int[] a)&#123; int max = a[0]; for(int i=0;i&lt;a.length;i++)&#123; if(a[i]&gt;max) max = a[i]; &#125; return max; &#125; 下标判断12345678public int maxIndex(int[] a)&#123; int max = 0; for(int i=0; i&lt;a.length;i++)&#123; if(a[i]&gt;a[max]) max = i; &#125; return a[max]; &#125; 数组操作辅助方法交换值123456public void swap(int[] arr,int a,int b)&#123; int temp = 0; temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; 输出链表12345public void printList(int[] arr)&#123; for(int i = 0;i&lt;arr.length;i++) System.out.print(arr[i]+&quot; &quot;); System.out.println(); &#125; 数组选择排序12345678910111213public void chooseSort(int[] arr)&#123; //选择排序 int temp = 0; for(int i=0;i&lt;arr.length-1;i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if(arr[j]&gt;arr[i])&#123; //swap(arr,i,j); temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; 选择排序改进版 改进版的选择排序，设置了角标值和数组值1234567891011121314public void chooseSort2(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++) &#123; int number = arr[i]; int index = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (number &gt; arr[j]) &#123; number = arr[j]; index = j; &#125; &#125; if (index!=i) swap(arr,i,index); &#125; &#125; 数组冒泡排序 冒泡排序，五个数为例，共进行4+3+2+1 10次比较123456789101112public void ppSort(int[] arr)&#123; //便于理解 int temp = 0; for(int i = 0;i&lt;arr.length-1;i++) for (int j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; //swap(arr,j,j+1); temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] =temp; &#125; &#125; &#125; 冒泡排序改进版123456789101112public void ppsort2(int[] arr)&#123; //改进版冒泡 int temp = 0; for (int i = arr.length-1;i&gt;0;i--) for(int j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; //swap(arr,j,j+1); temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] =temp; &#125; &#125; &#125; 查找通过值查找12345678public int findByValue(int[] arr,int key)&#123; //通过值查找 int index = -1; for (int i = 0;i&lt;arr.length;i++)&#123; if(key == arr[i]) index = i + 1; &#125; return index; &#125; 二分查找1234567891011121314151617public int findHalf(int[] arr,int key)&#123; //二分查找 list list = new list(); list.chooseSort2(arr); int max = arr.length-1; int min = 0; int mid ; while(min&lt;=max)&#123; mid = (max + min)&gt;&gt;1; if(key&gt;arr[mid]) min = mid + 1; else if(key&lt;arr[mid]) max = mid - 1; else return mid; &#125; return -1; &#125; 练习题 给定一个有序的数组，如果往该数组中存储一个元素，并保证这个数组还是有序的，那么这个元素的存储的角标该如何获取？ 1234567891011121314151617public int getJiaoBiao(int[] arr,int key)&#123; / list list = new list(); list.chooseSort2(arr); int min =0; int max =arr.length-1; int mid; while(min&lt;=max)&#123; mid = (min+max)&gt;&gt;1; if(key&gt;arr[mid]) min = mid + 1; else if (key&lt;arr[mid]) max = mid - 1; else return mid; &#125; return min; &#125; 在系统自带的Arrays类中，有这个方法，不过和我这个写的不一样，比我的更好一些，我把源码粘贴上来 123456789101112131415161718private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) &#123; int low = fromIndex; int high = toIndex - 1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;&gt; 1; int midVal = a[mid]; if (midVal &lt; key) low = mid + 1; else if (midVal &gt; key) high = mid - 1; else return mid; // key found &#125; return -(low + 1); // key not found. &#125; 不同的是返回值 比如我的答案如果是6，那么他的答案就会是-7，为什么那？ 因为要插入的这个数是不存在于数组中的，所以给他一个负数的位置，那么-7怎么来的？-6-1，因为还有1个值，就是用我的方法得到0的那个值，取了负数还是0，不好分辨，所以就整体取负后再减一 总结说：存在，返回具体的角标位置，不存在的话 返回 -插入点-1]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数组及内存图解]]></title>
    <url>%2F2018%2F04%2F08%2FJava%E5%87%BD%E6%95%B0%E5%8F%8A%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天整理了Java函数，数组，内存加载使用的问题，在这之前我先把昨天剩下的for语句写下来。 for语句 Java for语句基础 \n 回车\t 制表符\b 退格\r 按下回车键 windows系统中回车符其实是由两个符号组成 \r \nlinux 回车符只是 \n 1System.out.println(&quot;\&quot;hello world\&quot;&quot;); 上段代码最后输出结果是 “hello world” 有引号的，\会将他下一个字符转义 break 跳出 作用范围：swich语句 or 循环语句 当break语句单独存在时，下面不要定义其他语句，因为执行不到 123456A:for(int x=0; x&lt;3; x++)&#123; B:for(int y=0; y&lt;6; y++)&#123; System.out.println(x); break A; &#125;&#125; 大家观察一下上面的语句，这就是break的特殊用法，可以将for循环定义名字，break选择性的使用。 continue 继续 作用范围：循环结构 结束本次循环，继续下次循环 continue语句单独存在时，下面不要定义其他语句，因为执行不到 12345for(int x=0; x&lt;9; x++)&#123; if(x%2 == 0) continue; System.out.println(x);&#125; 函数 函数：定义在类中具有特定功能的一段小程序，也称方法。 定义及格式 定义函数格式： 1234修饰符 返回值类型 函数（参数类型 形参1, ... ... ,）&#123; 执行语句; return 返回值;&#125; 无具体返回值时，返回值类型用void，return可以忽略不写 功能 1 定义函数可将代码封装 2 便于对该功能复用 3 函数只有被调用才能执行 两个明确 1 函数功能结果是什么？ 2 实现过程中是否需要未知内容参与运算？ 函数重载 1 同一个类中的同名函数 2 参数个数不同或者是参数类型不同 3 函数重载与返回值无关 4 Java严谨性语言，如果函数出现调用不确定性，会编译失败（比如int返回值却是double参数类型） 数组 Java数组基础 内存 内存的划分 寄存器 本地方法区 方法区 栈内存 堆内存 栈内存 存储的都是局部变量，变量所属作用域一旦结束，该变量就自动释放 堆内存 储存数组和对象（数组就是对象），new 建立的都在堆上 特点： 每个实体都有首地址值 堆内存中每个变量都有默认内存初始值，根据类型不同而不同（int -&gt; 0,double -&gt; 0.0,float -&gt; 0.0f,boolean -&gt; false,char -&gt; ‘\u0000’） 垃圾回收机制 数组运行内存图解一维数组 接下来我就通过这段代码来演示运行时的内存变化 1234567int[] x = new int[3];int[] y = new int[3];x[0] = 9;y[0] = 34;x = y;System.out.println(x[0]);y = null; 栈中运行main然后存入x数组名，堆中分配地址（16进制），找到这个地址，开辟数组大小的空间，并给予其初始值。然后将数组地址传回栈中。 给x[0],y[0]赋值时，就是直接在堆内存中更改数据 x=y 语句的执行实质上就是将y的地址赋给x，下次再调用x的时候，即直接找到y的地址 当y = null; 就是将堆内存 和栈内存的指向关系删去， 12int[] x = new int[3];System.out.println(x[]); 如果直接运行上段代码，所得到的结果是一串字符 [I@1540e19d （我运行后的值） [: 代表数组I：int 实体类型1540e19d：16进制的哈希值（地址） 二维数组 直接来是二维数组的图解123int[][] arr = new int[3][2];arr[1][1] = 89;arr[2][2] = 89; //error 大家看下图，以上图为例，所谓二维数组就是栈内存中存下指向堆内存的地址，这个地址是大小为3的数组，初始值为空，然后再创建3个小的数组，每个小数组还有一个地址，将这些地址对应存到之前大小为3的数组中。 1234int[][] arr = new int[3][2];System.out.println(arr);System.out.println(arr[0]);System.out.println(arr[0][0]); 输出的结果 123[[I@1540e19d[I@677327b60 再来看看另一种定义下的情况 1234int[][] arr = new int[3][];System.out.println(arr);System.out.println(arr[0]);System.out.println(arr[0][0]); 结果如下 123[[I@1540e19dnullException in thread &quot;main&quot; java.lang.NullPointerException]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运算符基础]]></title>
    <url>%2F2018%2F04%2F07%2FJava%E8%BF%90%E7%AE%97%E7%AC%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[今天重温的主要是Java运算符，在这里我把之前已经遗忘的一些点记录下来，以后回顾的时候可以翻阅。 比较运算符^异或： 符号两边的结果相同为False，不同则为True1234True ^ True = False ;False ^ True = True ;True ^ False = True ;False ^ False = False ; ！非： 两次非运算就是原数12!true = false ;!!true = true ; 逻辑运算符&amp;和&amp;&amp;的区别： 让我们先来看一段代码 123int x = 1;if(x&gt;2 &amp;&amp; x&lt;5) System.out.println(); 在上面的情况中，在对 &amp;&amp; 左边的式子进行判断后，得出左边的式子值是false，因为两数相与，只要有一个flase，整体式子的结果就是false。所以停止运算右侧式子，直接给出false的结果。 但是使用 &amp; 运算符的时候，无论左边式子是什么，右边都参与运算。 &amp;&amp; 和 &amp; 运算结果一样，过程有一些小区别&amp; ：无论左边式子是什么，右边都参与运算&amp;&amp; ：当式子左边为false时，右边不参与运算，结果为false |和||的区别 上面我们说了 &amp; 和 &amp;&amp; 的区别，其实原理是一样的 || 和 | 运算结果一样，过程有一些小区别| ：无论左边式子是什么，右边都参与运算|| ：当式子左边为true时，右边不参与运算，结果为true 位运算&amp; 位运算 下面我用一个小例子来演示 12345676 &amp; 3 = ?内存中 0000-0000 0000-0000 0000-0000 0000-0110&amp; 0000-0000 0000-0000 0000-0000 0000-0011----------------------------------------- 0000-0000 0000-0000 0000-0000 0000-0010∴ 6 &amp; 3 = 2 6 &amp; 3 在内存中变化的实质是，转换为2进制，各位相对应的进行 &amp; 运算 应用场景： 取0100 0000 1100 0101的后四位，如何进行操作？ 答 ：用0000 0000 0000 1111与其进行 &amp; 运算。 | 位运算 原理同上 例如 6 | 3 = 7 ^ 位运算 原理同上 1234567891011126 ^ 3 = ?内存中(简化) 0110 ^ 0011 ------ 0101∴ 6 ^ 3 = 5继续 ^ 35 ^ 3 = ?演算后 5 ^ 3 = 6 不知道大家发没发现这个运算的一些小秘密，那就是一个数连续两次与相同的数进行异或运算后，结果会是最初的数。用公式写就是： a ^ b ^ b = a 那么这个究竟可以用作干什么那？可以用于文件的加密！ ~ 反码 大家可以在自己的电脑上试一下下面的代码，看看是不是自己猜测的值 12int a = 2;System.out.println(~a); 结果是 -3 ，很多人可能都以为反码的意思就是将a的二进制10取反为01，猜测结果是1 为什么不是这样的运算过程那？ 原理这就要从计算机常用的几个码说起了。首先，java存储的是有符号数，在计算机中，有符号数通常是使用补码存储的，java也不例外。先来看看什么叫原码，反码，补码。 原码原码就是符号位加上真值的绝对值,即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:1[+1]原 = 0000 0001 反码正数的反码是其本身负数的反码是在其原码的基础上,符号位不变，其余各个位取反.例如：1[+1] = [00000001]原 = [00000001]反 补码正数的补码就是其本身负数的补码是在反码的基础上+1。例如:1[+1] = [00000001]原 = [00000001]反 = [00000001]补 分析所以回到一开始的问题，int a = 2 a在计算机中是以补码存储的。 对于2这个正数来说，补码、反码、原码都是相同的，又由于是数值型，在这里我先用八位bit来表示一下：12原码:0000 0010反码:0000 0010 补码:0000 0010 取反取反过程是在补码的基础上进行的，由于是按位取反，无论符号位还是数值位都要取反，所以结果如下: 1取反后的补码: 1111 1101 换算为值那么取反后的补码的实际值是多少呢？我们需要先把他转化为原码，过程如下: 1反码 = 1111 1101 - 1 = 1111 1100 原码 = 反码符号位不变，其余取反 = 1000 0011 所以，最后的值-3 &lt;&lt; 左移 这个符号之前并没有听说过，在这次学习中进行了掌握（开始我还以为是C++的cout那） 1234563 &lt;&lt; 2 = ?内存中0000-0000 0000-0000 0000-0000 0000-0011结果0000-0000 0000-0000 0000-0000 0000-1100∴ 3 &lt;&lt; 2 = 12 上面的运算实质是 3的2进制 整题左移两位，多余的舍弃，空位用0补 一个数进行左移运算时，左移n位，即是该数乘以2的n次幂 &gt;&gt; 右移 原理几乎一样，只有略微的不同原来最高位是什么，用什么补空位（因为最高位为1时是负数） 右移n位，即是该数除以2的n次幂1234-12 &gt;&gt; 2 = ?答： -3 12 &gt;&gt; 2 = ?答： 3 &gt;&gt;&gt; 无符号右移 高位空位，全部填0，用0补位1234-12 &gt;&gt;&gt; 2 = ?答： 3 12 &gt;&gt;&gt; 2 = ?答： 3 应用 请用效率最高的方法求出 2*8 的值。 1System.out.println(2&lt;&lt;3); 两个整数值互换（不使用第三方变量） 1234567891011方法1：（不建议使用，如果数值过大，可能丢失精度）int a = 3, b = 5;a = a + b;b = a - b;a = a - b方法2：（利用异或位运算）int a = 3, b = 5;a = a ^ b;b = a ^ b;a = a ^ b; 三元运算符 （条件表达式）？表达式1：表达式2 若条件为true ，结果为表达式1若条件为false，结果为表达式21234练习：在x , y中取 值较大的整数int x = 3, y = 4;int max = ( x&gt;y )? x : y;System.out.println(max); swich 和 if else 与 三元运算符 三元运算符必须有结果，if else可有，可不有结果。当if else有具体运算结果时，可以使用三元运算符。 1234567891011121314151617swich使用示范： int x = 3; swich(x) &#123; case 1: System.out.println(x); break; case 2: System.out.println(x); break; case 3: System.out.println(x); break; case default: System.out.println(x); break; &#125; if： 对几个具体值进行判断 对区间判断 对运算结果boolean类型表达式判断 swich： 对几个具体值进行判断 值的个数通常是固定的 对几个固定值判断，建议使用swich，swich将答案存在内存中，效率高]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 链表实现]]></title>
    <url>%2F2018%2F04%2F06%2FJava-%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[分享一下我用java实现的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public class LinkList&lt;T&gt; &#123; private Node&lt;T&gt; head; //头节点 private Node&lt;T&gt; tail; //尾节点 /** * 构造空链表 */ public LinkList()&#123; head = tail = null; &#125; /** * 链表内部的节点类 */ private static class Node&lt;T&gt;&#123; T data; //节点的数据 Node&lt;T&gt; next; //该节点指向下一个节点的指针 Node(T data)&#123; this.data = data; this.next = null; &#125; &#125; /** * 为空链表增加头节点 */ public void addHead(T point)&#123; this.head = new Node&lt;T&gt;(point); if(tail == null)&#123; tail = head; &#125; &#125; /** * 为链表增加尾节点 */ public void addTail(T point)&#123; tail = new Node&lt;T&gt;(point); head.next = tail; &#125; /** * 插入节点（头插法） */ public void addNode(T point)&#123; if(this.head==null) //添加头节点 addHead(point); else if(this.tail==this.head) //在头节点后添加尾节点 addTail(point); else&#123; Node&lt;T&gt; newNode = new Node&lt;T&gt;(point); newNode.next = head.next; head.next = newNode; &#125; &#125; /** * 删除节点（通过数据值） */ public void deleteNode(T data)&#123; Node&lt;T&gt; curr = head ,pre = null; boolean flag = false; //判断要删除的节点是否存在 while(curr != null)&#123; if(curr.data.equals(data))&#123; if (curr==head)&#123; //删除头节点 System.out.println(&quot;delete the head Node&quot;); head = curr.next; flag = true; &#125;else if (curr==tail)&#123; //删除尾节点 System.out.println(&quot;delete the tail Node&quot;); tail = pre; pre.next = null; flag = true; &#125;else &#123; //删除中间节点 System.out.println(&quot;delete the center Node&quot;); pre.next = curr.next; flag = true; &#125; &#125; pre = curr; curr = curr.next; &#125; if (flag == false) System.out.println(&quot;链表中不存在该数据&quot;); &#125; /** * 查找链表中的元素（通过位置） */ public void findKth(T point)&#123; Node&lt;T&gt; curr = head , pre = null; int k = 1; boolean flag = false; while (curr != null)&#123; if(point.equals(k))&#123; System.out.println(&quot;第&quot;+k+&quot;位的值是&quot;+curr.data); flag = true; &#125; pre = curr; curr = curr.next; k++; &#125; if(flag==false) System.out.println(&quot;查找的位置在链表中不存在&quot;); &#125; /** * 查找链表中的元素（通过值） */ public void findByValue(T data)&#123; Node&lt;T&gt; curr = head ; int k = 1; boolean flag = false; while(curr!=null)&#123; if(curr.data==data)&#123; System.out.println(&quot;查找的值在链表中的第&quot;+k+&quot;位&quot;); flag = true; &#125; curr = curr.next; k++; &#125; if(flag==false) System.out.println(&quot;查找的值在链表中不存在&quot;); &#125; /** * 输出链表 */ public void printlnLink()&#123; Node&lt;T&gt; curr = this.head; if(curr==null)&#123; System.out.println(&quot;linklist is null&quot;); &#125;else&#123; while(curr!=null)&#123; System.out.print(curr.data+&quot; &quot;); curr = curr.next; &#125;System.out.println(); &#125; &#125; public static void main(String[] args)&#123; LinkList linkList = new LinkList&lt;Integer&gt;(); linkList.addNode(5); linkList.addNode(8); linkList.addNode(10); linkList.addNode(6); linkList.addNode(9); System.out.println(&quot;TailNode: &quot;+linkList.tail.data); linkList.deleteNode(8); linkList.printlnLink(); linkList.findByValue(5); linkList.findKth(10); System.out.print(&quot;&quot;); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java易错知识点]]></title>
    <url>%2F2018%2F04%2F06%2FJava%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[最近在看Java基础知识的视频，因为距离大二学习基础知识的时光有些久远了，并且当时也并没有进行总结，所以写下这个博客权当做笔记，方便温故而知新。 强制转换1234567891011第一种情况 byte a = 1; a = 3 + 4; System.out.println(a); 第二种情况 byte a = 1; byte b = 3; byte c = 4; a = b + c; System.out.println(a); 在这两种情况下，最后运行的值有什么不同那？ 第一个的值最后为7；第二个运行后运行错误，显示可能损失精度。 第一种情况下，因为3和4是int值，a是byte值，当a=3+4时，运算符对左右两边进行了一个判断，如果右边的数在byte的范围内，则自动将其强制转换，赋值给a。 第二种情况下，b、c都是变量，系统不可以自动将其强制转换，因为他们可能是一个大于byte范围的数。 算数运算符12345678910111213141516第一种情况 int x = 3, y; y = x++; System.out.println(x); System.out.println(y); 第二种情况 int x = 3, y; y = ++x; System.out.println(x); System.out.println(y); 第三种情况 int a = 3; a = a++; System.out.println(a); 运行结果分别是什么？ 123x = 4 y = 3x = 4 y = 4a = 3 第一种情况涉及到了运算符的原理，系统是如何对 y=x++ 这个式子进行处理的那，先将 x 原先的值3存储起来，再对x进行++运算，最后进行=运算的时候将预存的x的值赋给y。 第二种情况主要式子是 y=++x ，这次是直接进行 ++x 的运算，再将他赋给y。 第三种情况和第一种情况大致相同，为了方便理解，我将 a = a++ 在内存中的处理过程写成程序。通过下面的代码就能够了解为什么最后的结果是3了。 1234int a = 3;temp = a;a++;a = temp; +=运算问题123short s = 3;s += 4;s = s + 4; 第二个式子和第三个式子有什么不同？ 第二个式子可以运行成功，第三个式子不可以。在这里4是int值，+=是一个运算符，他会对右边的数进行判断，是否在short的范围内再自动进行强制转换，赋值给s。而第三个式子=的右面面对的是变量s，必须手动进行强制转换。 %运算问题12a = -5 % 2;b = 5 % -2; a和b的值分别是多少？ a = -1，b = 1 取模运算只有 %左边是负数的情况下对结果有影响]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo博客]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[经过了好一段时间的折腾，终于成功搭建好了博客。我就在这里分享一些使用Hexo+Github搭建的心得。既是为了分享，也是为了防止自己遗忘，备份之用。 搭建前准备工作 1.安装node.js 2.安装git 3.安装hexo （右键git bash 运行$ npm install -g hexo） 本地搭建静态博客 1.新建一个文件夹 如MyBlog 2.生成git模板 在MyBlog文件夹内，右键git bash输入$ hexo init 3.运行npm install 4.运行npm server 5.http://localhost:4000 可以看到本地搭建的博客 将博客关联github 在github上创建名字为XXX.github.io项目(XXX为用户名) 打开本地MyBlog文件夹内的_config.yml配置文件 ,拉到最底下，更改为 1234deploy: type: git repository: https://github.com/OrangeTop/OrangeTop.github.io.git branch: master 第一次使用git需要配置ssh,引号处填写自己的邮箱 1git bash $ ssh-keygen -t rsa -C "your_email@youremail.com" 然后一路回车即可成功生成.ssh文件 在C:\users\用户名.ssh文件夹中，打开id_rsa.pub，全部复制。然后回到github网站，进入setting选择SSH and GPG–&gt;New SSh Keytitle随意填，Key粘贴 1验证:git bash $ ssh -T git@github.com 上传本地仓库， 右键git bash。 (引号处注意填写自己的信息) 12$ git config --global user.name &quot;your name&quot; $ git config --global user.email &quot;your_email@youremail.com&quot; 继续部署，中途需要输入用户名密码 123$ npm install hexo-deployer-git --save$ hexo g$ hexo d 最后在浏览器输入OrangeTop.github.io 即可看见博客 The First Blog 进入MyBlog文件夹右键git bash123456789101112//创建新的博客，文件在source-&gt;_posts文件夹下hexo new &quot;新的文件名&quot;//运行hexo，访问本地localhost:4000可预览hexo s//进入MyBlog文件夹下的public文件夹cd public//本地生成静态文件hexo g//返回MyBlog文件夹cd ..//将本地静态文件推送至githubhexo d 报错解决 下载hexo报错 12345$ npm install -g hexonpm ERR! Unexpected end of JSON input while parsing near &apos;...&quot;commander&quot;:&quot;*&quot;&#125;,&quot;opt&apos;npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\75173\AppData\Roaming\npm-cache\_logs\2018-03-27T13_25_30_385Z-debug.log 解决方法 1234更换为淘宝镜像npm --registry https://registry.npm.taobao.org install express 检验是否更换成功npm config get registry 若不成功，继续 1234清理缓存npm cache clean –force重新安装npm install -g hexo 使用一段时间后，hexo d上传失败，ssh连接github失败 1234打开C:\Windows\System32\drivers\etc目录下的hosts文件再最后面加上下面两行192.30.253.112 github.com192.30.253.113 github.com 参考文章 教你搭一个博客 Hexo博客搭建教程]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2F2018%2F03%2F28%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[尼采说： Was mich nicht umbringt, macht mich stärker.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
