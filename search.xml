<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[十大经典排序算法]]></title>
    <url>%2F2018%2F12%2F15%2F%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[十大经典排序算法（动图演示） 算法概述算法分类十种常见排序算法可以分为两大类： 非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。 线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 算法复杂度 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 1、冒泡排序（Bubble Sort）冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 1.1 算法描述 比较相邻的元素。如果第一个比第二个大，就交换它们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 重复步骤1~3，直到排序完成。 1.2 动图演示 1.3 代码实现123456789101112131415161718public class BubbleSort &#123; public static int[] bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) swap(arr, j, j + 1); &#125; &#125; return arr; &#125; public static void swap(int[] arr, int a, int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125;&#125; 2、选择排序（Selection Sort）选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 2.1 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区； n-1趟结束，数组有序化了。 2.2 动图演示 2.3 代码实现1234567891011121314151617181920public class SelectionSort &#123; public static void selectionSort(int[] arr) &#123; int minIndex = 0; for (int i = 0; i &lt; arr.length - 1; i++) &#123; minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[minIndex] &gt; arr[j]) minIndex = j; &#125; swap(arr, i, minIndex); &#125; &#125; public static void swap(int[] arr, int a, int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125;&#125; 2.4 算法分析表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。 3、插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 3.1 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 3.2 动图演示 3.2 代码实现123456789101112131415161718public class InsertionSort &#123; public static void insertionSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0; j--) &#123; if (arr[j]&lt;arr[j-1])&#123; swap(arr, j, j-1); &#125; &#125; &#125; &#125; public static void swap(int[] arr, int a, int b) &#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125;&#125; 3.4 算法分析插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 4、希尔排序（Shell Sort）1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。 4.1 算法描述先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中 ti &gt; tj ，tk = 1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 4.2 动图演示 4.3 代码实现1234567891011121314151617181920public class ShellSort &#123; public static void shellsort(int[] arr) &#123; int temp; for (int gap = arr.length / 2; gap &gt;= 1; gap /= 2) &#123; //对每个增量进行一次排序 for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i; j &gt;= gap; j -= gap) &#123; //注意每个地方增量和差值都是gap if (arr[j-gap]&gt;arr[j]) swap(arr, j, j - gap); &#125; &#125;//loop i &#125;//loop gap &#125; public static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 4.4 算法分析希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。 5、归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 5.1 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 5.2 动图演示 5.3 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243public class MergeSort &#123; public static void mergeSort(int[] arr) &#123; mergeSort(arr, 0, arr.length - 1); &#125; public static void mergeSort(int[] arr, int low, int high) &#123; int mid = low + (high - low) / 2; if (low &lt; high) &#123; mergeSort(arr, low, mid); mergeSort(arr, mid + 1, high); merge(arr, low, mid, high); System.out.println(Arrays.toString(arr)); &#125; &#125; public static void merge(int[] arr, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low;// 左指针 int j = mid + 1;// 右指针 int k = 0; // 把较小的数先移到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (arr[i] &lt; arr[j]) &#123; temp[k++] = arr[i++]; &#125; else &#123; temp[k++] = arr[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; temp[k++] = arr[i++]; &#125; // 把右边边剩余的数移入数组 while (j &lt;= high) &#123; temp[k++] = arr[j++]; &#125; // 把新数组中的数覆盖nums数组 for (int k2 = 0; k2 &lt; temp.length; k2++) &#123; arr[k2 + low] = temp[k2]; &#125; &#125;&#125; 5.4 算法分析归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。 6、快速排序（Quick Sort）快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 6.1 算法描述快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下： 从数列中挑出一个元素，称为 “基准”（pivot）； 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 6.2 动图演示 6.3 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class QuickSort &#123; //判断数组是否为空 private static boolean isEmpty(int[] arr) &#123; return arr == null || arr.length == 0; &#125; //在主类中调用该方法，对数组进行排序 public static void quickSort(int[] arr) &#123; if (isEmpty(arr)) System.out.println("数组为空，请输入数据后再排序！！！"); quickSort(arr, 0, arr.length - 1); &#125; //也可以选择在主类中调用该方法，对数组指定位置进行排序 public static void quickSort(int[] arr, int low, int high) &#123; if (isEmpty(arr)) return; if (low &lt; high) &#123; //基准数据在数组中所在的角标 int pivotKey = partion(arr, low, high); //将基准左部递归排序 quickSort(arr, low, pivotKey - 1); //将基准右部递归排序 quickSort(arr, pivotKey + 1, high); &#125; &#125; private static int partion(int[] arr, int start, int end) &#123; //以第一个数据为基准 int pivot = arr[start]; while (start &lt; end) &#123; //从数组右端开始，若数据大于基准值，end指针-1 //反之则交换该数据值和基准值，并且将start++ while (arr[end] &gt;= pivot &amp;&amp; start &lt; end) end--; if (start &lt; end) &#123; arr[start] = arr[end]; start++; &#125; //从数组左端开始，若数据小于基准值，start指针+1 //反之则交换该数据值和基准值，并且将end-- while (arr[start] &lt; pivot &amp;&amp; start &lt; end) start++; if (start &lt; end) &#123; arr[end] = arr[start]; end--; &#125; &#125; //返回基准值在数组中的角标 return start; &#125; //函数功能：交换数组中两个数据值 private static void swap(int[] arr,int i,int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树和AVL树]]></title>
    <url>%2F2018%2F12%2F10%2F%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8CAVL%E6%A0%91%2F</url>
    <content type="text"><![CDATA[平衡二叉树平衡二叉树：对于任意一个节点，左子树和右子树的高度差不能超过1 平衡二叉树的高度和节点数量之间的关系也是 O(log N) 什么是平衡二叉树二分搜索树可以表示动态的数据集合，对于给定的数据集合，在建立一颗二分搜索树时，二分搜索树的结构形态与关键字的插入顺序有关。如果全部或者部分地按照关键字的递增或者递减顺序插入二分搜索树的结点，则所建立的二分搜索树全部或者在局部形成退化的单分支结构。 在最坏的情况下，二分搜索树可能完全偏斜，高度为n，其平均与最坏的情况下查找时间都是O(n)；而最好的情况下，二分搜索树的结点尽可能靠近根结点，其平均与最好情况的查找时间都是O(logn)。因此，我们希望最理想的状态下是使二分搜索树始终处于良好的结构形态。 实现平衡二叉树我们可以使用之前文章实现的 “二分搜索树的实现” 作为底层代码进行修改 (点击这里查看文章) 实现二分搜索树 点击下载-AVLTree.java 12345678910111213141516171819202122232425public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; &#123; private class Node&#123; public K key; public V value; public Node left, right; public int height; public Node(K key, V value)&#123; this.key = key; this.value = value; left = null; right = null; height = 1; &#125; &#125; private Node root; private int size; public AVLTree()&#123; root = null; size = 0; &#125;&#125; 计算节点高度及平衡因子节点高度：节点的高度。 平衡因子：左子树的高度 减去 右子树的高度 即为该节点的平衡因子。（平衡二叉树的平衡因子只能为1，0，-1） 12345678910111213// 获得节点node的高度private int getHeight(Node node)&#123; if(node == null) return 0; return node.height;&#125;// 获得节点node的平衡因子private int getBalanceFactor(Node node)&#123; if(node == null) return 0; return getHeight(node.left) - getHeight(node.right);&#125; 检查二分搜索树性质及平衡性检查BST：将该树下的所有节点通过中序遍历存储于数组中，如果升序排列，即是二分搜索树 1234567891011121314151617181920// 判断该二叉树是否是一棵二分搜索树public boolean isBST()&#123; ArrayList&lt;K&gt; keys = new ArrayList&lt;&gt;(); inOrder(root, keys); for(int i = 1 ; i &lt; keys.size() ; i ++) if(keys.get(i - 1).compareTo(keys.get(i)) &gt; 0) return false; return true;&#125;private void inOrder(Node node, ArrayList&lt;K&gt; keys)&#123; if(node == null) return; inOrder(node.left, keys); keys.add(node.key); inOrder(node.right, keys);&#125; 检查平衡性：如果树中每一个节点的平衡因子均为 1，0，-1中的数，即是平衡二叉树 12345678910111213141516// 判断该二叉树是否是一棵平衡二叉树public boolean isBalanced()&#123; return isBalanced(root);&#125;// 判断以Node为根的二叉树是否是一棵平衡二叉树，递归算法private boolean isBalanced(Node node)&#123; if(node == null) return true; int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor) &gt; 1) return false; return isBalanced(node.left) &amp;&amp; isBalanced(node.right);&#125; 旋转基本原理在平衡二叉树中删除或插入节点后，可能会使某些节点的平衡因子的绝对值大于 ，即树失去了平衡，这时候就需要进行平衡调整，使其重新满足平衡二叉树的要求。 调整平衡二叉树之前，首先要明白一个定义：最小不平衡子树。最小不平衡子树是指以离插入节点最近、且平衡因子绝对值大于1的节点做根的子树。 左旋转和右旋转LL：新插入的节点 在 最小不平衡子树的根节点 的左侧的左侧，需要进行右旋转。 RR：新插入的节点 在 最小不平衡子树的根节点 的右侧的右侧，需要进行左旋转。 12345678910111213141516171819202122// 对节点y进行向右旋转操作，返回旋转后新的根节点x// y x// / \ / \// x T4 向右旋转 (y) z y// / \ - - - - - - - -&gt; / \ / \// z T3 T1 T2 T3 T4// / \// T1 T2private Node rightRotate(Node y) &#123; Node x = y.left; Node T3 = x.right; // 向右旋转过程 x.right = y; y.left = T3; // 更新height y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x;&#125; 12345678910111213141516171819202122// 对节点y进行向左旋转操作，返回旋转后新的根节点x// y x// / \ / \// T1 x 向左旋转 (y) y z// / \ - - - - - - - -&gt; / \ / \// T2 z T1 T2 T3 T4// / \// T3 T4private Node leftRotate(Node y) &#123; Node x = y.right; Node T2 = x.left; // 向左旋转过程 x.left = y; y.right = T2; // 更新height y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1; x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1; return x;&#125; LR和RLLR：新插入的节点 在 最小不平衡子树的根节点 的左侧的右侧，需要进行左旋左子树，再右旋。 RL：新插入的节点 在 最小不平衡子树的根节点 的右侧的左侧，需要进行右旋右子树，再左旋。 插入节点插入节点时，需要进行三个新增的步骤 高度的更新 计算平衡因子 平衡的维护，即左右旋转 12345678910111213141516171819202122232425262728293031323334353637383940414243private Node add(Node node, K key, V value)&#123; if(node == null)&#123; size ++; return new Node(key, value); &#125; if(key.compareTo(node.key) &lt; 0) node.left = add(node.left, key, value); else if(key.compareTo(node.key) &gt; 0) node.right = add(node.right, key, value); else // key.compareTo(node.key) == 0 node.value = value; // 更新height node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right)); // 计算平衡因子 int balanceFactor = getBalanceFactor(node); // 平衡维护 // LL -&gt; 右旋转 if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &gt;= 0) return rightRotate(node); // RR -&gt; 左旋转 if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &lt;= 0) return leftRotate(node); // LR -&gt; 先左旋根节点的左子树，再右旋转 if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(node.left) &lt; 0) &#123; node.left = leftRotate(node.left); return rightRotate(node); &#125; // RL -&gt; 先右旋根节点的右子树，再左旋转 if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(node.right) &gt; 0) &#123; node.right = rightRotate(node.right); return leftRotate(node); &#125; return node;&#125; 删除节点可以将二分搜索树实现的代码中的删除节点操作，拿过来更改一下。 原来代码中删除节点没有维护平衡，所以我们创建一个 retNode，在最后面统一进行维护 删除节点进行平衡维护的代码本质 和 插入节点平衡维护代码是一样的，可以复用 调用 removeMin(node.right) 方法时，并没有维持节点平衡，可能会将其打破，可以改为remove(node.right,successor.key)；因为代码含义就是删除节点右子树最小节点 当key.compareTo(node.key)==0时，后续进行的代码逻辑需要改一下，if,else if,else 进行平衡维护时，需要对retNode进行判空操作，否则会出现异常 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384private Node remove(Node node, K key)&#123; if( node == null ) return null; Node retNode; if( key.compareTo(node.key) &lt; 0 )&#123; node.left = remove(node.left , key); // return node; retNode = node; &#125; else if(key.compareTo(node.key) &gt; 0 )&#123; node.right = remove(node.right, key); // return node; retNode = node; &#125; else&#123; // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; // return rightNode; retNode = rightNode; &#125; // 待删除节点右子树为空的情况 else if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; // return leftNode; retNode = leftNode; &#125; // 待删除节点左右子树均不为空的情况 else&#123; // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); //successor.right = removeMin(node.right); successor.right = remove(node.right, successor.key); successor.left = node.left; node.left = node.right = null; // return successor; retNode = successor; &#125; &#125; if(retNode == null) return null; // 更新height retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right)); // 计算平衡因子 int balanceFactor = getBalanceFactor(retNode); // 平衡维护 // LL if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &gt;= 0) return rightRotate(retNode); // RR if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &lt;= 0) return leftRotate(retNode); // LR if (balanceFactor &gt; 1 &amp;&amp; getBalanceFactor(retNode.left) &lt; 0) &#123; retNode.left = leftRotate(retNode.left); return rightRotate(retNode); &#125; // RL if (balanceFactor &lt; -1 &amp;&amp; getBalanceFactor(retNode.right) &gt; 0) &#123; retNode.right = rightRotate(retNode.right); return leftRotate(retNode); &#125; return retNode;&#125; 基于AVL实现集合映射 点击下载-AVLMap.java 点击下载-AVLSet.java 我们底层使用的是基于键值对的 AVL ，所以既可以很方便的实现映射，也可以方便的实现集合。 当实现集合时，不需要value值，我们只需要将其作为Object类型，传null值 即可。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoogleVoice全攻略]]></title>
    <url>%2F2018%2F12%2F04%2FGoogleVoice%E5%85%A8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[最近弄来了一个Google Voice 的号码，感觉挺有用的，本想写篇文章科普一下。但是后来发现网上有许多文章，于是就挑了一篇不错的转载了过来！ 获取一个美国手机号，Google Voice 攻略全记录 转载自：数字移民 ‘s Blog 0. Null获得一个长期可用、完全属于自己的手机号十分有必要。一方面，注册美区 PayPal 时需要绑定美国手机号，同时众多互联网服务提升账户安全性（账户异常需绑定手机号增加安全性），两步验证也需要手机号。提供美国虚拟号码的服务有很多，但是稳定且方便实惠的只有 Google Voice 一个。虽然有关 Google voice 的教程已经很多了，但是作为一项基本技能，「数字移民」博客还是有必要再介绍一下。本文介绍 Google Voice 的获取，绑定，充值，保留等。 1. Google Voice 简介Google Voice 是由 Google 推出的 VOIP 服务。简单来说，你可以获得一个虚拟美国号码，可以接听其他绑定的实体美国号码，也可以单独使用这个号码拨打电话，接收短信等；拨打美国号码免费，其他地区费率也极低。 2. Google Voice 获取及转移拥有美国实体号码的情况下，可以直接验证获取一个 Google voice 虚拟号码。很多人会尝试钻漏洞，用各种免费软件提供的虚拟号码来进行验证，时间成本过高，且成功率不高，在此不赘述。推荐在淘宝上直接购买。购买会获得一个 Google 账号 和其中含有的 Google voice 手机号，推荐购买后转移到自己的 Google 账号下。 下面介绍转移过程 1.1 进入 Google voice 界面，登陆含有 Google voice 的 Google 账号，输入账号密码后，一般会验证密保邮箱，这个卖家一般也会提供。进入设置 界面，点击 Transfer ￼ 1.2 会自动跳转老版本的 Google voice 界面，继续点击 transfer ￼ 1.3 点击登陆自己的 Google 账号（即目标账号）￼ 1.4 登陆后点击选中自己的 Google 账号 ￼ 1.5 点击继续 ￼ 1.6 忽略需要添加实体号码的提醒，点击继续，即可转移成功。 ￼ 3. 使用 Hangouts 拨打电话Google voice 提供 App 可以用来接收短信和电话，但 Google voice 这个 app 限制必须绑定美国真实手机号后才能拨打电话，所以推荐使用 Google Hangouts，可以绕过限制。Google hangouts 是 Google 的一个即时通讯软件，Gmail 中左下角聊天功能即是 Google hangouts。 具体设置方法： 2.1 登陆 Google Hangouts ，进入设置，在设置中勾选 接收 Google voice短信及电话 ￼ 2.2 验证是否成功，在Google voice 的设置界面即可查看是否绑定成功。￼ 4. Google voice 的用处 注册美区 PayPal 可用于验证美国手机号。 使用美国手机号注册 Telegram，可以减少账号被限制的风险。 绑定 Facebook 和 Twitter，开启两步验证，避免因使用 VPN 账号导致被封。 （使用部分代理服务可能导致社交账号行为 与 机构养号的行为很接近） 不建议使用 Google voice 号码来拨打美国各种服务的客服电话，连接效果较差，且有可能被系统识别阻拦等。 5. Google Voice 充值Google voice 无法在 iOS 应用中充值。推荐打开 Google voice网页版本（桌面端移动端均可），直接在设置中找到充值页面，单次充值可充10/25/50美元，总余额不能超过70美元。 因为充值使用的是 Google Pay，需要绑定 Visa/Mastercard 等外币信用卡才能使用，不支持银联信用卡。Google Play 礼品卡冲的余额似乎没发用来充值 Google voice （待确认）。 6. Google voice 保号Google voice 作为一项公共资源，Google 会不定期收回不活跃的手机号，回收前会提前一个月进行邮件通知。推荐使用 IFTTT 服务，定时使用 Google voice 拨打电话以保持活跃度。 即使充值了，若长期只收短信而不是使用也会有被销号的可能。建议添加提醒，每隔一两个月打个电话，或者发个短信保持活跃度。 IFTTT 使用截图待补充。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java-并查集]]></title>
    <url>%2F2018%2F11%2F29%2FJava-%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集（Union Find）什么是并查集并查集是一种树型的数据结构，其保持着用于处理一些 不相交集合（Disjoint Sets）的 合并及查询 问题。其包含合并集合 和 查找集合中的元素 两种操作。并且其常用于解决 动态连通性一类问题 实现并查集实现有两种方式 分别是： 简单元素替换 和 代表元素合并 Quick Find可以将该方法考虑为，为数据分为不同的集合，每次合并一个新的元素进来的时候，都要将原来集合里所有元素的值都修改为新并入元素的值。实现简单就是每次更新需要遍历一遍集合 1234567public interface UF &#123; int getSize(); boolean isConnected(int p, int q); void unionElements(int p, int q);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243public class UnionFind implements UF &#123; private int[] id; public UnionFind(int size) &#123; id = new int[size]; for (int i = 0; i &lt; id.length; i++) &#123; id[i] = i; &#125; &#125; @Override public int getSize() &#123; return id.length; &#125; // 查找元素 P 对应的集合编号 private int find(int p) &#123; if (p &lt; 0 || p &gt; id.length) throw new IllegalArgumentException("p is out of bound."); return id[p]; &#125; @Override public boolean isConnected(int p, int q) &#123; return find(p) == find(q); &#125; @Override public void unionElements(int p, int q) &#123; int pID = find(p); int qID = find(q); if (pID == qID) return; for (int i = 0; i &lt; id.length; i++) &#123; if (id[i] == pID) id[i] = qID; &#125; &#125;&#125; 它查找元素的时间复杂度非常低，只有O(1)，而合并集合元素的时候时间复杂度达到了O(N)。这种实现看起来还可以，就是感觉合并的时候似乎慢了一点，那么有没有办法使得合并的操作快点呢？ Quick Union和前面归并元素的思路不同，这里采用的是一种类似于树的层次结构。我们可以创建一个 parent 数组，数组元素值是其下标的父节点。按照这个思路，如果我们将一个元素并入到一个集合的时候，我们可以修改这个集合的代表元素，只要这个代表元素的值为这个并入的元素就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class UnionFind2 implements UF &#123; // 我们的第二版Union-Find, 使用一个数组构建一棵指向父节点的树 // parent[i]表示第一个元素所指向的父节点 private int[] parent; // 构造函数 public UnionFind2(int size)&#123; parent = new int[size]; // 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合 for( int i = 0 ; i &lt; size ; i ++ ) parent[i] = i; &#125; @Override public int getSize()&#123; return parent.length; &#125; // 查找过程, 查找元素p所对应的集合编号 // O(h)复杂度, h为树的高度 private int find(int p)&#123; if(p &lt; 0 || p &gt;= parent.length) throw new IllegalArgumentException("p is out of bound."); // 不断去查询自己的父亲节点, 直到到达根节点 // 根节点的特点: parent[p] == p while(p != parent[p]) p = parent[p]; return p; &#125; // 查看元素p和元素q是否所属一个集合 // O(h)复杂度, h为树的高度 @Override public boolean isConnected( int p , int q )&#123; return find(p) == find(q); &#125; // 合并元素p和元素q所属的集合 // O(h)复杂度, h为树的高度 @Override public void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if( pRoot == qRoot ) return; parent[pRoot] = qRoot; &#125;&#125; 这种实现里，查找所在集合的代表元素需要遍历它的父节点，直到它和它的下标值相同。但是归并的时候只要修改一个元素的值就可以了。不过从最坏的情况来看，查找这个集合的根节点的时间复杂度就可能将近O(N)了。看来这个办法是使得归并的操作简单了，但是整体的时间复杂度并没有完全降下去。 那么还有没有什么办法可以改进呢？ 优化在前面的 代替元素合并 方法中，会有极端的情况是因为，没有合并集合时进行判断，如果集合越来越长，也就退化成为了链表。所以，我们可以在这里进行优化，将要合并的两个集合进行判断（元素数量或高度），把数值低的纳入在高的下面，可以大大提升效率 基于Size优化基于 Size 优化并不如基于 Rank 优化效果好，而且代码也很简单，所以就不详细列出了。若有兴趣，可以观察下面的代码，进行仿写。 基于Rank优化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class UnionFind4 implements UF &#123; private int[] rank; // rank[i]表示以i为根的集合所表示的树的层数 private int[] parent; // parent[i]表示第i个元素所指向的父节点 // 构造函数 public UnionFind4(int size)&#123; rank = new int[size]; parent = new int[size]; // 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合 for( int i = 0 ; i &lt; size ; i ++ )&#123; parent[i] = i; rank[i] = 1; &#125; &#125; @Override public int getSize()&#123; return parent.length; &#125; // 查找过程, 查找元素p所对应的集合编号 // O(h)复杂度, h为树的高度 private int find(int p)&#123; if(p &lt; 0 || p &gt;= parent.length) throw new IllegalArgumentException("p is out of bound."); // 不断去查询自己的父亲节点, 直到到达根节点 // 根节点的特点: parent[p] == p while(p != parent[p]) p = parent[p]; return p; &#125; // 查看元素p和元素q是否所属一个集合 // O(h)复杂度, h为树的高度 @Override public boolean isConnected( int p , int q )&#123; return find(p) == find(q); &#125; // 合并元素p和元素q所属的集合 // O(h)复杂度, h为树的高度 @Override public void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if( pRoot == qRoot ) return; // 根据两个元素所在树的rank不同判断合并方向 // 将rank低的集合合并到rank高的集合上 if(rank[pRoot] &lt; rank[qRoot]) parent[pRoot] = qRoot; else if(rank[qRoot] &lt; rank[pRoot]) parent[qRoot] = pRoot; else&#123; // rank[pRoot] == rank[qRoot] parent[pRoot] = qRoot; rank[qRoot] += 1; // 此时, 我维护rank的值 &#125; &#125;&#125; 路径压缩经过上面的优化，效率已经有了很大的提升。在运行中，有很大的一部分时间是花在了，通过一个节点查找其根节点上。我们要是在这个时间段上，进行路径的压缩会不会更有效果那？ 非递归路径压缩12345678910private int find(int p)&#123; if(p &lt; 0 || p &gt;= parent.length) throw new IllegalArgumentException("p is out of bound."); while(p != parent[p])&#123; parent[p] = parent[parent[p]]; p = parent[p]; &#125; return p;&#125; 进行简单的路径压缩，只需要对 基于Rank 优化的代码中 find方法 进行改动即可 代码含义是 ： 把从当前叶节点到向上每两层的节点都指向自己的祖父节点 递归路径压缩123456789private int find(int p)&#123; if(p &lt; 0 || p &gt;= parent.length) throw new IllegalArgumentException("p is out of bound."); if(p != parent[p])&#123; parent[p] = find(parent[p]); &#125; return parent[p];&#125; 如此改动之后，则会将所有元素，指向根节点。 添加路径压缩后，并查集的时间复杂度是 O(log*n) ，比 O(log(n)) 还要快一点 相关问题主要用于解决动态连接性问题，LeetCode上面有并查集的标签可以尝试一下]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客图床更换]]></title>
    <url>%2F2018%2F11%2F09%2F%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E6%9B%B4%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[缘由前几天收到了邮件，说是七牛云测试域名 要被收回了，这可就尴尬了，在今天之前，我的博客图片都是托管在七牛云的，如果收回测试域名的话，博客里面的图片就不能访问了，只能更换图床 或者 买域名备案使用二级域名CDN加速，上网查了一下备案的流程，简直让人头大，还是直接更换图床吧！ 导出七牛云存放图片七牛云存储空间不能直接导出所有托管图片，不过可以使用官方的 命令行工具 (点击跳转) 1、下载qshell 2、设置当前用户的AccessKey和SecretKey （七牛云官网 - 个人中心） 3、配置 qdisk_down.conf （需创建在包含命令行文件夹内，并自行修改字符串） 1234567&#123; "dest_dir" : "C://Users//75173//Pictures//qiniu", "bucket" : "forblog", "cdn_domain" : "p6wpjrumy.bkt.clouddn.com", "prefix" : "", "suffixes" : ""&#125; 4、使用qshell 语句 qdownload 10 qdisk_down.conf1qshell qdownload 10 qdisk_down.conf 图床选择付费的有腾讯云、阿里云 等等 免费无需备案的有 sm.ms 、 github 等等 存入Github为了后面的迁移方便，保证原有链接只需替换前缀，所以选择 Github 1、在GitHub上新建一个repository 2、使用下面的命令将其clone到本机你想要的目录中 （这里我以我的Github地址作为例子，将其改为你自己新建的就好了） clone 地址1git clone git@github.com:OrangeTop/BlogImage.git 3、把图片放到本机你刚clone到的目录中。注意，是可以分目录来分类的，支持中文目录。 4、然后，运行下面的命令 123git add .git commit -m &quot;blog_img&quot;git push origin master 5、以后将图片存放子啊本机之前clone的目录，然后git bash执行下面语令即可 12git commit -m &quot;blog_img&quot;git push origin master 批量替换将文件中原先包含图片链接的代码进行批量替换， 123http://p6wpjrumy.bkt.clouddn.com/hiahia.pnghttps://raw.githubusercontent.com/OrangeTop/BlogImage/master/hiahia.png 如上面所示，将http://p6wpjrumy.bkt.clouddn.com/ 替换为 https://raw.githubusercontent.com/OrangeTop/BlogImage/master/]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-字典树]]></title>
    <url>%2F2018%2F10%2F30%2FJava-%E5%AD%97%E5%85%B8%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Trie树（字典树） 部分转载自 July coding 的GitHub July Coding ‘s article 方法介绍1.1、什么是Trie树Trie树，即字典树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。 Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。 它有3个基本性质： 根节点不包含字符，除根节点外每一个节点都只包含一个字符。 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符都不相同。 1.2、树的构建咱们先来看一个问题：假如现在给你10万个长度不超过10的单词，对于每一个单词，我们要判断它出没出现过，如果出现了，求第一次出现在第几个位置。对于这个问题，我们该怎么解决呢？ 如果我们用最傻的方法，对于每一个单词，我们都要去查找它前面的单词中是否有它。那么这个算法的复杂度就是O(n^2)。显然对于10万的范围难以接受。 换个思路想： 假设我要查询的单词是abcd，那么在它前面的单词中，以b，c，d，f之类开头的显然不必考虑，而只要找以a开头的中是否存在abcd就可以了。 同样的，在以a开头中的单词中，我们只要考虑以b作为第二个字母的，一次次缩小范围和提高针对性，这样一个树的模型就渐渐清晰了。 即如果现在有b，abc，abd，bcd，abcd，efg，hii 这6个单词，我们可以构建一棵如下图所示的树： 如上图所示，对于每一个节点，从根遍历到他的过程就是一个单词，如果这个节点被标记为红色，就表示这个单词存在，否则不存在。 那么，对于一个单词，只要顺着他从根走到对应的节点，再看这个节点是否被标记为红色就可以知道它是否出现过了。把这个节点标记为红色，就相当于插入了这个单词。 这样一来我们查询和插入可以一起完成，所用时间仅仅为单词长度（在这个例子中，便是10）。这就是一棵trie树。 我们可以看到，trie树每一层的节点数是26^i级别的。所以为了节省空间，我们还可以用动态链表，或者用数组来模拟动态。而空间的花费，不会超过单词数×单词长度。 1.3、查询Trie树是简单但实用的数据结构，通常用于实现字典查询。我们做即时响应用户输入的AJAX搜索框时，就是Trie开始。本质上，Trie是一颗存储多个字符串的树。相邻节点间的边代表一个字符，这样树的每条分支代表一则子串，而树的叶节点则代表完整的字符串。和普通树不同的地方是，相同的字符串前缀共享同一条分支。 下面，再举一个例子。给出一组单词，inn, int, at, age, adv, ant, 我们可以得到下面的Trie： 可以看出： 每条边对应一个字母。 每个节点对应一项前缀。叶节点对应最长前缀，即单词本身。 单词inn与单词int有共同的前缀“in”, 因此他们共享左边的一条分支，root-&gt;i-&gt;in。同理，ate, age, adv, 和ant共享前缀”a”，所以他们共享从根节点到节点”a”的边。 查询操纵非常简单。比如要查找int，顺着路径i -&gt; in -&gt; int就找到了。 搭建Trie的基本算法也很简单，无非是逐一把每则单词的每个字母插入Trie。插入前先看前缀是否存在。如果存在，就共享，否则创建对应的节点和边。比如要插入单词add，就有下面几步： 考察前缀”a”，发现边a已经存在。于是顺着边a走到节点a。 考察剩下的字符串”dd”的前缀”d”，发现从节点a出发，已经有边d存在。于是顺着边d走到节点ad 考察最后一个字符”d”，这下从节点ad出发没有边d了，于是创建节点ad的子节点add，并把边ad-&gt;add标记为d。 代码实现构造在这里的 isWord 是一个判定条件，例如字典树中只含有单词panda，需要进行查询是否含有单词pan,则当遍历到n时,进行判断这是否是一个单词，从而得出不包含的结论 1234567891011121314151617181920212223public class Trie &#123; class Node &#123; public boolean isWord; public TreeMap&lt;Character, Node&gt; next; public Node(boolean isWord) &#123; this.isWord = isWord; next = new TreeMap&lt;&gt;(); &#125; public Node() &#123; this(false); &#125; &#125; private Node root; private int size; public Trie() &#123; root = new Node(); size = 0; &#125;&#125; 插入单词1234567891011121314public void insert(String word) &#123; Node cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; char ch = word.charAt(i); if (cur.next.get(ch) == null) cur.next.put(ch, new Node()); cur = cur.next.get(ch); &#125; if (!cur.isWord) &#123; cur.isWord = true; size++; &#125;&#125; 查询单词1234567891011121314public boolean search(String word) &#123; return match(word, root, 0);&#125;private boolean match(String word, Node node, int index) &#123; if (index == word.length()) &#123; return node.isWord; &#125; char ch = word.charAt(index); if (node.next.get(ch) == null) return false; return match(word, node.next.get(ch), index + 1);&#125; 前缀查询12345678910public boolean startsWith(String prefix) &#123; Node cur = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; char ch = prefix.charAt(i); if (cur.next.get(ch) == null) return false; cur = cur.next.get(ch); &#125; return true;&#125; 问题实例1、一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析 提示：用trie树统计每个词出现的次数，时间复杂度是O(n*le)（le表示单词的平均长度），然后是找出出现最频繁的前10个词。当然，也可以用堆来实现，时间复杂度是O(n*lg10)。所以总的时间复杂度，是O(n*le)与O(n*lg10)中较大的哪一个。 2、寻找热门查询 原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复读比较高，虽然总数是1千万，但是如果去除重复和，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。 提示：利用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 相关问题 LeetCode 208 LeetCode 211 LeetCode 677 扩展 压缩字典树 因为字典树空间复杂度很高，所以有了压缩字典树，如下图就是普通字典树向压缩字典树的转换 三分搜索树 后缀树 字符模式识别]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome Plugin]]></title>
    <url>%2F2018%2F10%2F30%2FChrome-Plugin%2F</url>
    <content type="text"><![CDATA[Chrome 作为世界知名浏览器之一，领先的技术，丝滑的用户体验，庞大的浏览器插件，让其一直领先于其他同类产品 不知道大家平常使用chrome的时候，有没有添加一些扩展程序，快来添加一些试试吧！有扩展程序的chrome和没有扩展程序的差距可大多啦！ Momentum一个很漂亮的标签页，上面加了许多功能，还有待办清单。每次打开标签页的时候都会耳目一新 每天新的鼓舞人心的照片和报价 设定每日目标/焦点/意图 通过待办事项列表跟踪任务 查看天气和预报 链接和搜索 在 Chrome Web Store 下载 Momentum Infinity 新标签页自由定制 Chrome 新标签页，加入更加实用的小功能和扩展，里面有许多好用的功能 Gmail 自动提醒 精美天气 标签页主题快速更 自定义添加喜爱的网站 在 Chrome Web Store 下载 Infinity 为什么你们就是不能加个空格呢？有的网页是中文英文数字全部挨在一起的，看起来实在让忍不住在上面加个空格 自从装上了「为什么你们就是不能加个空格呢？」，插件会自动把网页中所有中文、英文、数字、符号之间插入一个空格，大家又可以好好玩耍啦 在 Chrome Web Store 下载 为什么你们就是不能加个空格呢？ ADBlock摆脱烦人广告、恶意软件和跟踪，还你一个清爽网页界面！ 在 Chrome Web Store 下载 ADBlock crxMouse Chrome™ 手势crxMouse Chrome™ 手势具有精彩的功能，实现鼠标导航，这些应用包括： 鼠标手势、超级拖拽、平滑滚动手势和摇杆手势 完全可自定义的鼠标手势、击键、操作和鼠标移动 Windows、Linux 和 Mac 支持 导入和导出配置 只需一个鼠标手势即可实现！crxMouse Chrome™ 手势扩展程序为您带来触手可及的 Chrome 浏览器功能，通过解锁完全可自定义的鼠标手势、击键和鼠标快捷键来提高您的工作效率。 这款鼠标手势扩展程序的功能使导航轻松简单！ 在 Chrome Web Store 下载 crxMouse Chrome™ IE Tab在标签页中以IE内核显示网页。快捷、强健、可靠。 在某些不支持chrome内核的网站使用这个有奇效噢 在 Chrome Web Store 下载 IE Tab The Great Suspenderchrome虽然是一个非常好的浏览器，但是它也太吃内存了。不过有了这个之后，就会冻结暂时用不到的分页，达到系统资源释放的目的 在 Chrome Web Store 下载 The Great Suspender One Tab有时候打开了数十个标签页，不但吃内存，而且看着也不是太美观。如果上面的The Great Suspender没有满足大家的要求的话 赶紧试试 OneTab，不仅节省高达 95% 的内存，还能减轻标签页混乱现象！单击 OneTab 图标，所有标签页转换成一个列表。当你需要再次访问标签页时，可以单独或全部恢复它们。 在 Chrome Web Store 下载 One Tab 划词翻译支持谷歌、百度、有道三大翻译和朗读引擎，可以方便的查看、复制和朗读不同引擎的翻译结果。 一个简便但强大的翻译扩展。 为什么选择划词翻译？ 支持几乎所有语言的翻译与阅读，并且同时支持国内与国外的谷歌翻译； 划词即显示翻译结果，简单方便。可以指定目标语言，例如从中文翻译到法语； 支持在 PDF 文档里使用 单词释义既详细又精准； 自带多种网页翻译，弥补国内Chrome网页翻译总是出错的不足； 完全免费； 无需安装任何第三方软件，麻雀虽小，五脏俱全。 在 Chrome Web Store 下载 划词翻译 Extension Manager一键管理所有扩展，快速开启/禁用、批量闪电管理，智能排序，右键卸载、锁定、选项配置，角标提醒，大小布局随心配。快捷、简单、安全。 一键开启/禁用扩展 闪电分组：根据场景快速开启/禁用扩展组（被锁定或主题类扩展除外） 智能排序：可根据您的使用频率智能排序（默认根据名称排序） 右键菜单：提供锁定、卸载、选项配置、主页、APP运行等快捷功能 智能搜索：通过关键字或词组快速找到需要的扩展 角标提醒：实时显示扩展状态，用完后提醒重置，减少资源占用（被锁定或主题类扩展除外） 在 Chrome Web Store 下载 Extension Manager]]></content>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-线段树]]></title>
    <url>%2F2018%2F10%2F17%2FJava-%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[为什么需要线段树1234题目一：10000个正整数，编号1到10000，用A[1],A[2],A[10000]表示。修改：无统计：1.编号从L到R的所有数之和为多少？ 其中1&lt;= L &lt;= R &lt;= 10000. 方法一：对于统计L,R ，需要求下标从L到R的所有数的和，从L到R的所有下标记做[L..R],问题就是对A[L..R]进行求和。这样求和，对于每个询问，需要将(R-L+1)个数相加 方法二：更快的方法是求前缀和,令 S[0]=0, S[k]=A[1..k] ，那么，A[L..R]的和就等于S[R]-S[L-1]，这样，对于每个询问，就只需要做一次减法，大大提高效率 1234题目二：10000个正整数，编号从1到10000，用A[1],A[2],A[10000]表示。修改：1.将第L个数增加C （1 &lt;= L &lt;= 10000）统计：1.编号从L到R的所有数之和为多少？ 其中1&lt;= L &lt;= R &lt;= 10000. 再使用方法二的话，假如A[L]+=C之后，S[L],S[L+1],,S[R]都需要增加C,全部都要修改，见下表 方法一 方法二 A[L]+=C 修改一个元素 修改R-L+1个元素 求和A[L…R] 计算R-L+1个元素的和 计算两个元素的差 从上表可以看出，方法一修改快，求和慢。 方法二求和快，修改慢。 那有没有一种结构，修改和求和都比较快呢？答案当然是线段树。 线段树 如上我们可以看出线段树不是完全二叉树，而是平衡二叉树，堆也是平衡二叉树 可以将第二张图上的，线段树看作满二叉树，即视缺少的部分为null值 数组表示线段树线段树是一种二叉树，当然可以像一般的树那样写成结构体，指针什么的。但是它的优点是，它也可以用数组来实现树形结构，可以大大简化代码。数组形式适合在编程竞赛中使用，在已经知道线段树的最大规模的情况下，直接开足够空间的数组，然后在上面建立线段树 简单的记法： 足够的空间 = 数组大小n 的四倍。实际上足够的空间 = （n向上扩充到最近的2的某个次方）的两倍 举例子： 假设数组长度为5，就需要5先扩充成8，8 * 2=16. 线段树需要16个元素 如果数组元素为8，那么也需要16个元素 所以线段树需要的空间是n的两倍到四倍之间的某个数，一般就开4 * n的空间就好 如果空间不够，可以自己算好最大值来省点空间。 如何表示 假设某个节点的编号为v，那么它的左子节点编号为2 * v，右子节点编号为2 * v+1 然后规定根节点为1，这样一颗二叉树就构造完成了 通常2 * v在代码中写成 v&lt;&lt;1 。 2 * v + 1写成 v&lt;&lt;1|1 （位运算符） 区间加法用线段树统计的东西或解决的问题，都必须符合区间加法 符合区间加法的例子 数字之和 总数字之和 = 左区间数字之和 + 右区间数字之和 最大公因数（GCD) 总GCD = GCD( 左区间GCD , 右区间GCD ) 最大值 总最大值 = Max(左区间最大值，右区间最大值) 不符合区间加法的例子 众数 只知道左右区间的众数，没法求总区间的众数 序列的最长连续零 只知道左右区间的最长连续零，没法知道总的最长连续零 代码实现融合器 使用融合器有更好的扩展性，完成符合区间加法的操作 123public interface Merger&lt;E&gt; &#123; E merge(E a, E b);&#125; 在线段树构造函数中，将该融合器作为参数，在具体实现的时候可以使用匿名内部类 当然也可以使用 Java 8 新特性，Lambda 表达式 12345678910111213141516171819public class SegmentTree&lt;E&gt; &#123; private E[] tree; private E[] data; private Merger&lt;E&gt; merger; public SegmentTree(E[] arr, Merger&lt;E&gt; merger)&#123; this.merger = merger; data = (E[])new Object[arr.length]; for(int i = 0 ; i &lt; arr.length ; i ++) data[i] = arr[i]; tree = (E[])new Object[4 * arr.length]; buildSegmentTree(0, 0, arr.length - 1); &#125; &#125; 创建区间需要注意的是，创建区间方法中，取左右区间中值的时候，可能会 整型大小溢出，要像下面那么写 1234567891011121314151617181920212223242526272829303132333435363738// 在treeIndex的位置创建表示区间[l...r]的线段树private void buildSegmentTree(int treeIndex, int l, int r)&#123; if(l == r)&#123; tree[treeIndex] = data[l]; return; &#125; int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); // int mid = (l + r) / 2; int mid = l + (r - l) / 2; buildSegmentTree(leftTreeIndex, l, mid); buildSegmentTree(rightTreeIndex, mid + 1, r); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);&#125;public int getSize()&#123; return data.length;&#125;public E get(int index)&#123; if(index &lt; 0 || index &gt;= data.length) throw new IllegalArgumentException("Index is illegal."); return data[index];&#125;// 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引private int leftChild(int index)&#123; return 2*index + 1;&#125;// 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引private int rightChild(int index)&#123; return 2*index + 2;&#125; 获取区间值在线段树中进行对[ queryL，queryR ] 的搜索 首先是对根的左右子树进行判断，判断想获取的区间在左子树，右子树，还是各有一部分 然后进行递归操作，确定准确的区间，并将其返回 123456789101112131415161718192021222324252627282930// 返回区间[queryL, queryR]的值public E query(int queryL, int queryR)&#123; if(queryL &lt; 0 || queryL &gt;= data.length || queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) throw new IllegalArgumentException("Index is illegal."); return query(0, 0, data.length - 1, queryL, queryR);&#125;// 在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[queryL...queryR]的值private E query(int treeIndex, int l, int r, int queryL, int queryR)&#123; if(l == queryL &amp;&amp; r == queryR) return tree[treeIndex]; int mid = l + (r - l) / 2; // treeIndex的节点分为[l...mid]和[mid+1...r]两部分 int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(queryL &gt;= mid + 1) return query(rightTreeIndex, mid + 1, r, queryL, queryR); else if(queryR &lt;= mid) return query(leftTreeIndex, l, mid, queryL, queryR); E leftResult = query(leftTreeIndex, l, mid, queryL, mid); E rightResult = query(rightTreeIndex, mid + 1, r, mid + 1, queryR); return merger.merge(leftResult, rightResult);&#125; 更新更新操作是牵一发而动全身的，不光要进行该单个值的修改，还要对其的祖辈节点进行更改 123456789101112131415161718192021222324252627282930// 将index位置的值，更新为epublic void set(int index, E e)&#123; if(index &lt; 0 || index &gt;= data.length) throw new IllegalArgumentException("Index is illegal"); data[index] = e; set(0, 0, data.length - 1, index, e);&#125;// 在以treeIndex为根的线段树中更新index的值为eprivate void set(int treeIndex, int l, int r, int index, E e)&#123; if(l == r)&#123; tree[treeIndex] = e; return; &#125; int mid = l + (r - l) / 2; // treeIndex的节点分为[l...mid]和[mid+1...r]两部分 int leftTreeIndex = leftChild(treeIndex); int rightTreeIndex = rightChild(treeIndex); if(index &gt;= mid + 1) set(rightTreeIndex, mid + 1, r, index, e); else // index &lt;= mid set(leftTreeIndex, l, mid, index, e); tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);&#125; 实战练习 LeetCode 303 LeetCode 307]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-堆与优先队列]]></title>
    <url>%2F2018%2F10%2F09%2FJava-%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[堆（Heap）基础表示 二叉堆是一颗完全二叉树 什么是完全二叉树？ 将数据一层一层的排列成树的形状，按照树从左到右的顺序，直到放不下为止 也就是说可以如果有空缺的元素，必须是在树的右下方 性质 最大堆：堆中某个节点的值总是不大于其父节点的值（相应也有最小堆） 节点的大小与层次无关 动态数组表示最大堆1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MaxHeap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private Array&lt;E&gt; data; public MaxHeap(int capacity)&#123; data = new Array&lt;&gt;(capacity); &#125; public MaxHeap()&#123; data = new Array&lt;&gt;(); &#125; public MaxHeap(E[] arr)&#123; data = new Array&lt;&gt;(arr); for(int i = parent(arr.length - 1) ; i &gt;= 0 ; i --) siftDown(i); &#125; // 返回堆中的元素个数 public int size()&#123; return data.getSize(); &#125; // 返回一个布尔值, 表示堆中是否为空 public boolean isEmpty()&#123; return data.isEmpty(); &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的父亲节点的索引 private int parent(int index)&#123; if(index == 0) throw new IllegalArgumentException("index-0 doesn't have parent."); return (index - 1) / 2; &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的左孩子节点的索引 private int leftChild(int index)&#123; return index * 2 + 1; &#125; // 返回完全二叉树的数组表示中，一个索引所表示的元素的右孩子节点的索引 private int rightChild(int index)&#123; return index * 2 + 2; &#125; 添加元素和Sift up12345678910111213// 向堆中添加元素public void add(E e)&#123; data.addLast(e); siftUp(data.getSize() - 1);&#125;private void siftUp(int k)&#123; while(k &gt; 0 &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &lt; 0 )&#123; data.swap(k, parent(k)); k = parent(k); &#125;&#125; 取出元素和Sift down1234567891011121314151617181920212223242526272829303132333435// 看堆中的最大元素public E findMax()&#123; if(data.getSize() == 0) throw new IllegalArgumentException("Can not findMax when heap is empty."); return data.get(0);&#125;// 取出堆中最大元素public E extractMax()&#123; E ret = findMax(); data.swap(0, data.getSize() - 1); data.removeLast(); siftDown(0); return ret;&#125;private void siftDown(int k)&#123; while(leftChild(k) &lt; data.getSize())&#123; int j = leftChild(k); // 在此轮循环中,data[k]和data[j]交换位置 if( j + 1 &lt; data.getSize() &amp;&amp; data.get(j + 1).compareTo(data.get(j)) &gt; 0 ) j ++; // data[j] 是 leftChild 和 rightChild 中的最大值 if(data.get(k).compareTo(data.get(j)) &gt;= 0 ) break; data.swap(k, j); k = j; &#125;&#125; Replace 取出最大元素后，放入一个新元素 实现1：先extractMax ，再add，两次O(logn)操作 实现2：直接将堆顶元素替换后，Sift down ，一次O(logn)操作 1234567891011121314// 查看堆中最大元素public E findMax()&#123; if(data.getSize() == 0) throw new IllegalArgumentException("Can not findMax when heap is empty."); return data.get(0);&#125;// 取出堆中的最大元素，并且替换成元素e public E replace(E e)&#123; E ret = findMax(); data.set(0, e); siftDown(0); return ret;&#125; Heapify 将任意数组整理成堆的形状,不需要单独写成一个函数，可以单独放在一个新的堆的构造函数中 从最后一个非叶子节点进行操作 在自制的 ArrayList 中，增加构造函数 123public Array(E[] arr)&#123; data = (E[])new Object[arr.length];&#125; ###复杂度 add 和 extractMax 时间复杂度都是 O(logn) 因为堆是一个完全二叉树，所以永远都不会退化为链表 优先队列（Priority-Queue） 普通队列：先进先出，后进后出 优先队列：出对顺序与进队顺序无关，和优先级相关 应用场景 医院：患者会动态增加，在其中选择优先级高的进行就诊 游戏AI：选择优先级高的玩家进行攻击 代码实现 和普通队列一样，继承队列接口，不过确认队首和出队的操作会有变化 实现方式有普通线性结构、顺序线性结构、堆三种实现方，堆最高效 1234567891011121314151617181920212223242526272829// 堆实现优先队列public class PriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; implements Queue&lt;E&gt; &#123; private MaxHeap&lt;E&gt; maxHeap; public PriorityQueue()&#123; maxHeap = new MaxHeap&lt;&gt;(); &#125; public int getSize()&#123; return maxHeap.size(); &#125; public boolean isEmpty()&#123; return maxHeap.isEmpty(); &#125; public E getFront()&#123; return maxHeap.findMax(); &#125; public void enqueue(E e)&#123; maxHeap.add(e); &#125; public E dequeue()&#123; return maxHeap.extractMax(); &#125;&#125; 比较器自制优先队列 自制的优先队列内置的是最大堆，如果遇到取出某些问题需要内置最小堆怎么办？ 其实 最大 和 最小 是可以相互转换的， 那么我们先要创建一个频率类， 12345678910111213141516171819private class Freq implements Comparable&lt;Freq&gt;&#123; public int e, freq; public Freq(int e, int freq)&#123; this.e = e; this.freq = freq; &#125; @Override public int compareTo(Freq another)&#123; if(this.freq &lt; another.freq) return 1; else if(this.freq &gt; another.freq) return -1; else return 0; &#125; &#125; Java优先队列 内置的优先队列比较高级，可以使用比较器 当然也可以直接将比较器匿名内部类的形式 热身练习 LeetCode-347]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-集合与映射]]></title>
    <url>%2F2018%2F09%2F06%2FJava-%E9%9B%86%E5%90%88%E4%B8%8E%E6%98%A0%E5%B0%84%2F</url>
    <content type="text"><![CDATA[集合（Set） 不能添加重复元素 应用： 客户统计，词汇量统计 实现1234567public interface Set&lt;E&gt; &#123; void add(E e); boolean contains(E e); void remove(E e); int getSize(); boolean isEmpty();&#125; 基于二分搜索树. 创建一个 Set 接口，定义 Set 的基础方法 创建 BSTSet 类，实现 Set 接口，内部实现二分搜索树的结构 注意：使用泛型后，需继承 Comparable （二分搜索树里的数据必须是可比较的） 12345678910111213141516171819202122232425262728293031323334353637package dataStructure.set;import dataStructure.BST;public class BSTSet&lt;E extends Comparable&lt;E&gt;&gt; implements Set&lt;E&gt;&#123; private BST&lt;E&gt; bst; public BSTSet()&#123; bst = new BST&lt;&gt;(); &#125; @Override public void add(E e) &#123; bst.add(e); &#125; @Override public void remove(E e) &#123; bst.remove(e); &#125; @Override public boolean contains(E e) &#123; return bst.contains(e); &#125; @Override public int getSize() &#123; return bst.size(); &#125; @Override public boolean isEmpty() &#123; return bst.isEmpty(); &#125;&#125; 写完这个后，发现和二分搜索树不是完全一样吗，对！二分搜索树就已经实现了 Set 的所有功能 基于链表 实现Set接口，内部实现LinkedList的结构（前文中自制的）前文地址 除了添加方法需要进行设置一下，其他的都调用链表方法就行 123456789101112131415161718192021222324252627282930public class LinkedListSet&lt;E&gt; implements Set&lt;E&gt; &#123; private LinkedList&lt;E&gt; list; public LinkedListSet()&#123; list = new LinkedList&lt;&gt;(); &#125; public int getSize()&#123; return list.getSize(); &#125; public boolean isEmpty()&#123; return list.isEmpty(); &#125; public void add(E e)&#123; if(!list.contains(e)) list.addFirst(e); &#125; public boolean contains(E e)&#123; return list.contains(e); &#125; public void remove(E e)&#123; list.removeElement(e); &#125;&#125; 时间复杂度分析 最理想的情况下，是满二叉树，h层的话，一共有2^(h-1)个节点 h = log2 (n+1) O(log2 n) = O(log n) 这两种时间复杂度的差距其实是非常大的，可以用一张图来更好的看出来 有序无序 一般来说，集合中元素可以轻易的进行排序，就是有序集合 有序集合基于搜索树实现的 无序集合有 基于链表实现的、基于哈希表实现的 映射（Map） 存储（键，值）数据对应的数据结构（Key，Value）就是映射 根据Key ，寻找Value 非常容易通过链表或二分搜索树实现 实现12345678910public interface Map&lt;K, V&gt; &#123; void add(K key, V value); V remove(K key); boolean contains(K key); V get(K key); void set(K key, V newValue); int getSize(); boolean isEmpty();&#125; 基于链表 需要创建一个 getNode 的方法来辅助实现 增删改查 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class LinkedListMap&lt;K, V&gt; implements Map&lt;K, V&gt; &#123; private class Node&#123; public K key; public V value; public Node next; public Node(K key, V value, Node next)&#123; this.key = key; this.value = value; this.next = next; &#125; public Node(K key, V value)&#123; this(key, value, null); &#125; public Node()&#123; this(null, null, null); &#125; @Override public String toString()&#123; return key.toString() + " : " + value.toString(); &#125; &#125; private Node dummyHead; private int size; public LinkedListMap()&#123; dummyHead = new Node(); size = 0; &#125; @Override public int getSize()&#123; return size; &#125; @Override public boolean isEmpty()&#123; return size == 0; &#125; private Node getNode(K key)&#123; Node cur = dummyHead.next; while(cur != null)&#123; if(cur.key.equals(key)) return cur; cur = cur.next; &#125; return null; &#125; public boolean contains(K key)&#123; return getNode(key) != null; &#125; public V get(K key)&#123; Node node = getNode(key); return node == null ? null : node.value; &#125; public void add(K key, V value)&#123; Node node = getNode(key); if(node == null)&#123; dummyHead.next = new Node(key, value, dummyHead.next); size ++; &#125; else node.value = value; &#125; public void set(K key, V newValue)&#123; Node node = getNode(key); if(node == null) throw new IllegalArgumentException(key + " doesn't exist!"); node.value = newValue; &#125; public V remove(K key)&#123; Node prev = dummyHead; while(prev.next != null)&#123; if(prev.next.key.equals(key)) break; prev = prev.next; &#125; if(prev.next != null)&#123; Node delNode = prev.next; prev.next = delNode.next; delNode.next = null; size --; return delNode.value; &#125; return null; &#125;&#125; 基于二分搜索树二分搜索树 定义二分搜索树类1234567891011121314151617181920212223public class BSTMap&lt;K extends Comparable&lt;K&gt;, V&gt; implements Map&lt;K, V&gt; &#123; private class Node&#123; public K key; public V value; public Node left, right; public Node(K key, V value)&#123; this.key = key; this.value = value; left = null; right = null; &#125; &#125; private Node root; private int size; public BSTMap()&#123; root = null; size = 0; &#125; &#125; 辅助方法12345678910111213// 返回以node为根节点的二分搜索树中，key所在的节点private Node getNode(Node node, K key)&#123; if(node == null) return null; if(key.equals(node.key)) return node; else if(key.compareTo(node.key) &lt; 0) return getNode(node.left, key); else // if(key.compareTo(node.key) &gt; 0) return getNode(node.right, key);&#125; 常见方法12345678910111213141516public int getSize()&#123; return size;&#125;public boolean isEmpty()&#123; return size == 0;&#125;public boolean contains(K key)&#123; return getNode(root, key) != null;&#125;public V get(K key)&#123; Node node = getNode(root, key); return node == null ? null : node.value;&#125; 增加元素123456789101112131415161718192021222324// 向二分搜索树中添加新的元素(key, value)public void add(K key, V value)&#123; root = add(root, key, value);&#125;// 向以node为根的二分搜索树中插入元素(key, value)，递归算法// 返回插入新节点后二分搜索树的根private Node add(Node node, K key, V value)&#123; if(node == null)&#123; size ++; return new Node(key, value); &#125; if(key.compareTo(node.key) &lt; 0) node.left = add(node.left, key, value); else if(key.compareTo(node.key) &gt; 0) node.right = add(node.right, key, value); else // key.compareTo(node.key) == 0 node.value = value; return node;&#125; 删除元素 删除元素和二分搜索树中的删除元素很相似 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node)&#123; if(node.left == null) return node; return minimum(node.left); &#125; // 删除掉以node为根的二分搜索树中的最小节点 // 返回删除节点后新的二分搜索树的根 private Node removeMin(Node node)&#123; if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node; &#125; // 从二分搜索树中删除键为key的节点 @Override public V remove(K key)&#123; Node node = getNode(root, key); if(node != null)&#123; root = remove(root, key); return node.value; &#125; return null; &#125; private Node remove(Node node, K key)&#123; if( node == null ) return null; if( key.compareTo(node.key) &lt; 0 )&#123; node.left = remove(node.left , key); return node; &#125; else if(key.compareTo(node.key) &gt; 0 )&#123; node.right = remove(node.right, key); return node; &#125; else&#123; // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; // 待删除节点右子树为空的情况 if(node.right == null)&#123; Node leftNode = node.left; node.left = null; size --; return leftNode; &#125; // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125; &#125; 复杂度 有序无序 根据键是否有顺序性，判断映射为有序无序 基于搜索树实现的是有序的映射 基于哈希表实现的是无序的映射 集合和映射关系 可以互相转换 如：有了映射的底层实现，可以将value看为0，这样就实现了集合 相关问题 LeetCode 349 LeetCode 350]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-二分搜索树]]></title>
    <url>%2F2018%2F09%2F01%2FJava-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二分搜索树定义 二分搜索树是一颗二叉树 二分搜索树种每个节点的值 大于左子树所有节点的值 小于右子树所有节点的值 每棵子树也是二分搜索树 存储的元素必须具备可比较性 1234567891011121314151617181920212223242526272829public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; class Node &#123; public E e; public Node left; public Node right; public Node(E e) &#123; this.e = e; left = null; right = null; &#125; &#125; private Node root; private int size; public BST() &#123; root = null; size = 0; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125;&#125; 添加元素 这里的二分搜索树是不添加相同元素的，如果想要添加可以对 14或16行 添加=条件 1234567891011121314151617181920public void add(E e) &#123; root = add(root, e); &#125;// 向以node为根的二分搜索树中插入元素e，递归算法// 返回插入新节点后，二叉树的根private Node add(Node node, E e) &#123; if (node == null) &#123; size++; return new Node(e); &#125; if (e.compareTo(node.e) &lt; 0) node.left = add(node.left, e); else if (e.compareTo(node.e) &gt; 0) node.right = add(node.right, e); return node;&#125; 查询操作123456789101112131415public boolean contains(E e) &#123; return contains(root, e); &#125;private boolean contains(Node node, E e) &#123; if (node == null) return false; if (e.compareTo(node.e) == 0) return true; else if (e.compareTo(node.e) &lt; 0) return contains(node.left, e); else return contains(node.right, e);&#125; 遍历操作树的遍历操作中分为深度优先遍历和广度优先遍历 深度优先遍历有：前序、中序、后序 这三种，每种都有各自的应用场景 前序遍历是最自然访问树的操作 中序遍历的节点是顺序的 后序遍历的一个应用是释放一棵树的内存（如C++语言中，需手动释放内存） 递归遍历 这里给出了前序遍历的递归写法，中序后序操作和其原理是一样的 123456789101112// 前序遍历public void preOrder() &#123; preOrder(root); &#125;private void preOrder(Node node) &#123; if (node == null) return; System.out.println(node.e); preOrder(node.left); preOrder(node.right);&#125; 非递归遍历 非递归前序遍历相比之下要复杂许多，还需要借助额外的数据结构–&gt;栈 非递归中序、后序遍历实现更加复杂，且应用不广 1234567891011121314151617public void preOrderNR()&#123; if(root == null) return; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty())&#123; Node cur = stack.pop(); System.out.println(cur.e); if(cur.right != null) stack.push(cur.right); if(cur.left != null) stack.push(cur.left); &#125;&#125; 层序遍历 广度优先遍历就是层序遍历，可以通过队列作为辅助数据结构来实现 常用于算法设计中–最短路径（无全图） 1234567891011121314151617public void levelOrder()&#123; if(root == null) return; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty())&#123; Node cur = q.remove(); System.out.println(cur.e); if(cur.left != null) q.add(cur.left); if(cur.right != null) q.add(cur.right); &#125;&#125; 重写toString为了方便在输出树的时候，可以更加清晰的看到树的结构，在这里对 toString 方法进行重写 1234567891011121314151617181920212223242526@Overridepublic String toString()&#123; StringBuilder res = new StringBuilder(); generateString(root, 0, res); return res.toString();&#125;// 生成以node为根节点，深度为depth的描述二叉树的字符串private void generateString(Node node, int depth, StringBuilder res)&#123; if(node == null)&#123; res.append(generateDepthString(depth) + "null\n"); return; &#125; res.append(generateDepthString(depth) + node.e + "\n"); generateString(node.left, depth + 1, res); generateString(node.right, depth + 1, res);&#125;private String generateDepthString(int depth)&#123; StringBuilder res = new StringBuilder(); for(int i = 0 ; i &lt; depth ; i ++) res.append("--"); return res.toString();&#125; 删除元素删除元素时，不能仅仅将元素删除，还要进行判断，如果被删除的元素有子树时，要将其安置好 查找最小元素12345678910111213141516// 寻找二分搜索树的最小元素public E minimum()&#123; if(size == 0) throw new IllegalArgumentException("BST is empty"); Node minNode = minimum(root); return minNode.e;&#125;// 返回以node为根的二分搜索树的最小值所在的节点private Node minimum(Node node)&#123; if( node.left == null ) return node; return minimum(node.left);&#125; 删除最小元素如果是最小元素的那个节点有右子树，那么在删除该元素时，应该用其右子树替代该元素的位置 若该子树是小元素，新建节点，保存最小元素的右子树 将当前最小元素节点删除，并维护size 返回删除节点后新二分搜索树的根 123456789101112131415161718192021// 从二分搜索树中删除最小值所在节点, 返回最小值public E removeMin()&#123; E ret = minimum(); root = removeMin(root); return ret;&#125;// 删除掉以node为根的二分搜索树中的最小节点// 返回删除节点后新的二分搜索树的根private Node removeMin(Node node)&#123; if(node.left == null)&#123; Node rightNode = node.right; node.right = null; size --; return rightNode; &#125; node.left = removeMin(node.left); return node;&#125; 删除任意元素删除任意元素时有多种情况，每种情况都需要独立去看待（看下面代码中的注释更方便于理解） 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 从二分搜索树中删除元素为e的节点public void remove(E e) &#123; root = remove(root, e);&#125;// 删除掉以node为根的二分搜索树中值为e的节点, 递归算法// 返回删除节点后新的二分搜索树的根private Node remove(Node node, E e) &#123; if (node == null) return null; if (e.compareTo(node.e) &lt; 0) &#123; return remove(node.left, e); &#125; if (e.compareTo(node.e) &gt; 0) &#123; return remove(node.right, e); &#125; else &#123; // 待删除节点 左子树为空，右子树不为空||左子树、右子树都为空 if (node.left == null) &#123; Node rightNode = node.right; node.right = null; size--; return rightNode; &#125; // 待删除节点 右子树为空，左子树不为空 if (node.right == null) &#123; Node leftNode = node.left; node.right = null; size--; return leftNode; &#125; // 待删除节点 左右子树都不为空 // 找到比待删除节点大的最小节点（后继结点）, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = removeMin(node.right); successor.left = node.left; node.left = node.right = null; return successor; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-链表实现.]]></title>
    <url>%2F2018%2F08%2F26%2FJava-%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0-1%2F</url>
    <content type="text"><![CDATA[什么是链表链表 [Linked List]：链表是由一组不必相连不必相连：可以连续也可以不连续的内存结构 节点，按特定的顺序链接在一起的抽象数据类型。 补充：抽象数据类型（Abstract Data Type [ADT]）：表示数学中抽象出来的一些操作的集合。内存结构：内存中的结构，如：struct、特殊内存块…等等之类； 最简单的数据结构 更深入的理解引用，指针 更深入的理解递归 辅助组成其他数据结构 优缺点 优点：真正的动态，不需要处理固定容量的问题 缺点：丧失了随机访问的能力 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package dataStructure;public class LinkedList&lt;E&gt; &#123; private class Node &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125; public String toString() &#123; return e.toString(); &#125; &#125; private Node dummyHead; private int size; public LinkedList() &#123; dummyHead = new Node(); size = 0; &#125; public int getSize() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("Add failed, Illegal index."); &#125; Node pre = dummyHead; for (int i = 0; i &lt; index; i++) &#123; pre = pre.next; &#125; /* Node node = new Node(e); node.next = pre.next; pre.next = node; */ pre.next = new Node(e, pre.next); size++; &#125; public void addFirst(E e) &#123; add(0, e); &#125; public void addLast(E e) &#123; add(size, e); &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("Get failed, Illegal index."); &#125; Node curr = dummyHead.next; for (int i = 0; i &lt; index; i++) &#123; curr = curr.next; &#125; return curr.e; &#125; // 获得链表的第一个元素 public E getFirst() &#123; return get(0); &#125; // 获得链表的最后一个元素 public E getLast() &#123; return get(size - 1); &#125; public void set(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("Set failed, Illegal index."); &#125; Node curr = dummyHead.next; /* while(curr != null)&#123; if (curr.e.equals(e))&#123; curr.e = e; return; &#125; curr = curr.next; &#125;*/ for (int i = 0; i &lt; index; i++) &#123; curr = curr.next; &#125; curr.e = e; &#125; public boolean contain(E e) &#123; Node curr = dummyHead.next; while (curr != null) &#123; if (curr.e.equals(e)) &#123; return true; &#125; curr = curr.next; &#125; return false; &#125; public E remove(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("Delete failed, Illegal index."); &#125; Node preNode = dummyHead; for (int i = 0; i &lt; index; i++) &#123; preNode = preNode.next; &#125; Node delNode = preNode.next; preNode.next = delNode.next; delNode.next = null; size--; return delNode.e; &#125; public E removeFirst() &#123; return remove(0); &#125; public E removeLast() &#123; return remove(size - 1); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); Node curr = dummyHead.next; while (curr != null) &#123; res.append(curr + "-&gt;"); curr = curr.next; &#125; res.append("Null"); return res.toString(); &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-队列实现]]></title>
    <url>%2F2018%2F08%2F25%2FJava-%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[队列有多种实现的方式，有数组队列还有循环队列 数组队列出列的时间复杂度是O(n) 数组队列12345678910public interface Queue&lt;E&gt; &#123; int getSize(); int getCapacity(); boolean isEmpty(); // 队列增加一个值 void enqueue(E e); // 队列出列 E dequeue(); E getFront();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package dataStructure;public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private Array&lt;E&gt; array; public ArrayQueue(int capacity)&#123; array = new Array&lt;&gt;(capacity); &#125; public ArrayQueue()&#123; array = new Array&lt;&gt;(); &#125; @Override public int getSize() &#123; return array.getSize(); &#125; @Override public int getCapacity() &#123; return array.getCapacity(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125; @Override public void enqueue(E e) &#123; array.addLast(e); &#125; @Override public E dequeue() &#123; return array.removeFirst(); &#125; @Override public E getFront() &#123; return array.getFirst(); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append("ArrayQueue:"); res.append("front ["); for (int i = 0; i &lt; array.getSize() ; i++) &#123; res.append(array.get(i)); if (i != array.getSize() -1)&#123; res.append(", "); &#125; &#125; res.append("] tail"); return res.toString(); &#125;&#125; 循环队列 接口也是继承的Queue接口 若创建一个容量为10的队列，需要创建容量为11的数组， 因为这是为了保证 front == tail时，队列为空 front == tail + 1时，队列为满 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package dataStructure;public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; private E data[]; private int front; private int tail; private int size; public LoopQueue(int capacity) &#123; data = (E[]) new Object[capacity + 1]; front = 0; tail = 0; size = 0; &#125; public LoopQueue() &#123; this(10); &#125; @Override public int getCapacity() &#123; return data.length - 1; &#125; @Override public boolean isEmpty() &#123; return front == tail; &#125; @Override public int getSize() &#123; return size; &#125; @Override public void enqueue(E e) &#123; if ((tail + 1) % data.length == front) &#123; resize(getCapacity() * 2); &#125; data[tail] = e; tail = (tail + 1) % data.length; size++; &#125; @Override public E dequeue() &#123; if (isEmpty()) throw new IllegalArgumentException("cannot dequeue from an empty LoopQueue"); E ret = data[front]; data[front] = null; front = (front + 1) % data.length; size--; if (size == getCapacity() / 4 &amp;&amp; getCapacity() != 0) &#123; resize(getCapacity() / 2); &#125; return ret; &#125; @Override public E getFront() &#123; if (isEmpty()) throw new IllegalArgumentException("cannot getFront from an empty LoopQueue"); return data[front]; &#125; private void resize(int newCapacity) &#123; E[] newData = (E[]) new Object[newCapacity + 1]; for (int i = 0; i &lt; size; i++) &#123; newData[i] = data[(i + front) % data.length]; &#125; data = newData; front = 0; tail = size; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(String.format("Queue: size = %d ,capacity = %d\n", size, getCapacity())); res.append("front ["); for (int i = front; i != tail; i = (i + 1) % data.length) &#123; res.append(data[i]); if ((i + 1) % data.length != tail) &#123; res.append(", "); &#125; &#125; res.append("] tail"); return res.toString(); &#125; public static void main(String[] args) &#123; LoopQueue&lt;Integer&gt; queue = new LoopQueue&lt;&gt;(); queue.enqueue(10); System.out.println(queue); &#125;&#125; 两种队列的比较 下面是两种队列时间复杂度的对比 链表队列 我们需要在链表中加个尾指针，这样的话 操作的时间复杂度会降低 尾端的 删除元素 时间复杂度是O(n)，添加元素 时间复杂度是O(1) 首端 删除、添加 的时间复杂度都是O(1) 所以我们选择链表的尾端添加元素，首端删除元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package dataStructure;public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; &#123; public class Node &#123; public E e; public Node next; public Node(E e, Node next) &#123; this.e = e; this.next = next; &#125; public Node(E e) &#123; this(e, null); &#125; public Node() &#123; this(null, null); &#125; public String toString() &#123; return e.toString(); &#125; &#125; private Node head, tail; private int size; public LinkedListQueue() &#123; head = null; tail = null; size = 0; &#125; @Override public int getSize() &#123; return size; &#125; @Override public int getCapacity() &#123; return size; &#125; @Override public boolean isEmpty() &#123; return size == 0; &#125; @Override public void enqueue(E e) &#123; if (tail == null) &#123; tail = new Node(e); head = tail; &#125; else &#123; tail.next = new Node(e); tail = tail.next; &#125; size++; &#125; @Override public E dequeue() &#123; if (isEmpty()) &#123; throw new IllegalArgumentException("Cannot dequeue from an empty queue"); &#125; Node retNode = head; head = head.next; retNode.next = null; if (head == null) &#123; tail = null; &#125; size--; return retNode.e; &#125; @Override public E getFront() &#123; if (isEmpty()) throw new IllegalArgumentException("Cannot getFront from an empty queue"); return head.e; &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append("Queue : front "); Node curr = head; while (curr != null) &#123; res.append(curr + "-&gt;"); curr = curr.next; &#125; res.append("Null tail"); return res.toString(); &#125; public static void main(String[] args) &#123; LinkedListQueue&lt;Integer&gt; queue = new LinkedListQueue(); for (int i = 0; i &lt; 10; i++) &#123; queue.enqueue(i); &#125; System.out.println(queue); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-栈实现]]></title>
    <url>%2F2018%2F08%2F25%2FJava-%E6%A0%88%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[栈的实现比较简单，因为栈可以看作是一个动态数组或链表，许多操作都可以借用它们实现 数组栈 下面是具体实现的代码 需要使用前面的动态数组类，然后创建一个Stack接口，去实现这个接口 12345678910111213141516public interface Stack&lt;E&gt; &#123; // 返回栈的大小 int getSize(); // 判断栈是否为空 boolean isEmpty(); // 压栈 void push(E e); // 弹栈 E Pop(); // 返回栈顶元素值 E Peek();&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; &#123; Array&lt;E&gt; array; ArrayStack(int capacity) &#123; array = new Array&lt;&gt;(capacity); &#125; ArrayStack() &#123; array = new Array&lt;&gt;(); &#125; @Override public int getSize() &#123; return array.getSize(); &#125; @Override public boolean isEmpty() &#123; return array.isEmpty(); &#125; @Override public void push(E e) &#123; array.addLast(e); &#125; @Override public E Pop() &#123; return array.removeLast(); &#125; @Override public E Peek() &#123; return array.getLast(); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append("Stack:"); res.append("["); for (int i = 0; i &lt; getSize(); i++) &#123; res.append(array.get(i)); if (i != getSize() - 1) &#123; res.append(", "); &#125; &#125; res.append("] top"); return res.toString(); &#125;&#125; 链表栈 实现Stack接口，借助LinkedList 完成功能 12345678910111213141516171819202122232425262728293031323334353637383940414243package dataStructure;public class LinkedListStack&lt;E&gt; implements Stack&lt;E&gt; &#123; private LinkedList&lt;E&gt; linkedList; public LinkedListStack() &#123; linkedList = new LinkedList&lt;&gt;(); &#125; @Override public int getSize() &#123; return linkedList.getSize(); &#125; @Override public boolean isEmpty() &#123; return linkedList.isEmpty(); &#125; @Override public void push(E e) &#123; linkedList.addFirst(e); &#125; @Override public E Pop() &#123; return linkedList.removeFirst(); &#125; @Override public E Peek() &#123; return linkedList.getFirst(); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append("Stack: top "); res.append(linkedList); return res.toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-动态数组实现]]></title>
    <url>%2F2018%2F08%2F23%2FJava-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[该数组可动态扩容，缩容，支持泛型 缩容是等到数组大小为四分之一容量的原因？为什么不是等到二分之一立刻缩容那？ 初始定义10为容量，当添加到第十个元素时，扩容为2倍，即容量为20 这时，如果重复进行删除增添的操作，就会反复扩容缩容 所以选择四分之一当前长度是为了留一个缓冲的 空间，防止这种情况的发生 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package dataStructure;public class Array&lt;E&gt; &#123; private E[] data; private int size; public Array(int capacity) &#123; data = (E[]) new Object[capacity]; size = 0; &#125; public Array() &#123; this(10); &#125; public int getSize() &#123; return size; &#125; public int getCapacity() &#123; return data.length; &#125; public boolean isEmpty() &#123; return size == 0; &#125; // 在index索引位置，增加一个元素e public void add(int index, E e) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IllegalArgumentException("Add failed. Array is full"); &#125; if (size == data.length) &#123; resize(2 * data.length); &#125; for (int i = size - 1; i &gt;= index; i--) &#123; data[i + 1] = data[i]; &#125; data[index] = e; size++; &#125; public void addLast(E e) &#123; add(size, e); &#125; public void addFirst(E e) &#123; add(0, e); &#125; // 根据index索引位置查找元素 public E get(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Find failed. Index is illegal"); return data[index]; &#125; public E getLast() &#123; return data[size - 1]; &#125; public E getFirst() &#123; return data[0]; &#125; // 修改index索引位置元素为e public void set(int index, E e) &#123; if (index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Find failed. Index is illegal"); data[index] = e; &#125; // 判断数组中是否存在某元素e public boolean contains(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i].equals(e)) return true; &#125; return false; &#125; // 查找数组中元素e所在的索引，若不存在,返回-1 public int find(E e) &#123; for (int i = 0; i &lt; size; i++) &#123; if (data[i] == e) return i; &#125; return -1; &#125; // 删除index索引的元素，并返回元素值 public E remove(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IllegalArgumentException("Remove failed. Index is illegal"); E ret = data[index]; for (int i = index; i &lt; size - 1; i++) &#123; data[i] = data[i + 1]; &#125; size--; // data[size] = null; if (size == data.length / 4 &amp;&amp; data.length / 2 != 0) &#123; resize(data.length / 2); &#125; return ret; &#125; public E removeFirst() &#123; return remove(0); &#125; public E removeLast() &#123; return remove(size - 1); &#125; // 从数组中删除元素e（第一次发现到的） public void removeElement(E e) &#123; int index = find(e); if (index != -1) remove(index); &#125; @Override public String toString() &#123; StringBuilder res = new StringBuilder(); res.append(String.format("Array: size = %d , capacity = %d\n", size, data.length)); res.append("["); for (int i = 0; i &lt; size; i++) &#123; res.append(data[i]); if (i != size - 1) &#123; res.append(", "); &#125; &#125; res.append("]"); return res.toString(); &#125; // 容量不够自动扩容，容量减小到一定程度，缩容 private void resize(int newCapacity) &#123; E[] newData = (E[]) new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newData[i] = data[i]; &#125; data = newData; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-括号生成]]></title>
    <url>%2F2018%2F08%2F18%2FLeetCode-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[题目 出处：LeetCode 算法第22题 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 暴力法 我们可以生成所有 2的2n次方 个 &#39;(&#39; 和 &#39;)&#39; 字符构成的序列。然后，我们将检查每一个是否有效。 为了生成所有序列，我们使用递归。长度为 n 的序列就是 &#39;(&#39; 加上所有长度为 n-1 的序列，以及 &#39;)&#39; 加上所有长度为 n-1 的序列。 为了检查序列是否为有效的，我们会跟踪平衡，也就是左括号的数量减去右括号的数量的净值。如果这个值始终小于零或者不以零结束，该序列就是无效的，否则它是有效的。 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; combinations = new ArrayList(); generateAll(new char[2 * n], 0, combinations); return combinations; &#125; public void generateAll(char[] current, int pos, List&lt;String&gt; result) &#123; if (pos == current.length) &#123; if (valid(current)) result.add(new String(current)); &#125; else &#123; current[pos] = '('; generateAll(current, pos+1, result); current[pos] = ')'; generateAll(current, pos+1, result); &#125; &#125; public boolean valid(char[] current) &#123; int balance = 0; for (char c: current) &#123; if (c == '(') balance++; else balance--; if (balance &lt; 0) return false; &#125; return (balance == 0); &#125;&#125; 回溯法 只有在我们知道序列仍然保持有效时才添加 &#39;(&#39; or &#39;)&#39;，而不是像方法一那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点 如果我们还剩一个位置，我们可以开始放一个左括号。 如果它不超过左括号的数量，我们可以放一个右括号 12345678910111213141516171819class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; ans = new ArrayList(); backtrack(ans, "", 0, 0, n); return ans; &#125; public void backtrack(List&lt;String&gt; ans, String cur, int open, int close, int max)&#123; if (str.length() == max * 2) &#123; ans.add(cur); return; &#125; if (open &lt; max) backtrack(ans, cur+"(", open+1, close, max); if (close &lt; open) backtrack(ans, cur+")", open, close+1, max); &#125;&#125; 参考文章LeetCode 22题解析]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-合并有序链表]]></title>
    <url>%2F2018%2F08%2F14%2FLeetCode-%E5%90%88%E5%B9%B6%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目 出处：LeetCode 算法第21题 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 思路遍历解法 先判断链表为空的情况 创建一个新链表，并在其前面加上一个哑节点，用于简化各种极端操作 创建一个指针，指向这个哑节点 循环判断 两个链表头节点值的大小 ，谁的值小将谁传入新链表 如果两个链表不一样长，剩余的部分也要加在新链表的后面 递归算法 递归算法写出来看着十分简洁，就是如果太多层的调用的话，调用太多栈会性能下降 谁的头节点小，就将该头节点作为最终链表的头节点 再一层层递归下去，反复调用自身函数，成功将链表合并 需要注意的是：如果两链表长度不想等，一定要在后面加上长链表剩余的部分 代码遍历1234567public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; 123456789101112131415161718192021public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; ListNode dummy = new ListNode(-1); ListNode curr = dummy; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; curr.next = l1; l1 = l1.next; &#125; else &#123; curr.next = l2; l2 = l2.next; &#125; curr = curr.next; &#125; curr.next = (l1 == null) ? l2 : l1; return dummy.next; &#125; 递归1234567891011public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt;= l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125; &#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-有效的括号]]></title>
    <url>%2F2018%2F08%2F10%2FLeetCode-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目 出处：LeetCode 算法第20题 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 12输入: &quot;()&quot;输出: true 示例 2: 12输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3: 12输入: &quot;(]&quot;输出: false 示例 4: 12输入: &quot;([)]&quot;输出: false 示例 5: 12输入: &quot;&#123;[]&#125;&quot;输出: true 思路 大家应该都还记得数据结构中有一个栈的概念，我们可以利用栈的先进后出的特性来做这道题 先将他们转换为char类型的字符串，将其一个一个字符的进行判断，如果它是这三种类型中任意一个的左括号则将他们压栈；如果它是右括号，则查看栈顶是否是与之相对应的左括号，若是则将该左括号弹栈，继续下一个字符的操作；若不是，则该字符串不是一个有效的字符串 代码12345678910111213141516171819202122232425262728class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack(); for (int i = 0; i &lt; s.length(); i++)&#123; char ch = s.charAt(i); if(ch == '(' || ch == '[' || ch == '&#123;' )&#123; stack.push(ch); &#125; else&#123; if (stack.isEmpty())&#123; return false; &#125; char topChar = stack.pop(); if(ch == ')' &amp;&amp; topChar != '(' )&#123; return false; &#125;else if(ch == ']' &amp;&amp; topChar != '[' )&#123; return false; &#125;else if(ch == '&#125;' &amp;&amp; topChar != '&#123;' )&#123; return false; &#125; &#125; &#125; return stack.isEmpty(); &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-删除链表的倒数第N个节点]]></title>
    <url>%2F2018%2F08%2F05%2FLeetCode-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目 出处：LeetCode 算法第19题 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点 示例： 123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 思路 Leetcode的解答已经十分详细了，这就是上面的解析，原文的链接附在参考文章中 两次遍历 这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1) 个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决 首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)个结点那里。我们把第 (L - n) 个结点的 next 指针重新链接至第 (L - n + 2) 个结点，完成这个算法。 一次遍历 上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。 代码两次遍历12345678910111213141516171819202122232425262728public class Basic19 &#123; public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public ListNode removeNthFormEnd(ListNode head, int n) &#123; ListNode pre = new ListNode(0); pre.next = head; int length = 0; ListNode curr = head; while (curr != null) &#123; length++; curr = curr.next; &#125; length -= n; curr = pre; while (length &gt; 0) &#123; length--; curr = curr.next; &#125; curr.next = curr.next.next; return pre.next; &#125;&#125; 一次遍历123456789101112131415161718192021222324252627public class Basic19 &#123; public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // 前进第一个指针，使第一个和第二个之间的间隙分开n个节点 for (int i = 1; i &lt;= n + 1; i++) &#123; first = first.next; &#125; // 先移动到最后，保持差距 while (first != null) &#123; first = first.next; second = second.next; &#125; second.next = second.next.next; return dummy.next; &#125;&#125; 参考文章 LeetCode 19题解答]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[u盘容量未知-解决]]></title>
    <url>%2F2018%2F08%2F01%2Fu%E7%9B%98%E5%AE%B9%E9%87%8F%E6%9C%AA%E7%9F%A5-%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[问题前几天公司发的电脑，一直没有刷系统，昨天弄了一下，结果在安装时将u盘拔出，导致了下面这种情况，u盘容量未知，并且无法格式化 解决 win+R输入control打开控制面板 点击系统安全，点击管理工具，新界面寻找计算机管理 点击磁盘管理，找到u盘界面，右键新建卷，即可解决问题 或者直接win+R输入diskmgmt.msc进入磁盘管理]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-两数相加]]></title>
    <url>%2F2018%2F07%2F26%2FLeetCode-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[出处：LeetCode 算法第2题 给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例： 123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 思路 本来想自己写解析的，不过后来看LeetCode上面的解析写得真不错，于是就粘贴过来啦 如图，对两数相加方法的可视化: 342 + 465 = 807，每个节点都包含一个数字，并且数字按位逆序存储。 就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。由于每位数字都应当处于 0…9 的范围内，我们计算两个数字的和时可能会出现“溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为 2，并将进位 carry = 1 带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。 伪代码如下： 将当前节点初始化为返回列表的哑节点。 将进位 carry 初始化为 0。 将 p 和 q 分别初始化为列表 l1 和 l2 的头部。 遍历列表 l1 和 l2，直至到达它们的尾端。 将 x 设为节点 p 的值。如果 p 已经到达 l1 的末尾，则将其值设置为 0。 将 y 设为节点 q 的值。如果 q 已经到达 l2 的末尾，则将其值设置为 0。 设定 sum = x + y + carry。 更新进位的值，carry = sum / 10。 创建一个数值为 (sum \ bmod 10) 的新节点，并将其设置为当前节点的下一个节点，然后将当前节点前进到下一个节点。 同时，将 p 和 q 前进到下一个节点。 检查 carry = 1 是否成立，如果成立，则向返回列表追加一个含有数字 1 的新节点。 返回哑节点的下一个节点。 注意情况： 测试用例 说明 l1 = [0，1]l2 = [0，1，2] 当一个列表比另一个列表长时。 l1 = [ ]l2 = [0，1] 当一个列表为空时，即出现空列表。 l1 = [9，9]l2 = [1] 求和运算最后可能出现额外的进位，这一点很容易被遗忘 代码12345678910111213141516171819202122232425262728293031323334public class Basic02 &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode sumNode = new ListNode(0); ListNode p = l1, q = l2, curr = sumNode; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = x + y + carry; carry = sum / 10; curr.next = new ListNode(sum % 10); if (p != null) &#123; p = p.next; &#125; if (q != null) &#123; q = q.next; &#125; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return sumNode.next; &#125; public class ListNode &#123; int val; ListNode next; public ListNode(int val) &#123; this.val = val; &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode-四数之和]]></title>
    <url>%2F2018%2F07%2F17%2FLeetCode-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目 出处：LeetCode 算法第18题 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，**b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 12345678给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 思路 首先对数组进行排序，设置两个for循环，作为四个数中的前两个数，有可能有两个相同的数，遇到相同的数跳过，这样做是为了避免重复 四个数中的后两个数怎么办，通过设置两个指针m和n，m从数组前往后进行遍历，n用来从数组后往前进行遍历。m&gt;=n是结束循环的条件 遇到 target == a + b + c + d 的数就加到ArrayList中 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Basic18 &#123; public static List&lt;List&lt;Integer&gt;&gt; forSun(int[] num, int target) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList(); //将数组进行排序 Arrays.sort(num); //第一个加数 for (int i = 0; i &lt; num.length - 3; i++) &#123; //判断第一个加数使用是否重复 if (i != 0 &amp;&amp; num[i] == num[i - 1]) &#123; continue; &#125; //第二个加数 for (int j = i + 1; j &lt; num.length - 2; j++) &#123; //判断第二个加数使用是否重复 if (j != i + 1 &amp;&amp; num[j] == num[j - 1]) &#123; continue; &#125; //第三个数 int left = j + 1; //第四个数 int right = num.length - 1; while (left &lt; right) &#123; int sum = num[i] + num[j] + num[left] + num[right]; if (sum &lt; target) &#123; left++; &#125; else if (sum &gt; target) &#123; right--; &#125; else &#123; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); temp.add(num[i]); temp.add(num[j]); temp.add(num[left]); temp.add(num[right]); list.add(temp); left++; right--; //保证再次使用第三个数不重复 while (left &lt; right &amp;&amp; num[left] == num[left - 1]) &#123; left++; &#125; //保证再次使用第四个数不重复 while (left &lt; right &amp;&amp; num[right] == num[right + 1]) &#123; right--; &#125; &#125; &#125; &#125; &#125; return list; &#125; @Test public void test1() &#123; int[] num = new int[]&#123;1, 0, -1, 0, -2, 2&#125;; int target = 0; List list = forSun(num, target); for (Iterator it = list.iterator(); it.hasNext(); ) &#123; System.out.println(it.next()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android实训总结]]></title>
    <url>%2F2018%2F07%2F10%2FAndroid%E5%AE%9E%E8%AE%AD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在学校实训的一个多星期中，掌握了一部分的安卓技术，也可以做出来一个安卓app 安卓新闻App]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯算法]]></title>
    <url>%2F2018%2F06%2F28%2F%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[回溯的算法题，之前也遇到过，但是每次都没有仔细研究，这几天做 剑指offer 的题中，又再次遇到了回溯，于是打算这一次能够将他弄明白 概述常用解释回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就回溯返回，尝试别的路径 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为回溯点 许多复杂的，规模较大的问题都可以使用回溯法，有通用解题方法的美称 基本思想在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法） 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束 题目请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子 举例如在下图矩阵中包含一条字符串 bcced 的路径，但是矩阵中不包含 abcb 路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子 123a b c es f c sa d e e 思路这道题可以采用回溯算法来做，我们可以以矩阵中每一个点为起始点，当有一个点与字符串中第一个字符相等，即可继续前进，接下来去搜索该节点的上下左右节点，如果有任意一个节点和字符串中接下来的字符相等时，即继续前进；否则返回到之前的节点，再重新搜索。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public class BackTracking &#123; /** * @param matrix 输入的矩阵 * @param rows 矩阵行数 * @param cols 矩阵列数 * @param str 将要搜索的字符串 * @return 是否找到 是：true 否：false */ public static boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; //参数校验 if (matrix == null || matrix.length != rows * cols || rows &lt; 1 || cols &lt; 1 || str.length &lt; 1 || str == null) &#123; return false; &#125; //定义boolean型矩阵，用来标识路径是否进入某个格子 boolean[] visited = new boolean[rows * cols]; //记录结果，作为str字符串的角标 int pathLength = 0; //以每一个点为起始进行搜索 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; //给每个格子初始值赋为负值 memset(visited, false); if (hasPathCore(matrix, rows, cols, str, i, j, visited, pathLength)) &#123; return true; &#125; &#125; &#125; return false; &#125; /** * @param matrix 输入的矩阵 * @param rows 矩阵总行数 * @param cols 矩阵总列数 * @param str 需要查找的str字符串 * @param row 当前处理的矩阵行号 * @param col 当前处理的矩阵列号 * @param visited 访问标记数组 * @param pathLength 已经处理str字符串的个数 * @return 是否找到 是：true 否：false */ private static boolean hasPathCore(char[] matrix, int rows, int cols, char[] str, int row, int col, boolean[] visited, int pathLength) &#123; //判断：如果检测到了数组的最后一位，可以直接返回true if(pathLength == str.length) return true; boolean hasPath = false; if (row &lt; rows &amp;&amp; col &lt; cols &amp;&amp; col &gt;= 0 &amp;&amp; row &gt;= 0 &amp;&amp; matrix[row * cols + col] == str[pathLength] &amp;&amp; !visited[row * cols + col]) &#123; visited[row * cols + col] = true; pathLength++; // 按照上下左右回溯 hasPath = hasPathCore(matrix, rows, cols, str, row, col - 1, visited, pathLength) || hasPathCore(matrix, rows, cols, str, row - 1, col, visited, pathLength) || hasPathCore(matrix, rows, cols, str, row, col + 1, visited, pathLength) || hasPathCore(matrix, rows, cols, str, row + 1, col, visited, pathLength); if (!hasPath) &#123; --pathLength; visited[row * cols + col] = false; &#125; &#125; return hasPath; &#125; /** * 给boolean型数组赋值 * * @param booleans 数组 * @param bool 赋值 */ private static void memset(boolean[] booleans, boolean bool) &#123; for (int i = 0; i &lt; booleans.length; i++) &#123; booleans[i] = bool; &#125; &#125;&#125; 测试为了方便测试，使用了 Junit 来进行测试，不得不说，真好用啊！！ 12345678910111213141516171819202122232425262728293031323334353637383940import org.junit.Test;public class BackTrackingTest &#123; @Test public void test1() &#123; char[] matrix = new char[]&#123;'a', 'b', 'c', 'e', 's', 'f', 'c', 's', 'a', 'd', 'e', 'e'&#125;; char[] str = new char[]&#123;'b', 'f', 'c', 'e'&#125;; boolean bool = BackTracking.hasPath(matrix, 3, 4, str); System.out.println(bool); &#125; @Test public void test2()&#123; String matrix = "asdfzxcvqwer"; String str = "sxzq"; boolean bool = BackTracking.hasPath(matrix.toCharArray(), 3, 4, str.toCharArray()); System.out.println(bool); &#125; @Test public void test3()&#123; String matrix = ""; String str = "sxzq"; boolean bool = BackTracking.hasPath(matrix.toCharArray(), 0, 0, str.toCharArray()); System.out.println(bool); &#125; @Test public void test4()&#123; String matrix = "qwerasdfzxcv"; String str = "qwsw"; boolean bool = BackTracking.hasPath(matrix.toCharArray(), 0, 0, str.toCharArray()); System.out.println(bool); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL8.0连接中的几个问题]]></title>
    <url>%2F2018%2F06%2F17%2FMySQL8-0%E8%BF%9E%E6%8E%A5%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题汇总JDBC 驱动最新版问题报错原因 使用了MySQL的最新版 JDBC 连接驱动 报错提示1java.sql.SQLException: The server time zone value '???ú±ê×??±??' is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 解决方案在 1jdbcUrl=jdbc:mysql://localhost:3306/person 后面加上： 1jdbcUrl=jdbc:mysql://localhost:3306/person?serverTimezone=UTC 但如果你的 jdbcUrl 类似下面： 1jdbcUrl=jdbc:mysql://localhost:3306/person?serverTimezone=UTC&amp;characterEncoding=utf-8 就是有多个params的时候需要以&amp;分开，但 &amp;要改为 &amp;amp; 如下： 1jdbcUrl=jdbc:mysql://localhost:3306/spring?serverTimezone=UTC&amp;ampcharacterEncoding=utf-8 注意 在使用配置文件或c3p0-xml配置的情况下 多个params间以 &amp;amp; 分割 在 JDBCUtils 老版方法中 多个params中用 &amp;amp 分割]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-C3P0连接池]]></title>
    <url>%2F2018%2F06%2F17%2FJava-C3P0%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[概述分析实际开发中“获得连接”或“释放资源”是非常消耗系统资源的两个过程，为了解决此类性能问题，通常情况我们采用连接池技术，来共享连接Connection 概念用池来管理Connection，这样可以重复使用Connection。有了池，所以我们就不用自己来创建 Connection’而是通过池来获取Connection对象。当使用完Connection后，调用Connection的close() 方法也不会真的关闭Connection，而是把Connection “归还”给池。池就可以再利用这个Connection 对象了。 规范Java为数据库连接池提供了公共的接口：javax.sqI.DataSource,各个厂商需要让自己的连接池实现这个接口。这样应用程序可以方便的切换不同厂商的连接池！ 常见的连接池：DBCP、C3POO 自定义连接池分析根据我们对连接池简单的理解，如果我们要编写自定义连接池，需要完成以下步骤 创建连接池实现（数据源），并实现接口 javax.sqI.DataSource 。因为我们只使用该接口中getConnection()方法，简化本案例，我们将自己提供方法，而没有实现接口 提供一个集合，用于存放连接，因为移除/添加操作过多，所以选择LinkedList 本案例在静态代码块中，为连接池初始化3个连接 之后程序如果需要连接，调用实现类的getConnection(),本方法将从连接池（容器List)获得连接。为了保证当前连接只能提供给一个线程使用，所以我们需要将连接先从连接池中移除 当用户使用完连接，释放资源时，不执行close()方法，而是将连接添加到连接池中 准备 写好配置文件后，通过静态代码块加载配置文件信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class JDBCUtils_V3 &#123; private static String driver; private static String url; private static String username; private static String password; static &#123; try &#123; // 1.通过当前类获取类加载器 ClassLoader classLoader = JDBCUtils_V3.class.getClassLoader(); // 2.通过类加载器的方法获得一个输入流 InputStream is = classLoader.getResourceAsStream("db.properties"); // 3.创建一个properties对象 Properties props = new Properties(); // 4.加载输入流 props.load(is); // 5.获取相关参数的值 driver = props.getProperty("driver"); url = props.getProperty("url"); username = props.getProperty("username"); password = props.getProperty("password"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() &#123; Connection conn = null; try &#123; Class.forName(driver); conn = DriverManager.getConnection(url, username, password); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return conn; &#125; public static void release(Connection conn, PreparedStatement pstmt, ResultSet rs) &#123; if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (pstmt != null)&#123; try &#123; pstmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; if (conn != null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 实现123456789101112131415161718192021222324252627282930313233343536373839public class MyDataSource implements DataSource&#123; //1.创建1个容器用于存储Connection对象 private static LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;(); //2.创建5个连接放到容器中去 static&#123; for (int i = 0; i &lt; 5; i++) &#123; Connection conn = JDBCUtils.getConnection(); pool.add(conn); &#125; &#125; /** * 重写获取连接的方法 */ @Override public Connection getConnection() throws SQLException &#123; Connection conn = null; //3.使用前先判断 if(pool.size()==0)&#123; //4.池子里面没有，我们再创建一些 for (int i = 0; i &lt; 5; i++) &#123; conn = JDBCUtils.getConnection(); pool.add(conn); &#125; &#125; //5.从池子里面获取一个连接对象Connection conn = pool.remove(0); return conn; &#125; /** * 归还连接对象到连接池中去 */ public void backConnection(Connection conn)&#123; pool.add(conn); &#125;&#125; 自定义连接池：方法增强自定义连接池中存在严重问题，用户调用getConnection()获得连接后，必须使用release()方法进行连接的归还，如果用户调用conn.close()将连接真正的释放，连接池中将出现无连接可用。 此时我们希望，即使用户调用了close()方法，连接仍归还给连接池。close()方法原有功能时释放资源，期望功能：将当前连接归还连接池。说明se()方法没有我们希望的功能，我们将对close() 方法进行增强，从而实现将连接归还给连接池的功能 方法增强总结 继承：子类继承父类，将父类的方法进行复写，从而进行增强。 使用前提：必须有父类，且存在继承关系 装饰者设计模式：此设计模式专门用于增强方法。 使用前提：必须有接口 缺点：需要将接口的所有方法都实现 动态代理：在运行时动态的创建代理类，完成增强操作。 与装饰者相似使用前提：必须有接口 难点：需要反射技术 字节码增强：运行时创建目标类子类，从而进行增强常见 第三方框架：cglib、javassist等 装饰者设计模式设计模式：专门为解决某一类问题，而编写的固定格式的代码。 装饰者固定结构：接口A，己知实现类c，需要装饰者创建代理类B 创建类B，并实现接口A 提供类B的构造方法，参数类型为A，用于接收A接口的其他实现类(c) 给类B添加类型为A成员变量，用于存放A接口的其他实现类 增强需要的方法 实现不需要增强的方法，方法体重调用成员变量存放的其他实现类对应的方法 实现123456789101112131415161718192021222324252627282930//1.实现同一个接口Connectionpublic class MyConnection implements Connection &#123; //3.定义一个变量 private Connection conn; private LinkedList&lt;Connection&gt; pool; // 2.编写一个构造方法(参数使用了面相对象的多态特性) public MyConnection(Connection conn,LinkedList&lt;Connection&gt; pool) &#123; this.conn=conn; this.pool=pool; &#125; //4.书写需要增强的方法 @Override public void close() throws SQLException &#123; pool.add(conn); &#125; /** * 此方法必须覆盖！否则会出现空指针异常！！！ */ @Override public PreparedStatement prepareStatement(String sql) throws SQLException &#123; return conn.prepareStatement(sql); &#125; /*下面为不需要增强的方法*/ &#125; 使用装饰类 C3P0连接池导入Jar包C3P0-0.9.1.2.jar mchange-commons-java-0.2.3.4.jar 配置文件 配置文件名称：c3p0-config.xml (固定) 配置文件位置：src（类路径） 配置文件内容：命名配置 c3p0-config.xml-基本配置 常见配置项 编写工具类 未抽取工具类之前 1234567891011121314151617181920212223242526public class TestC3P0 &#123; @Test public void testAddUser()&#123; Connection conn = null; PreparedStatement pstmt = null; ComboPooledDataSource dataSource = new ComboPooledDataSource(); try &#123; conn = dataSource.getConnection(); String sql = "insert into tbl_user value(null,?,?)"; pstmt = conn.prepareStatement(sql); pstmt.setString(1, "xiaomingming"); pstmt.setString(2, "小白"); int rows = pstmt.executeUpdate(); if(rows&gt;0)&#123; System.out.println("添加成功"); &#125;else &#123; System.out.println("添加失败"); &#125; &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125;finally &#123; JDBCUtils_V3.release(conn, pstmt, null); &#125; &#125;&#125; 抽取工具类 123456789101112131415public class C3P0Utils &#123; private static ComboPooledDataSource dataSource = new ComboPooledDataSource(); public static DataSource getDataSource()&#123; return dataSource; &#125; public static Connection getConnection()&#123; try &#123; return dataSource.getConnection(); &#125; catch (SQLException e) &#123; throw new RuntimeException(e); &#125; &#125;&#125; 抽取工具类后的测试类可以这样写 12345678910111213141516171819202122232425public class TestC3P0 &#123; @Test public void testAddUser1()&#123; Connection conn = null; PreparedStatement pstmt = null; try &#123; conn = C3P0Utils.getConnection(); String sql = "insert into tbl_user value(null,?,?)"; pstmt = conn.prepareStatement(sql); pstmt.setString(1, "xiaowang"); pstmt.setString(2, "小白"); int rows = pstmt.executeUpdate(); if(rows&gt;0)&#123; System.out.println("添加成功"); &#125;else &#123; System.out.println("添加失败"); &#125; &#125;catch (Exception e)&#123; throw new RuntimeException(e); &#125;finally &#123; JDBCUtils_V3.release(conn, pstmt, null); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C3P0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序算法]]></title>
    <url>%2F2018%2F06%2F10%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[快排的算法在平均状况下，排序效率为 O（N*LogN），运算效率是最高的，所以最受欢迎。而且在快速排序的算法中还体现着 分冶 思想，这几天我学习了一下这个算法，整理一下他的算法思路。 快速排序算法-维基百科 算法原理快速排序算法使用分冶法来把一个序列分为两个序列 从数列中挑出一个元素，称为“基准”（pivot） 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面 在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作 递归地把 小于基准值元素的子数列 和 大于基准值元素的子数列 排序 下面的图片来自于维基百科，通过看这张图可以观察到使用该算法后数据的变化 白话快排我在CSDN看到一篇非常好的文章讲解了这个算法的原理，在这里转载过来一部分 白话经典算法系列之六 快速排序 快速搞定 虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法： 先来看实例吧，定义下面再给出（最好能用自己的话来总结定义，这样对实现代码会有帮助） 以一个数组作为示例，取区间第一个数为基准数。 0 1 2 3 4 5 6 7 8 9 72 6 57 88 60 42 83 73 48 85 初始时，start = 0; end = 9; pivot = a[i] = 72 由于已经将a[0]中的数保存到pivot中，可以理解成在数组a[0]上挖了个坑，可以将其它数据填充到这来。 从j开始向前找一个比pivot小或等于pivot的数。当 end=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; start++; 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从start开始向后找一个大于X的数，当start =3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; end–; 数组变为： 0 1 2 3 4 5 6 7 8 9 48 6 57 88 60 42 83 73 88 85 start = 3; end = 7; pivot =72 再重复上面的步骤，先从后向前找，再从前向后找。 从j开始向前找，当end =5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; start ++; 从i开始向后找，当start =5时，由于start == end退出。 此时，start = end = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。 数组变为： 0 1 2 3 4 5 6 7 8 9 48 6 57 42 60 72 83 73 88 85 可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了 对挖坑填数进行总结 1．start end pivot共三个参数; 将基准数挖出形成第一个坑a[start]。 2．end–由后向前找比它小的数，找到后挖出此数填前一个坑a[start]中。 3．start++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[end]中。 4．再重复执行2，3二步，直到 start == end，将基准数填入a[start]中。 照着这个总结很容易实现挖坑填数的代码： 代码示例 在这个类中，为了方便理解，我创建了多个方法互相调用，并在函数上面加上了注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class QuickSort &#123; //判断数组是否为空 private static boolean isEmpty(int[] arr) &#123; return arr == null || arr.length == 0; &#125; //在主类中调用该方法，对数组进行排序 public static void quickSort(int[] arr) &#123; if (isEmpty(arr)) System.out.println("数组为空，请输入数据后再排序！！！"); quickSort(arr, 0, arr.length - 1); &#125; //也可以选择在主类中调用该方法，对数组指定位置进行排序 public static void quickSort(int[] arr, int low, int high) &#123; if (isEmpty(arr)) return; if (low &lt; high) &#123; //基准数据在数组中所在的角标 int pivotKey = partion(arr, low, high); //将基准左部递归排序 quickSort(arr, low, pivotKey - 1); //将基准右部递归排序 quickSort(arr, pivotKey + 1, high); &#125; &#125; private static int partion(int[] arr, int start, int end) &#123; //以第一个数据为基准 int pivot = arr[start]; while (start &lt; end) &#123; //从数组右端开始，若数据大于基准值，end指针-1 //反之则交换该数据值和基准值，并且将start++ while (arr[end] &gt;= pivot &amp;&amp; start &lt; end) end--; if (start &lt; end) &#123; arr[start] = arr[end]; start++; &#125; //从数组左端开始，若数据小于基准值，start指针+1 //反之则交换该数据值和基准值，并且将end-- while (arr[start] &lt; pivot &amp;&amp; start &lt; end) start++; if (start &lt; end) &#123; arr[end] = arr[start]; end--; &#125; &#125; //返回基准值在数组中的角标 return start; &#125; //函数功能：交换数组中两个数据值 private static void swap(int[] arr,int i,int j)&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 优化 在上面可以发现，代码的基准一直选取的是第一个数，在某些糟糕的情况下，该算法效率并不佳 过段时间，我会再补上优化的部分]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-DOM]]></title>
    <url>%2F2018%2F05%2F31%2FJava-DOM%2F</url>
    <content type="text"><![CDATA[概述DOM：Document Object Model(文档对象模型) 用来将标记型文档封装成对象，并将标记型文档中的所有的内容(标签，文本，属性等)都封装成对象。 封装成对象的目的是为了更为方便的操作这些文档以及文档中的所有内容。 因为对象的出现就可以有属性和行为被调用。 文档对象模型 文档：标记型文档 对象：封装了属性和行为的实例，可以被直接调用 模型：所有标记型文档都具备一些共性特征的一个体现 标记型文档(标签，属性，标签中封装的数据) 只要是标记型文档，DOM这种技术都可以对其进行操作 常见的标记型文档：html xml DOM这种技术是如何对标记型文档机型操作的呢？ 要操作标记型文档必须对其进行解析 解析方式DOM DOM技术的解析方式： 将标记型文档解析一棵DOM树，并将树中的内容都封装成节点对象 DOM解析方式 好处：可以对树中的节点进行任意操作，比如：增删改查 弊端：这种解析需要将整个标记型文档加载进内存。 意味着如果标记型文档的体积很大，较为浪费内存空间 SAX SAX：是由一些组织定义的一种民间常用的解析方式，并不是w3c标准，而DOM是W3C的标准 SAX解析的方式：基于事件驱动的解析。获取数据的速度很快，但是不能对标记进行增删改 DOM三级模型 DOM level 1：将html文档封装成对象 DOM level 2：在level 1基础上加入了新功能，比如解析名称空间 DOM level 3：将xml文档封装成了对象 DHTML动态的HTML，不是一门语言，是多项技术综合体的简称 其中包含了HTML，CSS，DOM，JavaScript 这四个技术在动态html页面效果定义时，都处于什么样角色呢？负责什么样的职责呢？ HTML： 负责提供标签，对数据进行封装，目的是便于对该标签中的数据进行操作 简单说：用标签封装数据 CSS： 负责提供样式属性，对标签中的数据进行样式的定义 简单说：对数据进行样式定义 DOM： 负责将标签型文档以及文档中的所有内容进行解析，并封装成对象， 在对象中定义了更多的属性和行为，便于对对象操作 简单说：将文档和标签以及其他内容变成对象 J s： 负责提供程序设计语言，对页面中的对象进行逻辑操作 简单说：负责页面的行为定义，就是页面的动态效果 所以 JavaScript是动态效果的主力编程语言 DHTML+XMLhttpRequest = AJAX BOMBrowser Object Model 浏览器对象模型 ，这个模型方便于操作浏览器 浏览器对应的对象就是window对象，这个可以通过查阅DHTML API获得 定义一个事件源，通过对事件源的触发，获取想要的结果 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;script type="text/javascript" src="out.js"&gt;&lt;/script&gt; //定义按钮 onclick事件的处理方式 &lt;script type="text/javascript"&gt; //定义一函数 function windowObjDemo()&#123; //想要知道这个浏览器的信息。 就需要使用window对象中的navigator var name = navigator.appName; var version = navigator.appVersion; println(name+":"+version); &#125; //演示location function windowObjDemo2()&#123; var pro = location.protocol; var text = location.href; alert(text); //给location的href属性设置一个值 //改变了地址栏的值，并对其值进行了解析如果是http，还进行连接访问 location.href = "https://orangetop.github.io"; &#125; &lt;/script&gt; &lt;!--定义事件源,注册事件关联的动作--&gt; &lt;input type="button" value="演示window中的对象" onclick="windowObjDemo2()" /&gt;&lt;/body&gt; window对象 演示window中的常见方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt; &lt;script type="text/javascript" src="out.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var timeid; function windowMethodDemo()&#123; var b = confirm("你真的确定要点击吗？"); alert("b="+b); //延迟4秒，弹窗 setTimeout("alert('time out run')",4000); //每隔3秒弹窗 timeid = setInterval("alert('interval run')",3000); &#125; function stopTime()&#123; //取消之前设置的间隔事件 clearInterval(timeid); &#125; function windowMove()&#123; // moveBy(10,10); // moveTo(40,40); for (var x = 0; x &lt; 700; x++)&#123; //窗口抖动 moveBy(20, 0); moveBy(0, 20); moveBy(-20,0); moveBy(0,-20); &#125; &#125; function windowOpen()&#123; //可以作为广告，会弹出 ad.htmlopen("ad.html","_blank","height=400,width=400,status=no,toolbar=no,menubar=no,location=no"); c8lose(); &#125; &lt;/script&gt; &lt;input type="button" value="演示window对象的方法" onclick="windowOpen()"/&gt; &lt;input type="button" value="停止" onclick="stopTime()"/&gt;&lt;/body&gt; window常见事项 12345678910111213141516171819202122&lt;script type="text/javascript"&gt; onunload = function()&#123; //在对象被卸载前触发 alert("onunload run"); &#125; onload = function()&#123; //浏览器完成对象装载后触发 alert("onload run"); &#125; onbeforeunload = function()&#123; //在对象将要被卸载前触发 alert("onbeforeunload run"); &#125; onload = function()&#123; window.status = "啊！，加载完毕啦"; &#125;&lt;/script&gt; DOMdocument对象该对象将标记型文档进行封装，作用是可以对标记型文档进行操作 若是想要实现动态效果，就需要对节点操作，那么要先获取到这个节点 要想获取节点，必须要先获取到节点所属的文档对象document document对象最常见的操作就是获取页面中的节点 获取节点的方法体现： 1、getElementById()： 通过标签的id属性值获取该标签节点，返回该标签节点 2、getElementsByName()： 通过标签的name属性获取节点，因为name有相同，所以返回的一个数组 3、getElementsByTagName(): 通过标签名获取节点。因为标签名会重复，所以返回的是一个数组 凡是带s返回的都是数组 获取节点 节点都有三个必备的属性： 节点名称，节点类型，节点值 常见节点有三种： 1、标签型节点：类型 1 2、属性节点： 类型 2 3、文本节点： 类型 3 标签型节点是没有值的，属性和文本节点是可以有值的 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;body&gt;&lt;script type="text/javascript"&gt; function getNodeDemo()&#123; var divNode = document.getElementById("divid"); //获取div节点中的文本。 var text = divNode.innerHTML; alert(text); //改变div中的文本。 divNode.innerHTML = "文本被改了".fontcolor("red"); &#125; //获取文本框节点演示getElementsByName方法 function getNodeDemo2()&#123; var userNode = document.getElementsByName("user")[0]; alert(userNode.value); &#125; //获取超链接节点对象。演示getElementsByTagName方法。 function getNodeDemo3()&#123; //直接用标签名获取。 var nodes = document.getElementsByTagName("a"); for(var x=0; x&lt;nodes.length; x++)&#123; //新窗口打开 nodes[x].target = "_blank"; &#125; &#125; &lt;/script&gt; &lt;input type="button" value="演示document对象获取节点" onclick="getNodeDemo4()" /&gt; &lt;div id="divid"&gt;这是一个div区域&lt;/div&gt; &lt;input type="text" name="user" /&gt; &lt;a href="http://www.sina.com.cn"&gt;网站1&lt;/a&gt; &lt;a href="http://www.SOHU.com.cn"&gt;网站2&lt;/a&gt; &lt;div id="newslink"&gt; &lt;a href="http://www.163.com.cn"&gt;新闻链接1&lt;/a&gt; &lt;a href="http://www.164.com.cn"&gt;新闻链接2&lt;/a&gt; &lt;a href="http://www.itcast.com.cn"&gt;新闻链接3&lt;/a&gt; &lt;/div&gt;&lt;/body&gt; 对于页面中的超链接，新闻链接通过新窗口打开，门户网站链接在当前页面打开 要获取其中被操作的超链接对象，可是通过document获取超链接，拿到的是页面中所有的超链接节点。 只想获取一部分该如何办呢？ 只要获取到被操作的超链接所属的节点即可，再通过这个节点获取到它里面所有的超链接节点 123456789101112function getNodeDemo4()&#123; //获取超链接所属的div节点 var divNode = document.getElementById("newslink"); //通过对div对象方法的查找发现它也具备getElementsByTagName方法。 //记住：所有的容器型标签都具备这个方法。在该标签范围内获取指定名称的标签。 var aNodes = divNode.getElementsByTagName("a"); for(var x=0;x&lt;aNodes.length; x++)&#123; aNodes[x].target = "_blank"; &#125;&#125; 节点层次 通过节点的层次关系获取节点对象 关系： 1、父节点: parentNode:对应一个节点对象 2、子节点：childNodes:对应一个节点集合 3、兄弟节点： 上一个兄弟节点：previousSibling 下一个兄弟节点：nextSibling 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;html&gt;&lt;body&gt;&lt;script type="text/javascript"&gt; function getNodeByLevel()&#123; //获取页面中的表格节点。 var tabNode = document.getElementById("tabid"); //获取父节点 parentNode var node = tabNode.parentNode; alert(node.nodeName);//body //获取子节点 childNodes var nodes = tabNode.childNodes; alert(nodes[0].childNodes[0].nodeName); //获取兄弟节点 //上一个 var node = tabNode.previousSibling; alert(node.nodeName); var node = tabNode.nextSibling.nextSibling; alert(node.nodeName); //尽量少用兄弟节点，因为在解析的时候会出现浏览器不同解析不一致， //会解析出标签间的空白文本节点 &#125;&lt;/script&gt; &lt;input type="button" value="通过节点层次关系获取节点" onclick="getNodeByLevel()" /&gt; &lt;div&gt;div区域&lt;/div&gt; &lt;span&gt;span区域&lt;/span&gt; &lt;table id="tabid"&gt; &lt;tr&gt; &lt;td&gt;单元格一&lt;/td&gt; &lt;td&gt;单元格二&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;span&gt;span区域11&lt;/span&gt; &lt;dl&gt; &lt;dt&gt;上层项目&lt;/dt&gt; &lt;dd&gt;下层项目&lt;/dd&gt; &lt;/dl&gt; &lt;a href=''&gt;一个超链接&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 创建添加节点 需求：在div_1中添加节点 有两种方法： 第一种： 创建节点，使用document中的createTextNode方法 通过getElementById方法，获取div_1节点 将文本节点添加到div_1节点中 第二种： 使用了容器型标签中的一个属性，innerHTML 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=GBK"&gt; &lt;title&gt;Untitled Document&lt;/title&gt;&lt;style type="text/css"&gt; div&#123; border:#00ccff 1px solid; width:200px; padding:30px; margin:10px; &#125; #div_1&#123; background-color:#00ccff; &#125; #div_2&#123; background-color:#FFccff; &#125; #div_3&#123; background-color:#cc00ff; &#125; #div_4&#123; background-color:#00FF00; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; //创建并添加节点。 //需求：在div_1节点中添加一个文本节点。 function crtAndAdd()&#123; //1, 创建节点。使用document中的createTextNode方法。 var oTextNode = document.createTextNode("这是一个新的文本 "); //2，获取div_1节点。 var oDivNode = document.getElementById("div_1"); //3，将文本节点添加到div_1节点中。 oDivNode.appendChild(oTextNode); &#125; //需求：在div_1中创建并添加一个按钮节点。 function crtAndAdd2()&#123; //1,创建一个按钮节点。 var oButNode = document.createElement("input"); oButNode.type = "button"; oButNode.value = "一个新按钮"; //2，获取div_1节点。 var oDivNode = document.getElementById("div_1"); //3，将按钮节点添加到div_1节点中。 oDivNode.appendChild(oButNode); &#125; //通过另一种方式完成添加节点。 function crtAndAdd3()&#123; //1，获取div_1节点。 var oDivNode = document.getElementById("div_1"); //oDivNode.innerHTML = "&lt;input type='button' value='有个按钮'/&gt;"; oDivNode.innerHTML = "&lt;a href='http://www.163.com'&gt;有个超链接&lt;/a&gt;"; &#125;&lt;/script&gt; &lt;input type="button" value="创建并添加节点" onclick="crtAndAdd3()"/&gt; &lt;input type="button" value="删除节点" onclick="delNode()"/&gt; &lt;input type="button" value="修改节点" onclick="updateNode()"/&gt; &lt;input type="button" value="克隆节点" onclick="cloneDemo()"/&gt; &lt;hr/&gt; &lt;div id="div_1"&gt; &lt;/div&gt; &lt;div id="div_2"&gt; 加油，年薪百万在招手！ &lt;/div&gt; &lt;div id="div_3"&gt; div区域演示文字 &lt;/div&gt; &lt;div id="div_4"&gt; 节点的增删改查 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 删除节点 一般用removeChild，获取父节点，删除父的子节点 123456789101112131415//需求将div_2节点删除。 function delNode()&#123; //1,获取div_2节点。 var oDivNode = document.getElementById("div_2"); //2,使用div节点的remvoeNode方法删除 //false 自杀，true 诛九族 //建议试一下false，true看看区别 //oDivNode.removeNode(true);较少用 //一般使用removeChild方法。 删除子节点。 //获取div_2的父节点，然后在用父节点的removeChild，将div_2删除。 oDivNode.parentNode.removeChild(oDivNode);&#125; 替换克隆节点1234567891011121314151617181920212223242526272829303132//需求：用div_3节点替换div_1节点。function updateNode()&#123; //获取div-3和div-1. //使用replaceNode进行替换。 var oDivNode_1 = document.getElementById("div_1"); var oDivNode_3 = document.getElementById("div_3"); //oDivNode_1.replaceNode(oDivNode_3); // 建议使用replaceChild方法。 oDivNode_1.parentNode.replaceChild(oDivNode_3,oDivNode_1);&#125;//需求：希望用div_3替换div-1，并保留div-3节点。//其实就是对div_3进行克隆function cloneDemo()&#123; var oDivNode_1 = document.getElementById("div_1"); var oDivNode_3 = document.getElementById("div_3"); //true 全部克隆，false 自己克隆 var oCopyDiv_3 = oDivNode_3.cloneNode(true); //oDivNode_1.replaceNode(oDivNode_3); // 建议使用replaceChild方法。 oDivNode_1.parentNode.replaceChild(oCopyDiv_3,oDivNode_1);&#125; 练习新闻字体（大中小）需求：新闻字体的大中小样式改变 思路： 1、先有新闻数据，并用标签封装。 2、定义一些页面样式。静态的样式和预定义的样式(用于动态效果，方便于事件处理时的样式加载。) 3、确定事件源和事件，以及处理方式中被处理的节点。 事件源：a标签，事件：onclick，被处理的节点：div-newstext 4、用 Js处理页面的行为 然要给超链接加入自定义的事件处理，就要先取消超链接的默认点击效果 可以使用给 href 设置：javascript:void(0) 来完成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=GBK"&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;style type="text/css"&gt; /*超链接访问前，访问后样式一致*/ a:link,a:visited&#123; color:#0044ff; text-decoration:none; &#125; a:hover&#123; color:#ff8800; &#125; #newstext&#123; width:500px; border:#00ff00 1px solid; padding:10px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; //定义 改变字体 的方法。 function changeFont2(size,clr)&#123; //既然要对div newstext中的文本字体进行操作。 //必须要先获取div节点对象。 var oNewsText = document.getElementById("newstext"); //获取oNewText节点的style样式属性对象。 oNewsText.style.fontSize = size; oNewsText.style.color = clr; &#125; &lt;/script&gt; &lt;h1&gt;这是一个新闻标题&lt;/h1&gt; &lt;hr/&gt; &lt;a href="javascript:void(0)" onclick="changeFont('max')"&gt;大字体&lt;/a&gt; &lt;a href="javascript:void(0)" onclick="changeFont('norm')"&gt;中字体&lt;/a&gt; &lt;a href="javascript:void(0)" onclick="changeFont('min')"&gt;小字体&lt;/a&gt; &lt;div id="newstext" class="norm"&gt; 6月21日，夏至，太阳光将直射北回归线，北半球的白昼也达到了全年最长。 对于北纬40°左右地区，夏至前后几天夜晚可观星的时间只有短短不到5个小 时。即便如此，六月的夜空依然很精彩，土星将在本月迎来冲日，还有几个流 星雨活动，但它们的流量都不大。 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 如果根据用户点击所需要的效果不唯一，仅通过传递多个参数虽然可以实现效果 但是存在很多缺点 传参过多，阅读性差 Js 代码和 CSS代码耦合性高 不利于扩展 解决办法： 将多个所需的样式进行封装 封装到选择器中，只要给指定的标签加载不同的而选择器就可以了 1234function changeFont(selectorName)&#123; var oNewsText = document.getElementById("newstext"); oNewsText.className = selectorName;&#125; 全选文本框1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;全选&lt;/title&gt; &lt;script&gt; function checkAll()&#123; //1.获取编号前面的复选框 var checkAllEle = document.getElementById("checkAll"); //2.对编号前面复选框的状态进行判断 if(checkAllEle.checked==true)&#123; //3.获取下面所有的复选框 var checkOnes = document.getElementsByName("checkOne"); //4.对获取的所有复选框进行遍历 for(var i=0;i&lt;checkOnes.length;i++)&#123; //5.拿到每一个复选框，并将其状态置为选中 checkOnes[i].checked=true; &#125; &#125;else&#123; //6.获取下面所有的复选框 var checkOnes = document.getElementsByName("checkOne"); //7.对获取的所有复选框进行遍历 for(var i=0;i&lt;checkOnes.length;i++)&#123; //8.拿到每一个复选框，并将其状态置为未选中 checkOnes[i].checked=false; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table border="1" width="500" height="50" align="center" &gt; &lt;thead&gt; &lt;tr&gt; &lt;td colspan="4"&gt; &lt;input type="button" value="添加" /&gt; &lt;input type="button" value="删除" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;input align="" type="checkbox" onclick="checkAll()" id="checkAll"/&gt;全选&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr &gt; &lt;td&gt;&lt;input type="checkbox" name="checkOne"/&gt;&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;/tr&gt; &lt;tr &gt; &lt;td&gt;&lt;input type="checkbox" name="checkOne"/&gt;&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;25&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 省市二级联动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;二级联动&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;script&gt; var cities = new Array(3); cities[0] = new Array("武汉市","黄冈市","襄阳市","荆州市"); cities[1] = new Array("长沙市","郴州市","株洲市","岳阳市"); cities[2] = new Array("石家庄市","邯郸市","廊坊市","保定市"); cities[3] = new Array("郑州市","洛阳市","开封市","安阳市"); function changeCity(val) &#123; //1、获取第二个下拉列表 var cityEle = document.getElementById("city"); //2、清空第二个下拉列表的option内容 cityEle.options.length = 0; //3、遍历二维数组中的省份 for(var i=0;i&lt;cities.length;i++)&#123; //注意，比较的是角标 if(val==i)&#123; //4、遍历用户选择的省份下的城市 for(var j=0;j&lt;cities[i].length;j++)&#123; //alert(cities[i][j]); //5、创建城市的文本节点 var textNode = document.createTextNode(cities[i][j]); //6、创建option元素节点 var opEle = document.createElement("option"); //7、将城市的文本节点添加到option元素节点 opEle.appendChild(textNode); //8、将option元素节点添加到第二个下拉列表中去 cityEle.appendChild(opEle); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;table border="1" align="center" height="70%" bgcolor="white"&gt; &lt;tr&gt; &lt;td colspan="2" align="center"&gt; &lt;font size="5"&gt;会员注册&lt;/font&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;籍贯&lt;/td&gt; &lt;td&gt; &lt;select onchange="changeCity(this.value)"&gt; &lt;option&gt;--请选择--&lt;/option&gt; &lt;option value="0"&gt;湖北&lt;/option&gt; &lt;option value="1"&gt;湖南&lt;/option&gt; &lt;option value="2"&gt;河北&lt;/option&gt; &lt;option value="3"&gt;河南&lt;/option&gt; &lt;/select&gt; &lt;select id="city"&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>Dom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript入门]]></title>
    <url>%2F2018%2F05%2F29%2FJavaScript%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[概述 Js 是基于对象和事件驱动的脚本语言，主要应用在客户端 特点： 交互性（他可以做信息的动态交互） 安全性（不允许访问本地硬盘） 跨平台性（只要有可以解析 Js 的浏览器就可执行，与平台无关） 区别（Java） 它们分别是不同公司的产品 Js 基于对象，Java面向对象 Js 只需解释就可执行，Java需先编译为字节码文件，再执行 Js 弱类型，Java强类型 结合（HTML） Js和html相结合的方式： 1、将 Js 代码封装到 &lt;script> 标签中。 2、将 Js 代码封装到 Js 文件中，并通过 &lt;script> 中的src属性进行导入。 注意：如果 &lt;script> 标签中使用src属性，那么该标签中封装的 Js 代码不会被执行， 所以通常导入 Js 文件都是用单独 &lt;script> 来完成 1234567&lt;!--导入一个js文件--&gt;&lt;script type="text/javascript" src="demo.js"&gt;&lt;/script&gt;&lt;!--封装javascript代码。--&gt;&lt;script type="text/javascript"&gt; alert("hello javascript");&lt;/script&gt; 语法通用内容通常高级程序设计语言所包含的语法内容： 1、关键字:该种语言中被赋予了特殊含义的单词。 2、标示符:用于标示数据和表达式的符号。通常可以理解为在程序中自定义的名称。比如变量名，函数名。 3、注释:注解说明解释程序。用于调试程序。 4、变量:用于标示内存中一片空间。用于存储数据，该空间的中的数据是可以变化的。 什么时候使用变量，当数据不确定的时候。 5、运算符：可以让数据进行运算的符号。 6、语句:用于对程序的运行流程进行控制的表达式。 7、函数:用于对功能代码进行封装，便于提高复用性。 8、数组:对多数据进行存储，便于操作。就是传说中容器。 9、对象:只要是基于对象的语言，或者是面向对象的语言，就存在着对象的概念，对象就是一个封装体。 既可以封装数据有可以封装函数。 这些都是高级程序设计语言具备的共性内容，只不过各种语言对这些内容的表现形式有所不同, 但是使用基本思想是一致。 变量 Js 中定义变量，使用到关键字 var 定义变量，Js是弱类型的 123456789&lt;script type="text/javascript"&gt; //var不写也行，因为js是非严谨的语言，但是我们开发的时候建议都按照严谨的方式来定义。 var x = 4； x = "abc";//重新赋值为字符串abc。 x = 3.45;//赋值为小数。其实也是数字类型。 x = true;//赋值为boolean类型。 x = 'c';//赋值为字符串c。 alert("x="+x);//这是一个函数，将具体的参数通过对话框进行显示。&lt;/script&gt; 运算符 算术运算符 + - * / % ++ – 赋值运算符 = += -= *= /= %= 比较运算符：运算的结果要么是false要么是true。 > &lt; &gt;= &lt;= != == 逻辑运算符：用来连接两个 Boolean 型的表达式 位运算符 &amp; | ^ &gt;&gt; &lt;&lt; &gt;&gt;&gt; 三元运算符 ? : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;script type="text/javascript"&gt; //1、算术运算符演示。 var a = 3710; alert("a="+a/1000*1000);//a=3710; var a1 = 2.3,b1 = 4.7; alert("a1+b1="+(a1+b1));//结果为 7 alert("12"-1);//11 alert("12"+1);//121 alert(true+1);//2 因为在js中false就是0，或者null，非0，非null。就是true。默认用1表示。 alert(2%5);//2 var n = 3,m; m = n++;//若该句为 m=++n n=4,m=4 alert("n="+n+",m="+m);//n=4，m=3 // 2、赋值运算符 var i = 3; i = i+2; i+=2; alert("i="+i); // 3、比较运算符。 var z = 3; alert(z!=4); // 4、逻辑运算符。 var t = 4; alert(t&gt;7 &amp;&amp; t&lt;6); alert(!true);// ！t false // 5、位运算符。 var c = 6; alert(c&amp;3);//2 alert(5^3^3);//5 alert(c&gt;&gt;&gt;1);//6/2的1次方; alert(c&lt;&lt;2);//24 //6，三元运算符。 3&gt;0?alert("yes"):alert("no"); alert(3&gt;10?100:200); &lt;/script&gt; 细节 undefined：未定义，其实它就是一个常量 123456789101112&lt;script type="text/javascript"&gt; var xx; alert(xx);//undefined alert(xx==undefined);//true 可用于健壮性判断 //要想获取具体的值的类型。可以通过typeof来完成。 alert(typeof("abc")=='string');//string alert(typeof(2.5)=='number');//number//判断类型。 alert(typeof(true));//boolean alert(typeof(78));//number alert(typeof('9'));//string&lt;/script&gt; 语句 顺序结构 判断结构 代表语句：if 选择结构 swich 循环结构 while do while for 其他语句 break continue: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script type="text/javascript"&gt; //判断结构 var x = 3; if(4==x)&#123; //建议将常量放左边。以报错来修正代码。 alert("yes"); &#125;else&#123; alert("no"); &#125; //选择结构。 var x = "abc"; switch(x)&#123; case "kk": alert("a"); break; case "abc": alert("b"); break; default: alert("c"); break;//省略。 &#125; //循环结构。 var x = 1; document.write("&lt;font color='blue' &gt;"); while(x&lt;10) &#123; // alert("x="+x); //将数据直接写到当前页面当中。 document.write("x="+x+"&lt;br/&gt;"); x++; &#125; document.write("&lt;/font&gt;"); for(var x=0; x&lt;3; x++)&#123; //别用int document.write("x="+x); &#125; w:for(var x=0; x&lt;3; x++)&#123; for(var y=0; y&lt;4; y++)&#123; document.write("x==="+x); continue w;//跳出当前循环。 &#125; &#125; &lt;/script&gt; 练习 99乘法表，加上样式 12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=GBK"&gt; &lt;title&gt;Untitled Document&lt;/title&gt; &lt;link rel="stylesheet" href="table.css"/&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript"&gt; document.write("&lt;table&gt;"); for(var x=1; x&lt;=9; x++)&#123; document.write("&lt;tr&gt;"); for(var y=1; y&lt;=x; y++)&#123; document.write("&lt;td&gt;"+y+"*"+x+"="+y*x+"&lt;/td&gt;"); &#125; document.write("&lt;/tr&gt;"); &#125; document.write("&lt;/table&gt;"); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 数组 数组用于存储更多的数据，是一个容器。 特点： 1、长度的是可变的。 2、元素的类型是任意的。 建议在使用数组时，存储同一类型的元素。操作起来较多方便。 1234567js中的数组定义的两种方式：1、 var arr = []; var arr = [3,1,5,8];2、使用了javascript中的Array对象来完成的定义。 var arr = new Array();//var arr = []; var arr1 = new Array(5);//数组定义并长度是5. var arr2 = new Array(5,6,7);//定义一个数组，元素是5,6,7; 函数 函数：就是一个功能的封装体。 定义功能通常需要两个明确。 1、功能的结果 2、功能实现中的参与运算的未知的内容 Js中的定义函数的格式，通过指定的关键字来定义 12345678910111213function 函数名(参数列表)&#123; 函数体：return 返回值;//如果没有具体的返回值，return语句可以省略不写。&#125;&lt;script type="text/javascript"&gt; function add(x,y)&#123; return x+y; &#125; var sum = add(4,5); alert("sum="+sum);&lt;/script&gt; 细节 1、只要使用函数的名称就是对这个函数的调用。 2、函数中有一个数组在对传入的参数进行存储。这个数组就是arguments 12345678910&lt;script type="text/javascript"&gt; function show(x,y)&#123; alert(arguments.length); alert(x+":"+y); for(var a=0;a&lt;arguments.length; a++)&#123; document.write(arguments[a]); &#125; &#125; show(4,5,6,9,7,4);//建议函数中定义几个参数就传递几个实参。&lt;/script&gt; 小细节2 1234567891011121314151617181920212223&lt;script type="text/javascript"&gt; function getSum()&#123; return 100; &#125; //getSum函数运行，并将返回的结果赋值给sum var sum = getSum(); //getSum本身是一个函数名，而函数本身在js中就是一个对象。getSum就是这个函数对象的引用. //将getSum这个引用的地址赋值给sum。这时sum也指向了这个函数对象。 //相当于这个函数对象有两个函数名称 var sum = getSum; //打印时候如果sum指向的是函数对象，那么会将该函数对象的字符串表现形式打印出来 //就是该函数的代码定义格式 alert("sum="+sum);， function show2()&#123; alert("show2 run"); &#125; alert(show2()); //show2 run undefined //因为有两个alert&lt;/script&gt; 动态函数 Js函数的其他表现形式 动态函数：使用的是Js中内置的一个对象Function 只不过用的不是很多 参数列表，函数体都是通过字符串动态指定的 12345678&lt;script type="text/javascript"&gt; //参数列表，函数体都是通过字符串动态指定的 var add = new Function("x,y","var sum; sum=x+y; return sum;"); var he = add(4,8); alert("he="+he); &lt;/script&gt; 匿名函数 匿名函数：没有名字的函数，通常是函数的简写形式。 123456789101112131415161718192021&lt;script type="text/javascript"&gt; //示例一 var add3 = function (a,b)&#123; return a+b; &#125; alert(add3(7,8)); //示例二 function haha() &#123; alert("haha run"); &#125; var xixi = haha; //上述代码可以简写成下面的方式。 var xixi = function() &#123; alert("haha run"); &#125;&lt;/script&gt; 练习一 综合练习： 1、定义功能，完成对数组的最值获取 2、对数组排个序 3、对数组查个找 4、对数组元素进行反转 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;script type="text/javascript"&gt; var arr = [66,13,37,21,89,17]; //取最值。 function getMax(arr)&#123; var max = 0; for(var x=1; x&lt;arr.length; x++)&#123; if(arr[x]&gt;arr[max]) max = x; &#125; return arr[max]; &#125; var maxValue = getMax(arr); //排序。 function sortArray(arr)&#123; for(var x=0; x&lt;arr.length-1; x++)&#123; for(var y=x+1; y&lt;arr.length; y++)&#123; if(arr[x]&gt;arr[y])&#123; swap(arr,x,y); &#125; &#125; &#125; &#125; //数组中的元素位置置换。 function swap(arr,x,y)&#123; var temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; &#125; function println(val)&#123; document.write(val+"&lt;br/&gt;"); &#125; println("排序前:"+arr) sortArray(arr); println("排序后:"+arr) &lt;/script&gt; &lt;script type="text/javascript"&gt; //查找。 function searchElement(arr,key)&#123; for(var x=0;x&lt;arr.length; x++)&#123; if(arr[x]==key) return x; &#125; return -1; &#125; //折半，必须有前提。必须是有序的数组。 function binarySearch(arr,key)&#123; var max,min,mid; min = 0; max = arr.length-1; while(min&lt;=max)&#123; mid = (max+min)&gt;&gt;1; if(key&gt;arr[mid]) min = mid + 1; else if(key&lt;arr[mid]) max = mid - 1; else return mid; &#125; return -1; &#125; //对数组的反转。 function reverseArray(arr)&#123; for(var start=0,end=arr.length-1; start&lt;end; start++,end--)&#123; swap(arr,start,end); &#125; &#125; reverseArray(arr); println("反转后:"+arr); &lt;/script&gt; 全局和局部变量 在脚本片段中定义的变量，是全局变量 函数内定义的变量，是局部变量 1234567891011121314151617181920212223&lt;script type="text/javascript"&gt;// for(var x=0; x&lt;3; x++)&#123;//在脚本片段中定义的变量，是全局变量。// document.write("x="+x);// &#125; // function show()&#123;// var x = 6;//局部变量。// &#125; // document.write("X======="+x); var x = 3;//全局变量x. function show(x)&#123;//函数局部的变量x x = 8; &#125; show(x); document.write("x="+x);//x=3; &lt;/script&gt; 常见对象Object toString()：将对象变成字符串 valueOf()：返回制定对象原始值 1234567891011121314151617&lt;script type="text/javascript"&gt; function show()&#123; alert("show run"); &#125; alert(show.toString()); var arr = [3,4,1,6,8]; alert(arr.toString()); var abc = function()&#123; alert("abc run"); &#125; alert(abc); alert(abc.valueOf());&lt;/script&gt; String Js相比 Java 的String少很多功能 我们可以自行添加 1234567891011//out.js//打印指定参数数据到页面上，并换行function println(param)&#123; document.write(param+"&lt;br/&gt;");&#125;//out.js打印指定参数数据到页面上。function print(param)&#123; document.write(param);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;body&gt;//导入out.js&lt;script type="text/javascript" src="out.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="stringtool.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //演示简单功能 var str = "abcde"; println("len="+str.length); println(str.bold());//加粗 println(str.fontcolor("red"));//字体颜色。 println(str.link("http://www.163.com"));//将字符串变成超链接。 println(str.substr(1,3));//bcd println(str.substring(1,3));//bc //自定义 //去除字符串两端的空格。 function trim(str)&#123; //定义两个变量，一个记录开始的位置。一个记录结束的位置。 //对开始的位置 的字符进行判断，如果是空格，就进行递增，直到不是空格为止。 //对结束的位置 的字符进行判断，如果是空格，就进行递减，直到不是空格为止。 //必须要保证开始&lt;=结束，这样才可以进行截取。 var start,end; start=0; end=str.length-1; while(start&lt;=end &amp;&amp; str.charAt(start)==' ')&#123; start++; &#125; while(start&lt;=end &amp;&amp; str.charAt(end)==" ")&#123; end--; &#125; return str.substring(start,end+1); &#125; var s = " ab c "; alert("-"+trim(s)+"-"); //alert("abc".bold());//&lt;b&gt;this&lt;/b&gt;//给string的原型中添加一个功能。 注意：给对象添加新功能直接使用 对象.新内容 即可。// String.prototype.len = 199;//给string的原型对象中添加一个属性 名为len。值为199.//添加行为。// println("abc".len);// alert("-"+" ab cd ".trim()+"-");&lt;/script&gt;&lt;/body&gt; 既然trim方法是用来操作字符串的方法，可不可以像字符串已有的方法一样， 将该方法也定义到字符串对象中呢？直接用字符串对象调用就欧了 原型 这里就可以使用一个该字符串的原型属性来完成： 原型：就是该对象的一个描述。该描述中如果添加了新功能，那么该对象都会具备这些新功能。 而prototype就可以获取到这个原型对象，通过prototype就可以对对象的功能进行扩展。 需求：想要给string对象添加一个可以去除字符串两端空格的新功能，就可以使用原型属性来完成。 12345678910111213141516171819&lt;script&gt; //String.prototype.mytrim = trim(); //在已有该函数时也可以这样写 String.prototype.trim = function()&#123; //匿名函数 var start,end; start=0; end=this.length-1; while(start&lt;=end &amp;&amp; this.charAt(start)==' ')&#123; start++; &#125; while(start&lt;=end &amp;&amp; this.charAt(end)==" ")&#123; end--; &#125; return this.substring(start,end+1); &#125;&lt;/script&gt; 我们来试着用原型完成一个小练习 添加一个，将字符串进行反转的方法 1234567891011121314151617String.prototype.reverse = function()&#123; var arr = this.toCharArray(); //将数组位置置换功能进行封装。并定义到了反转功能内部。 function swap(arr,a,b)&#123; var temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; for(var x=0,y=arr.length-1; x&lt;y ; x++,y--)&#123; swap(arr,x,y); &#125; return arr.join("");&#125; Array 在下面代码中展示了一些常用的Array方法 concat、join、pop、reverse、shift、sort、splice、unshift 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script type="text/javascript" src="../demo/out.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var arr = ["nba","haha","cba","aaa","abc"]; var arr2 = ["qq","xiaoqiang",70]; //在arr数组上连接一个元素"mm"，再连接一个arr2数组 //将mm作为新数组中的元素，将arr2数组中的元素也作为新数组中的元素 var newArr = arr.concat("mm",arr2); println(newArr); println(arr.join("-")); println(myJoin(arr,"+"));//以"+"为分隔符 //模拟一下的join的实现原理 function myJoin(arr,separator)&#123; var str = ""; for(var x=0;x&lt;arr.length ; x++)&#123; if(x!=arr.length-1) str += arr[x]+separator; else str += arr[x]; &#125; return str; &#125; //移除数组中的元素，并返回该元素。pop println("&lt;hr/&gt;"); println(arr.pop());//删除并返回最后一个元素。 println(arr.reverse());//反转 println(arr.shift());//删除并返回第一个元素 println(arr); println(arr); arr.sort(); //删除元素并可以进行元素的替换。 var temp = arr.splice(1,3,8080,9527,"xixixi","wangcai"); println(temp); println(arr.unshift("uuuu"));//在头部插入 println(arr);&lt;/script&gt; pop() 方法是删除最后一个元素，unshift()方法是在头部插入 那么是不是可以用他们做出堆栈，队列那？可以自己试试呀 Date12345678910111213141516171819202122232425262728293031&lt;script type="text/javascript" src="out.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var date = new Date(); println(date); println(date.toLocaleString());//日期和时间 println(date.toLocaleDateString());//只有日期。 function getWeek(num)&#123; var weeks = ['星期日','星期一','星期二','星期三','星期四','星期五','星期六']; return weeks[num]; &#125; // 日期对象和毫秒值之间的转换 var date2 = new Date(); //获取毫秒值 日期对象--&gt;毫秒值 var time = date2.getTime(); println("time:"+time);//1338191622156 //将毫秒值转成日期对象。 //1、new Date(time);//setTime(); var date3 = new Date(time); //将日期对象和字符串之间进行转换 //日期对象转成字符串，toLocaleString toLocaleDateString //将字符串转成日期对象，具备指定格式的日期字符串--&gt;毫秒值---&gt;日期对象 var str_date = "9/28/2017"; var time2 = Date.parse(str_date); var date3 = new Date(time2); println(date3.toLocaleDateString());&lt;/script&gt; Math 该对象的中的方法都是静态的。不需要new，直接Math调用即可 123456789101112131415161718192021222324252627282930&lt;script type="text/javascript" src="out.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var num1 = Math.ceil(12.34);//返回大于等于指定参数的最小整数。 var num2 = Math.floor(12.34);//返回小于等于指定数据的最大整数。 var num3 = Math.round(12.54);//四舍五入 println("num1="+num1); //13 println("num2="+num2); //12 println("num3="+num3); //13 var num4 = Math.pow(10,2);//10的2次方 println("num4="+num4); println("&lt;hr/&gt;"); for(var x=0; x&lt;10; x++)&#123; //伪随机数// var num = Math.floor(Math.random()*10+1); //ParseInt 全局方法 var num = parseInt((Math.random()*10+1)); println(num); &#125; //将指定进制格式的字符串转成十进制 var num = parseInt("110",2); println("num="+num); var num1 = parseInt('0x3c',16); println("num1="+num1);&lt;/script&gt; 全局方法 全局对象都在 global 中, 如 ParseInt 12345678910111213parseInt("123");println(parseInt("123")+1);var val = parseInt("12abc");//val = 12;val val = parseInt("abc12");//非法，返回NANprintln("value="+val);//通过isNaN来判断结果是否非法。//将指定进制格式的字符串转成十进制var num = parseInt("110",2);println("num="+num);var num1 = parseInt('0x3c',16);println("num1="+num1); Number 我们刚刚在ParseInt 里，已经知道了怎么将指定进制转换十进制 那么如何把十进制 转换为 指定进制 那？ 12345678//将十进制转成其他进制，使用数字对象完成 var num3 = new Number(6);println("num3="+num3.toString(2));var num4 = 60;println("num4="+num4.toString(16)); 特有语句 为了简化对象调用内容的书写，可以使用 Js中的特有语句 with 来完成。 12345678910111213141516171819202122/*格式： with(对象) &#123; 在该区域中可以直接使用指定的对象的内容。不需要写对象. &#125;*/ // var year = date.getFullYear();// var month = date.getMonth()+1;// var day = date.getDate();// var week = getWeek(date.getDay());with(date)&#123; var year = getFullYear(); var month = getMonth()+1; var day = getDate(); var week = getWeek(getDay()); println(year+"-----"+month+"---+--"+day+"-----"+week);&#125; for in ：对对象进行变量的语句 12345678910var arr = [32,80,65];for(i in arr)&#123;println("i="+arr[i]);&#125;println("&lt;hr/&gt;");for(x in numObj)&#123;println(x);&#125; 自定义对象 如果想要自定义对象，应该先对对象进行描述 Js是基于对象，不是面向对象的，不具备描述事物的能力 我们还想按照面向对象的思想编写 Js 就要先描述，在 Js中，可以用函数来模拟面对对象的中的描述 12345678910111213141516171819202122232425//用js来描述人function Person()&#123;//相当于构造器。 alert("person run");&#125;//通过描述进行对象的建立。 new.var p = new Person();//动态给p对象添加属性。直接使用p.属性名即可。p.name = "zhangsan";p.age = 29;//如果定义的p对象的属性赋值为一个函数，即是给p对象添加一个方法。p.show = function()&#123; alert("show :"+this.name+":"+this.age);&#125;p.show();var obj = new Object();obj.name = "god father";obj.age = 2012;alert(obj.name+":"+obj.age); 封装 12345678910111213141516171819202122function Person(name,age)&#123; //在给Person对象添加了两个属性。 this.name = name; this.age = age; this.setName = function(name)&#123; this.name = name; &#125; this.getName = function()&#123; return this.name; &#125;&#125; var p = new Person("旺财",20);for(x in p)&#123; //记得导入out.js println(x+":"+p[x]);&#125;p.setName("小强");alert(p.getName()); 直接使用{}定义属性和值的键值对方式。键值键通过:连接，键与键之间用逗号隔开 12345678910111213141516171819202122232425262728var pp = &#123; //定义一些成员。 "name":"小明","age":38, "getName":function()&#123; return this.name; &#125; &#125; //对象调用成员有两种方式：对象.属性名 对象["属性名"]alert(pp["age"]+":"+pp.name); //用js实现键值对映射关系的集合容器。 var oMap = &#123; 8:"小强",3:"旺财",7:"小明"&#125; var val1 = oMap[8];alert("val1:"+val1);var val2 = get(7);alert("val2:"+val2);function get(key)&#123; return oMap[key];&#125; 定义对象 比较常用map，键值对的形式 123456789101112131415161718192021var myobj = &#123; myname:"lisisi",myage:30&#125; alert(myobj.myname+":"+myobj["myage"]);var myobj2 = &#123; "myname2":"hahahah","myage2":48&#125;alert(myobj2.myname2+":"+myobj2["myage2"]);var myMap = &#123; //names:["lsii1","lisi2","lisi4"],nums:[34,10,48] names:[&#123;name1:"zhangsan"&#125;,&#123;myname:"hahahah"&#125;]&#125;alert(myMap.names[1]);alert(myMap.names[0].name1);]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-正则表达式]]></title>
    <url>%2F2018%2F05%2F27%2FJava-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述 在讲正则表达式之前，让我们先完成一个小程序 需求：定义一个功能对QQ号进行校验。 要求：长度5~15. 只能是数字， 0不能开头 12345678910111213141516171819//太复杂public static void checkQQ(String qq)&#123; int len = qq.length(); if(len&gt;=5 &amp;&amp; len&lt;=15)&#123; if(!qq.startsWith("0"))&#123; try &#123; long l = Long.parseLong(qq); System.out.println(l+":正确"); &#125;catch(NumberFormatException e)&#123; System.out.println(qq+":含有非法字符"); &#125; &#125;else&#123; System.out.println(qq+":不能0开头"); &#125; &#125;else&#123; System.out.println(qq+":长度错误"); &#125;&#125; 1234String qq = "12346578";String regex = "[1-9][0-9]&#123;4,14&#125;";//正则表达式boolean b = qq.matches(regex); System.out.println(qq+":"+b); 你能想象到，之前那么多行的程序，可以被短短几行代码表达出来吗？ 正则表达式用于操作字符串数据，通过一些特定的符号来体现的。 所以我们为了掌握正则表达式，必须要学习一些符号。虽然简化了，但是阅读性差 规则 可以选择看API文档中 java.util.regex 目录下的Pattern类，或者下面的连接教程 正则表达式-语法 常用功能匹配 使用的就是String类中的matches方法 假设手机号只有13***,15***,18***这几个频段 1234567public static void functionDemo_1()&#123; //匹配手机号码是否正确。 String tel = "15800001111"; String regex = "1[358]\\d&#123;9&#125;"; boolean b = tel.matches(regex); System.out.println(tel+":"+b);&#125; 切割 使用的就是String类中的split方法 需求：想要以连续的出现的任意相同字母为切割符 那么就是用”.“ 来表示任意字符，它后面的字符应该是跟他一样的，所以把 . 用小括号括起来 这就是组，它是字符串中第一组被包起来的，所以后面用 “\\1”表示它，+代表可以出现1或多次 1234567891011public static void functionDemo_2()&#123; String str = "zhangsanttttxiaoqiangmmmmmmzhaoliu"; String[] names = str.split("(.)\\1+"); for(String name : names)&#123; System.out.println(name); &#125;&#125; 那么 ( ( a ) ( b ( c ) ) ) 分别是几组那？ 第一组： ( ( a ) ( b ( c ) ) ) 第二组： \a 第三组： ( b ( c ) ) 第四组： ( c ) 替换 使用的就是String类中的 replaceAll() 方法 需求1：将连续出现的字符，替换为一个该字符 需求2：输入手机号，将第4-7位替换为* 1234567891011121314public static void functionDemo_3() &#123; String str = "zhangsanttttxiaoqiangmmmmmmzhaoliu"; // $代表前一个参数，$1 前一个参数的第一组 str = str.replaceAll("(.)\\1+", "$1"); System.out.println(str); String tel = "15800001111";//158****1111; // 将手机号切割，前三位，后四位各为一组 tel = tel.replaceAll("(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)", "$1****$2"); System.out.println(tel);&#125; 获取 将正则规则进行对象的封装 通过正则对象的matcher方法字符串相关联。获取要对字符串操作的匹配器对象Matcher 通过Matcher匹配器对象的方法对字符串进行操作 123Pattern p = Pattern.compile("a*b");Matcher m = p.matcher("aaaaab");boolean b = m.matches(); 需求：获取字符串中的 三个字符的单词 123456789101112131415161718192021public static void functionDemo_4() &#123; String str = "da jia hao,ming tian bu fang jia!"; String regex = "\\b[a-z]&#123;3&#125;\\b"; //1,将正则封装成对象。 Pattern p = Pattern.compile(regex); //2, 通过正则对象获取匹配器对象。 Matcher m = p.matcher(str); //使用Matcher对象的方法对字符串进行操作。 //既然要获取三个字母组成的单词 //查找。 find(); System.out.println(str); while(m.find())&#123; System.out.println(m.group());//获取匹配的子序列 System.out.println(m.start()+":"+m.end()); &#125;&#125; 练习 1、治疗口吃:我我…我我…我我我爱…爱爱爱爱…爱爱..学学学学学…学学..习习习习.习 2、对IP地址排序。 192.168.10.34 127.0.0.1 3.3.3.3 105.70.11.55 3、对邮件地址校验。 12345678910111213//练习1public static void test_1()&#123; String str = "我我...我我...我我我爱...爱爱爱爱...爱爱..学学学学学...学学..习习习习.习"; //1，将字符串中.去掉 用替换。 str = str.replaceAll("\\.+", ""); System.out.println(str); //2,替换叠词。 str = str.replaceAll("(.)\\1+", "$1"); System.out.println(str); &#125; 12345678910111213141516171819202122232425262728//练习2public static void test_2()&#123; String ip_str = "192.168.10.34 127.0.0.1 3.3.3.3 105.70.11.55"; //1,为了让ip可以按照字符串顺序比较，只要让ip的每一段的位数相同。 //所以，补零，按照每一位所需做多0进行补充。每一段都加两个0. ip_str = ip_str.replaceAll("(\\d+)", "00$1"); System.out.println(ip_str); //然后每一段保留数字3位。 ip_str = ip_str.replaceAll("0*(\\d&#123;3&#125;)", "$1"); System.out.println(ip_str); //2、将ip地址切出。 String[] ips = ip_str.split(" +"); TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;(); for(String ip : ips)&#123; ts.add(ip); &#125; for(String ip : ts)&#123; System.out.println(ip.replaceAll("0*(\\d+)", "$1")); &#125;&#125; 123456789101112//练习3public static void test_3() &#123; String mail = "abc1@sina.com.cn"; String regex = "^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$"; boolean b = mail.matches(regex); System.out.println(mail+":"+b);&#125; 练习（爬取邮箱）12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class RegexTest2 &#123; public static void main(String[] args) throws IOException &#123; List&lt;String&gt; list = getMailsByWeb(); for(String mail : list)&#123; System.out.println(mail); &#125; &#125; public static List&lt;String&gt; getMailsByWeb() throws IOException &#123; //1,读取源文件。 URL url = new URL("http://192.168.1.100:8080/myweb/mail.html"); BufferedReader bufIn = new BufferedReader(new InputStreamReader(url.openStream())); //2,对读取的数据进行规则的匹配。从中获取符合规则的数据. String mail_regex = "\\w+@\\w+(\\.\\w+)+"; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Pattern p = Pattern.compile(mail_regex); String line = null; while((line=bufIn.readLine())!=null)&#123; Matcher m = p.matcher(line); while(m.find())&#123; //3,将符合规则的数据存储到集合中。 list.add(m.group()); &#125; &#125; return list; &#125; //爬取本地文件 public static List&lt;String&gt; getMails() throws IOException&#123; //1,读取源文件。 BufferedReader bufr = new BufferedReader(new FileReader("c:\\mail.html")); //2、剩下的和上面的一样了（从第二步骤开始） //记得将 bufIn 改为 bufr &#125; &#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-反射]]></title>
    <url>%2F2018%2F05%2F27%2FJava-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[概述 JAVA反射机制是在运行状态中，对于任意一个类 (class文件)，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性； 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 动态获取类中信息，就是java反射 ，可以理解为对类的解剖。 原理 以Tomcat为例，它对外提供了一个接口是，servlet，我们在写程序的时候可以继承这个接口 可是我们怎么让Tomcat识别我们的程序那，在Tomcat里new 一个？ 我们把我们程序的配置信息写在配置文件中，这样Tomcat就可以识别我们的程序了 反射机制 使用 Java 反射机制可以在运行时期检查 Java 类的信息， 检查 Java 类的信息往往是你在使用 Java 反射机制的时候所做的第一件事情 通过获取类的信息你可以获取以下相关的内容： Class对象 要想要对字节码文件进行解剖，必须要有字节码文件对象，如何获取字节码文件对象呢？ 第一种方式： Object类中的getClass()方法的 必须要明确具体的类，并创建对象，太麻烦 12345678910public static void getClassObject_1()&#123; Person p = new Person(); Class clazz = p.getClass(); Person p1 = new Person(); Class clazz1 = p1.getClass(); System.out.println(clazz==clazz1);&#125; 第二种方式： 任何数据类型都具备一个静态的属性.class来获取其对应的Class对象 相对简单，但是还是要明确用到类中的静态成员，还是不够扩展 1234567public static void getClassObject_2() &#123; Class clazz = Person.class; Class clazz1 = Person.class; System.out.println(clazz==clazz1);&#125; 第三种方式 可使用Class类中的 forName() 方法完成 只要通过给定的类的 字符串名称就可以获取该类，更为方便，扩展性更强 12345678public static void getClassObject_3() throws ClassNotFoundException &#123; //类名记住一定要写全 String className = "cn.java.bean.Person"; Class clazz = Class.forName(className); System.out.println(clazz);&#125; 构造函数 早期：使用 new 的时候，先根据被new的类的名称找寻该类的字节码文件，并加载进内存， 并创建该字节码文件对象，并接着创建该字节文件的对应的Person对象 1cn.java.bean.Person p = new cn.java.bean.Person(); 现在： 12345String name = "cn.java.bean.Person";//找寻该名称类文件，并加载进内存，并产生Class对象。Class clazz = Class.forName(name);//如何产生该类的对象呢？Object obj = clazz.newInstance(); 当获取指定名称对应类中的所体现的对象时， 而该对象初始化不使用空参数构造该怎么办呢？ 既然是通过指定的构造函数进行对象的初始化， 所以应该先获取到该构造函数。 通过字节码文件对象即可完成。 该方法是：getConstructor(paramterTypes); 12345678String name = "cn.java.bean.Person";//找寻该名称类文件，并加载进内存，并产生Class对象。Class clazz = Class.forName(name);//获取到了指定的构造函数对象。Constructor constructor = clazz.getConstructor(String.class,int.class);//通过该构造器对象的newInstance方法进行对象的初始化。Object obj = constructor.newInstance("小明",38); 字段123456789101112131415161718192021public static void getFieldDemo() throws Exception &#123; Class clazz = Class.forName("cn.java.bean.Person"); Field field = null;//clazz.getField("age");//只能获取公有的， field = clazz.getDeclaredField("age");//只获取本类，但包含私有。 //对私有字段的访问取消权限检查。暴力访问。 field.setAccessible(true); Object obj = clazz.newInstance(); field.set(obj, 89); Object o = field.get(obj); System.out.println(o); //上述语句，和下面语句实现了一样的功能 //cn.java.bean.Person p = new cn.itcast.bean.Person(); //p.age = 89;&#125; 方法 获取指定Class中的所有公共函数 12345678910public static void getMethodDemo() throws Exception &#123; Class clazz = Class.forName("cn.itcast.bean.Person"); Method[] methods = clazz.getMethods();//获取的都是公有的方法。 methods = clazz.getDeclaredMethods();//只获取本类中所有方法，包含私有。 for(Method method : methods)&#123; System.out.println(method); &#125;&#125; 获取指定Class中的指定空参方法 123456789101112public static void getMethodDemo_2() throws Exception &#123; Class clazz = Class.forName("cn.itcast.bean.Person"); Method method = clazz.getMethod("show", null);//获取空参数一般方法。 Constructor constructor = clazz.getConstructor(String.class,int.class); Object obj = constructor.newInstance("小明",37); method.invoke(obj, null);&#125; 获取指定Class中指定有参方法 1234567891011public static void getMethodDemo_3() throws Exception &#123; Class clazz = Class.forName("cn.itcast.bean.Person"); Method method = clazz.getMethod("paramMethod", String.class,int.class); Object obj = clazz.newInstance(); method.invoke(obj, "小强",89);&#125; 演示类（Person）123456789101112131415161718192021222324252627282930313233343536373839package cn.java.bean;public class Person &#123; private int age; private String name; public Person(String name,int age) &#123; super(); this.age = age; this.name = name; System.out.println("Person param run..."+this.name+":"+this.age); &#125; public Person() &#123; super(); System.out.println("person run"); &#125; public void show()&#123; System.out.println(name+"...show run..."+age); &#125; private void privateMethod()&#123; System.out.println(" method run "); &#125; public void paramMethod(String str,int num)&#123; System.out.println("paramMethod run....."+str+":"+num); &#125; public static void staticMethod()&#123; System.out.println(" static method run......"); &#125;&#125; 练习 需求：简易模拟电脑运行，需要声卡和网卡 因为后期可能有各种设备，所以创建接口，让设备继承接口 12345678910111213141516171819202122232425//接口public interface PCI &#123; public void open(); public void close();&#125;public class SoundCard implements PCI &#123; public void open()&#123; System.out.println("sound open"); &#125; public void close()&#123; System.out.println("sound close"); &#125;&#125;public class NetCard implements PCI &#123; public void open() &#123; System.out.println("net open"); &#125; public void close() &#123; System.out.println("net close"); &#125;&#125; 模拟主板 12345678910111213public class Mainboard &#123; public void run() &#123; System.out.println("main board run...."); &#125; public void usePCI(PCI p) &#123;//PCI p = new SouncCard(); if (p != null) &#123; p.open(); p.close(); &#125; &#125;&#125; 每次添加设备都要修改代码传递新对象吗？可以不修改代码完成该动作吗？ 创建一个配置文件，包含着各设备信息，主类中调取并实现创建对象的动作 12345678910111213141516171819202122232425262728293031public class ReflectTest &#123; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; Mainboard mb = new Mainboard(); mb.run(); File configFile = new File("pci.properties"); Properties prop = new Properties(); FileInputStream fis = new FileInputStream(configFile); prop.load(fis); for(int x=0; x&lt;prop.size(); x++)&#123; String pciName = prop.getProperty("pci"+(x+1)); Class clazz = Class.forName(pciName);//用Class去加载这个pci子类。 //这里实例化的对象，肯定是PCI的对象 PCI p = (PCI)clazz.newInstance(); mb.usePCI(p); &#125; fis.close(); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-网络编程]]></title>
    <url>%2F2018%2F05%2F26%2FJava-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述 下面给了两个链接，是关于OSI模型和TCPIP模型 网络七层模型及四层模型详解 网络编程完全总结 网络要素IP地址 网络中设备的标识 不易记忆，可用主机名 本地回环地址：127.0.0.1 主机名：localhost IP对象123456public static void main(String[] args) throws UnknownHostException &#123; InetAddress ip = InetAddress.getLocalHost(); System.out.println(ip.getHostName()+":::"+ip.getHostAddress()); ip = InetAddress.getByName("www.baidu.com"); System.out.println(ip.getHostName()+":::"+ip.getHostAddress()); &#125; 端口号 用于标识进程的逻辑地址，不同进程的标识 有效端口：0~65535，其中0~1024为系统保留端口 传输协议 通讯的规则 常见协议：TCP，UDP UDP 将数据及源和目的封装在数据包内，不需要建立连接 将每个数据包大小限制在64K内 无连接，是不可靠协议 不需建立连接，所以速度快 TCP 建立连接，形成传输数据的通道 在连接中进行大数据量传输 通过三次握手完成连接，可靠协议 必须建立连接，效率会稍低 域名解析 DNS( Domain Name System)是“域名系统”的英文缩写 它用于TCP/IP网络，提供的服务是用来将主机名和域名转换为IP地址的工作 当输入一个域名时，会先在本地的hosts下解析，如果没有就通过DNS解析为IP地址 屏蔽恶意网站原理 在本地 C:\Windows\System32\drivers\etc 目录下，有一个hosts文件 在最后面加上 127.0.0.1 www.xxxxx.com 那么这个网站就会被屏蔽掉了 socket编程UDP协议发送端 思路 1，建立UDP的socket服务 2、将要发送的数据封装到数据包中 3、通过UDP的socket服务将数据包发送出去 4、关闭socket服务 12345678910111213141516171819public static void main(String[] args) throws IOException &#123; System.out.println("发送端启动......"); //1、udpsocket服务。使用DatagramSocket对象。 DatagramSocket ds = new DatagramSocket(); //2、将要发送的数据封装到数据包中。 String str = "嘎嘎嘎嘎"; //使用DatagramPacket将数据封装到的该对象包中。 byte[] buf = str.getBytes(); DatagramPacket dp = new DatagramPacket(buf,buf.length, InetAddress.getByName("172.20.10.12"),10000); //3、通过udp的socket服务将数据包发送出去。使用send方法。 ds.send(dp); //4、关闭资源。 ds.close();&#125; 接收端 思路： 1、建立UDP socket服务,因为是要接收数据，必须要明确一个端口号 2、创建数据包，用于存储接收到的数据。方便用数据包对象的方法解析这些数据 3、使用socket服务的receive方法将接收的数据存储到数据包中 4、通过数据包的方法解析数据包中的数据 5、关闭资源 1234567891011121314151617181920212223242526public static void main(String[] args) throws IOException &#123; System.out.println("接收端启动......"); //1,建立udp socket服务。 DatagramSocket ds = new DatagramSocket(10000); //2,创建数据包。 byte[] buf = new byte[1024]; DatagramPacket dp = new DatagramPacket(buf,buf.length); //3,使用接收方法将数据存储到数据包中。 ds.receive(dp);//阻塞式的。 //4，通过数据包对象的方法，解析其中的数据,比如，地址，端口，数据内容。 String ip = dp.getAddress().getHostAddress(); int port = dp.getPort(); String text = new String(dp.getData(),0,dp.getLength()); System.out.println(ip+":"+port+":"+text); //5,关闭资源。 ds.close();&#125; 先开启接收端，再开启发送端 注意：发送端的DatagramPacket和接收端的DatagramSocket 端口需要一致 TCP协议客户端 客户端发数据到服务端 TCP传输，客户端建立的过程： 1、创建TCP客户端socket服务。使用的是Socket对象，建议该对象一创建就明确目的地，要连接的主机 2、如果连接建立成功，说明数据传输通道已建立。该通道就是socket流 ,是底层建立好的。 ​ 既然是流，说明这里既有输入，又有输出。想要输入或者输出流对象，可以找Socket来获取。 ​ 可以通过getOutputStream()，和getInputStream()来获取两个字节流。 3、使用输出流，将数据写出 4、关闭资源 1234567891011121314151617181920public static void main(String[] args) throws UnknownHostException, IOException &#123; Socket socket = new Socket("172.20.10.12",10002); OutputStream out = socket.getOutputStream(); out.write("tcp演示：哥们又来了!".getBytes()); //读取服务端返回的数据,使用socket读取流。 InputStream in = socket.getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String text = new String(buf,0,len); System.out.println(text); //关闭资源。 socket.close();&#125; 服务端 服务端接收客户端发送过来的数据，并打印在控制台上。 建立TCP服务端的思路： 1、创建服务端socket服务。通过ServerSocket对象。 2、服务端必须对外提供一个端口，否则客户端无法连接 3、获取连接过来的客户端对象 4、通过客户端对象获取socket流读取客户端发来的数据，并打印在控制台上 5、关闭资源。关客户端，关服务端 1234567891011121314151617181920212223242526public static void main(String[] args) throws IOException &#123; //1创建服务端对象。 ServerSocket ss = new ServerSocket(10002); //2,获取连接过来的客户端对象。 Socket s = ss.accept(); String ip = s.getInetAddress().getHostAddress(); //3，通过socket对象获取输入流，要读取客户端发来的数据 InputStream in = s.getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String text = new String(buf,0,len); System.out.println(ip+":"+text); //使用客户端socket对象的输出流给客户端返回数据 OutputStream out = s.getOutputStream(); out.write("收到".getBytes()); s.close(); ss.close(); &#125; 练习一需求 客户端输入字母数据，发送给服务端，服务端收到后显示在控制台， 并将该数据转成大写返回给客户端，直到客户端输入over.转换结束. 创建一个英文大写转换服务器 分析： 有客户端和服务端，使用TCP传输 客户端编写 客户端思路： 1、需要先有socket端点 2、客户端的数据源：键盘 3、客户端的目的：socket 4、接收服务端的数据，源：socket 5、将数据显示在打印出来：目的：控制台 6、在这些流中操作的数据，都是文本数据 转换客户端思路： 1、创建socket客户端对象 2、获取键盘录入 3、将录入的信息发送给socket输出流 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) throws UnknownHostException, IOException &#123; //1、创建socket客户端对象。 Socket s = new Socket("192.168.1.100",10004); //2、获取键盘录入。 BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in)); //3、socket输出流。 PrintWriter out = new PrintWriter(s.getOutputStream(),true); //4、socket输入流，读取服务端返回的大写数据 BufferedReader bufIn = new BufferedReader(new InputStreamReader(s.getInputStream())); String line = null; while((line=bufr.readLine())!=null)&#123; if("over".equals(line)) break;// out.print(line+"\r\n");// out.flush(); out.println(line); //读取服务端发回的一行大写数。 String upperStr = bufIn.readLine(); System.out.println(upperStr); &#125; s.close();&#125; 服务端编写 转换服务端思路： 1、ServerSocket服务 2、获取socket对象 3、源：socket，读取客户端发过来的需要转换的数据 4、目的：显示在控制台上 5、将数据转成大写发给客户端 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws IOException &#123; //1、ServerSocket服务 ServerSocket ss = new ServerSocket(10004); //2、获取socket对象。 Socket s = ss.accept(); //获取ip. String ip = s.getInetAddress().getHostAddress(); System.out.println(ip+"......connected"); //3、获取socket读取流，并装饰。 BufferedReader bufIn = new BufferedReader(new InputStreamReader(s.getInputStream())); //4、获取socket的输出流，并装饰。 PrintWriter out = new PrintWriter(s.getOutputStream(),true); String line = null; while((line=bufIn.readLine())!=null)&#123; System.out.println(line); out.println(line.toUpperCase());// out.print(line.toUpperCase()+"\r\n");// out.flush(); &#125; s.close(); ss.close(); &#125; 常见问题 如果将这两段代码中的PrintWriter 的true删掉，也就是不让他自动刷新 再将out.println(line) 及 out.println(line.toUpperCase())注释掉， 改写为out.print(xxx); 运行代码试试 是否发现客户端输入后，服务端没显示，客户端也不能继续输入了？ 这是因为堵塞了，没有刷新 加上out.flush()再试试？还是不行 没有换行符没法终止，服务端认为客户端没有输入完整 一定注意，需要换行和刷新，PrintWriter 的true，System.out.println(xxx) 练习二需求 客户端发送服务端文本文件，服务端接收到后，返回接收成功 客户端编写 思路： 1、创建一个socket端点 2、客户端的数据源：硬盘文件 3、客户端的目的：socket 4、接收服务端的数据，源：socket 5、将数据显示在打印出来：目的：控制台 123456789101112131415161718192021222324252627public static void main(String[] args) throws UnknownHostException, IOException &#123; System.out.println("上传客户端。。。。。。"); //1、创建socket客户端对象 Socket s = new Socket("192.168.1.100",10005); //2、读取将要传输的文件 BufferedReader bufr = new BufferedReader(new FileReader(file)); //3、socket输出流 PrintWriter out = new PrintWriter(s.getOutputStream(),true); String line = null; while((line=bufr.readLine())!=null)&#123; out.println(line); &#125; //告诉服务端，客户端写完了。 s.shutdownOutput(); //4、socket输入流，读取服务端返回的数据 BufferedReader bufIn = new BufferedReader(new InputStreamReader(s.getInputStream())); String str = bufIn.readLine(); System.out.println(str); bufr.close(); s.close();&#125; 服务端编写 服务端思路： 1、ServerSocket服务 2、获取socket对象 3、源：socket，读取客户端发过来的文件数据 4、目的：硬盘，存放在指定目录下 5、返回客户端：上传成功 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) throws IOException &#123; System.out.println("上传服务端。。。。。。。。。"); //1、ServerSocket服务 ServerSocket ss = new ServerSocket(10005); //2、获取socket对象 Socket s = ss.accept(); System.out.println(s.getInetAddress().getHostAddress()+".....connected"); //3、读取客户端发送过来的文件字节，存到缓冲区 BufferedReader bufIn = new BufferedReader(new InputStreamReader(s.getInputStream())); //4、将读取到的文件字节，存放到指定目录下 BufferedWriter bufw = new BufferedWriter(new FileWriter("c:\\server.txt")); String line = null; while((line=bufIn.readLine())!=null)&#123; bufw.write(line); bufw.newLine(); bufw.flush(); &#125; PrintWriter out = new PrintWriter(s.getOutputStream(),true); out.println("上传成功"); bufw.close(); s.close(); ss.close(); &#125; 练习三需求 多客户端进行上传图片操作，服务端接收后并回复 客户端1234567891011121314151617181920212223242526272829303132public class UploadPicClient &#123; public static void main(String[] args) throws UnknownHostException, IOException &#123; //1,创建客户端socket。 Socket s = new Socket("192.168.1.100",10006); //2,读取客户端要上传的图片文件。 FileInputStream fis = new FileInputStream("c:\\0.bmp"); //3,获取socket输出流，将读到图片数据发送给服务端。 OutputStream out = s.getOutputStream(); byte[] buf = new byte[1024]; int len = 0; while((len=fis.read(buf))!=-1)&#123; out.write(buf,0,len); &#125; //告诉服务端说：这边的数据发送完毕。让服务端停止读取。 s.shutdownOutput(); //读取服务端发回的内容。 InputStream in = s.getInputStream(); byte[] bufIn = new byte[1024]; int lenIn = in.read(buf); String text = new String(buf,0,lenIn); System.out.println(text); fis.close(); s.close(); &#125;&#125; 服务端 因为是多客户端，所以需要用多线程 否则，一个客户端传文件时，别的客户端只能等待 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class UploadTask implements Runnable &#123; private static final int SIZE = 1024*1024*2; private Socket s; public UploadTask(Socket s) &#123; this.s = s; &#125; @Override public void run() &#123; int count = 0; String ip = s.getInetAddress().getHostAddress(); System.out.println(ip + ".....connected"); try&#123; // 读取客户端发来的数据。 InputStream in = s.getInputStream(); // 将读取到数据存储到一个文件中。 File dir = new File("c:\\pic"); if (!dir.exists()) &#123; dir.mkdirs(); &#125; File file = new File(dir, ip + ".jpg"); //如果文件已经存在于服务端 while(file.exists())&#123; file = new File(dir,ip+"("+(++count)+").jpg"); &#125; FileOutputStream fos = new FileOutputStream(file); byte[] buf = new byte[1024]; int len = 0; while ((len = in.read(buf)) != -1) &#123; fos.write(buf, 0, len); if(file.length()&gt;SIZE)&#123; System.out.println(ip+"文件体积过大"); fos.close(); s.close(); System.out.println(ip+"...."+file.delete()); return ; &#125; &#125; // 获取socket输出流，将上传成功字样发给客户端。 OutputStream out = s.getOutputStream(); out.write("上传成功".getBytes()); fos.close(); s.close(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125;public class UploadPicServer &#123; public static void main(String[] args) throws IOException &#123; //创建tcp的socket服务端。 ServerSocket ss = new ServerSocket(10006); while(true)&#123; //持续获取socket对象 Socket s = ss.accept(); new Thread(new UploadTask(s)).start(); &#125; &#125;&#125; 客户端服务端原理模拟服务器 为了了解原理，自定义一个服务器 1234567891011121314151617181920212223242526public class MyTomcat &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(9090); Socket s = ss.accept(); System.out.println(s.getInetAddress().getHostAddress()+".....connected"); InputStream in = s.getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String text = new String(buf,0,len); System.out.println(text); //给客户端一个反馈信息。 PrintWriter out = new PrintWriter(s.getOutputStream(),true); out.println("嘎嘎嘎嘎"); s.close(); ss.close(); &#125;&#125; 打开浏览器，输入localhost:9090，页面显示嘎嘎嘎嘎 控制台显示： 123456780:0:0:0:0:0:0:1.....connectedGET / HTTP/1.1 Accept: text/html, application/xhtml+xml, image/jxr, */*Accept-Language: zh-CNUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299Accept-Encoding: gzip, deflateHost: localhost:9090Connection: Keep-Alive 解释： 123456GET / HTTP/1.1 请求行 请求方式 http协议版本。请求消息头 . 属性名：属性值Accept: text/html, application/xhtml+xml, image/jxr, */*.....Connection: Keep-Alive 模拟浏览器123456789101112131415161718192021222324public class MyBrowser &#123; public static void main(String[] args) throws UnknownHostException, IOException &#123; Socket s = new Socket("127.0.0.1",9090); //模拟浏览器，给tomcat服务端发送符合http协议的请求消息。 PrintWriter out = new PrintWriter(s.getOutputStream(),true); out.println("GET / HTTP/1.1"); out.println("Accept: */*"); out.println("Host: 192.168.1.100:8080"); out.println("Connection: close"); out.println(); out.println(); InputStream in = s.getInputStream(); byte[] buf = new byte[1024]; int len = in.read(buf); String str =new String(buf,0,len); System.out.println(str); s.close(); &#125;&#125; 开启模拟服务器后，再开启模拟浏览器 模拟浏览器可以看到嘎嘎嘎嘎，模拟服务器也收到了浏览器传来的数据 URL 获取URL对象的URL连接器对象。将连接封装成了对象： Java中内置的可以解析的具体协议的对象+socket 1234URLConnection conn = url.openConnection();System.out.println(conn);String value = conn.getHeaderField("Content-Type");System.out.println(value); 常用网络结构C/S client/server（客户端、服务端） 特点： 该结构的软件，客户端和服务端都需要编写 可发成本较高，维护较为麻烦 好处： 客户端在本地可以分担一部分运算 B/S browser/server（浏览器、 服务端） 特点： 该结构的软件，只开发服务器端，不开发客户端，因为客户端直接由浏览器取代。 开发成本相对低，维护更为简单 缺点： 所有运算都要在服务端完成]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-GUI]]></title>
    <url>%2F2018%2F05%2F26%2FJava-GUI%2F</url>
    <content type="text"><![CDATA[GUI(Graphical User Interface) 即图形用户界面，更方便更直接 AWT简介 在Java的早期版本中，GUI组件由名为AWT(Abstract Window Toolkit，抽象窗口工具包)的标准库来提供。 继承关系图 事件监听机制 组成 事件源 事件 监听器 处理方式 简易代码演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class MouseAndKeyDemo &#123; private Frame f; private TextField tf; private Button but; public MouseAndKeyDemo() &#123; init(); &#125; private void init() &#123; f = new Frame("演示鼠标和键盘监听"); f.setBounds(400,200,500,400); //设置流式布局 f.setLayout(new FlowLayout()); tf = new TextField(35); but = new Button("一个按钮"); f.add(tf); //将按钮添加到窗体中。 f.add(but); myEvent(); //可视化 f.setVisible(true); &#125; private void myEvent() &#123; //给文本框添加键盘监听。 tf.addKeyListener(new KeyAdapter() &#123; @Override public void keyPressed(KeyEvent e) &#123; System.out.println("key run..."+ KeyEvent.getKeyText(e.getKeyCode()) +"::::"+e.getKeyCode()); int code = e.getKeyCode(); if(!(code&gt;=KeyEvent.VK_0 &amp;&amp; code&lt;=KeyEvent.VK_9))&#123; System.out.println("必须是数字"); //非数字字符无法显示在文本框 e.consume(); &#125; &#125; &#125;); f.addWindowListener(new WindowAdapter() &#123; @Override public void windowClosing(WindowEvent e) &#123; //终止程序 System.exit(0); &#125; &#125;); but.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123;// System.out.println("action run....."); &#125; &#125;); //在按钮上添加一个鼠标监听. but.addMouseListener(new MouseAdapter() &#123; private int count = 1; @Override public void mouseEntered(MouseEvent e) &#123; System.out.println("mouse enter..."+count++); &#125; @Override public void mouseClicked(MouseEvent e) &#123; //双击 if(e.getClickCount()==2) tf.setText("mouse double click..."+count++); &#125; &#125;); &#125;&#125;public class test&#123; public static void main(String[] args) &#123; new MouseAndKeyDemo(); &#125;&#125; Swing Swing都是图形化的，很多代码都可以系统自动生成，就不详细说了 Swing不是线程安全的]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-IO流]]></title>
    <url>%2F2018%2F05%2F16%2FJava-IO%E6%B5%81%2F</url>
    <content type="text"><![CDATA[输入流和输出流相对于内存设备而言. 将外设中的数据读取到内存中：输入 将内存的数写入到外设中：输出 字节流的两个顶层父类： InputStream OutputStream. 字符流的两个顶层父类： Reader Writer 这些体系的子类都以父类名作为后缀。 而且子类名的前缀就是该对象的功能。 字符流 字符流的由来： 其实就是：字节流读取文字字节数据后，不直接操作而是先查指定的编码表。获取对应的文字。 在对这个文字进行操作。简单说：字节流+编码表 FileWriter使用方法 需求：将一些文字存储到硬盘一个文件中。流程在代码注释中。 创建一个可以往文件中写入字符数据的字符输出流对象，如第14行代码 既然是往一个文件中写入文字数据，那么在创建对象时，就必须明确该文件(用于存储数据的目的地)。 如果文件不存在，则会自动创建；如果文件存在，则会被覆盖。 为什么调用Writer对象中的write(string)方法，写入数据后，文件并没有显示写入的数据？ 其实数据只是写入到临时存储缓冲区中，还需要进行刷新 flush(); close();关闭流，关闭资源。在关闭前会先调用flush刷新缓冲中的数据到目的地。 12345678910111213141516171819202122232425262728public class FileWriterDemo &#123; //换行，unix windows 不一样 ,所以使用这个 private static final String LINE_SEPARATOR = System.getProperty("line.separator"); public static void main(String[] args) throws IOException &#123; //创建一个可以往文件中写入字符数据的字符输出流对象。 /* * 如果构造函数中加入true，可以实现对文件进行续写！ */ FileWriter fw = new FileWriter("demo.txt",true); //调用Writer对象中的write(string)方法，写入数据 fw.write("abcde"+LINE_SEPARATOR+"hahaha"); //fw.write("xixi"); //进行刷新，将数据直接写到目的地中。 fw.flush(); // 关闭流，关闭资源。在关闭前会先调用flush刷新缓冲中的数据到目的地。 fw.close(); //关闭流后，无法再进行写操作// fw.write("haha");// java.io.IOException: Stream closed &#125;&#125; 处理异常 最好使用try，catch。在外部初始化创建 fileWriter，new在try代码块内部 finally中判断是否为空，然后写关闭的语句，给它也进行try，catch 1234567891011121314151617181920212223242526public class IOExceptionDemo &#123; public static void main(String[] args) &#123; FileWriter fw = null; try &#123; fw = new FileWriter("k:\\demo.txt"); fw.write("abcde" + LINE_SEPARATOR + "hahaha"); &#125; catch (IOException e) &#123; System.out.println(e.toString()); &#125; finally &#123; if (fw != null) try &#123; fw.close(); &#125; catch (IOException e) &#123; // code.... throw new RuntimeException("关闭失败"); &#125; &#125; &#125;&#125; FileReader 需求：读取一个文本文件。将读取到的字符打印到控制台 12345678FileReader fr = new FileReader("demo.txt");int ch = 0;while((ch=fr.read())!=-1)&#123; System.out.println((char)ch);&#125;//如果读完已有值后，再读取文件，会返回-1 第二种读取方式： 以数组为单位的读取 12345678假设demo.txt中有 abcde 五个字母char[] buf = new char[3];//将读取到的字符存储到数组中int num = fr.read(buf);System.out.println(num+":"+new String(buf)); //abcint num1 = fr.read(buf);System.out.println(num1+":"+new String(buf)); //dec 为什么一共只有五个字母，第二次读取时却是 ”dec“ ？ 因为是存在缓冲区，第一次abc没有清除，第二次是de覆盖了ab 1234567FileReader fr = new FileReader("demo.txt");char[] buf = new char[1024];int len = 0;while((len=fr.read(buf))!=-1)&#123; System.out.println(new String(buf,0,len));//读取buf，从0读到len&#125; 练习：复制文件 练习：将c盘的一个文本文件复制到d盘 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CopyTextTest_2 &#123; private static final int BUFFER_SIZE = 1024; public static void main(String[] args) &#123; //读取一个已有的文本文件，使用字符读取流和文件相关联。 FileReader fr = null; //创建一个目的，用于存储读到数据。 FileWriter fw = null; try &#123; fr = new FileReader("IO流_2.txt"); fw = new FileWriter("copytest_2.txt"); //创建一个临时容器，用于缓存读取到的字符。 char[] buf = new char[BUFFER_SIZE];//这就是缓冲区。 //定义一个变量记录读取到的字符数，(其实就是往数组里装的字符个数 ) int len = 0; while((len=fr.read(buf))!=-1)&#123; fw.write(buf, 0, len); //读取buf，从0开始，len结束 &#125; &#125; catch (Exception e) &#123; throw new RuntimeException("读写失败"); &#125;finally&#123; if(fw!=null) try &#123; fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if(fr!=null) try &#123; fr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 缓冲区 这就好比去超市，没有缓冲区就是买一样东西一结帐，有缓冲区就是拿着筐或者推着车，买完再结帐，可以大幅度提高效率 不过如果车过大会堵塞出口，那样的话就可以在车子里面放几个筐，结账用筐，也会提高效率 BufferWriter12345678910111213141516171819public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWriter("buf.txt"); //为了提高写入的效率。使用了字符流的缓冲区。 //创建了一个字符写入流的缓冲区对象，并和指定要被缓冲的流对象相关联 BufferedWriter bufw = new BufferedWriter(fw); //使用缓冲区的写入方法将数据先写入到缓冲区中。 for(int x=1; x&lt;=4; x++)&#123; bufw.write("abcdef"+x); bufw.newLine(); //使用缓冲区的刷新方法将数据刷目的地中。 bufw.flush(); &#125; //关闭缓冲区。其实关闭的就是被缓冲的流对象。 bufw.close();&#125; BufferReader123456789101112131415FileReader fr = new FileReader("buf.txt"); BufferedReader bufr = new BufferedReader(fr);FileWriter fw = new FileWriter("buf_copy.txt");BufferedWriter bufw = new BufferedWriter(fw);String line = null;while((line=bufr.readLine())!=null)&#123; bufw.write(line); bufw.newLine(); bufw.flush();&#125; bufw.close();bufr.close(); 自定义MyBufferReader1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * 自定义的读取缓冲区。其实就是模拟一个BufferedReader. * * 分析： * 缓冲区中无非就是封装了一个数组， * 并对外提供了更多的方法对数组进行访问。 * 其实这些方法最终操作的都是数组的角标。 * * 缓冲的原理： * 其实就是从源中获取一批数据装进缓冲区中。 * 在从缓冲区中不断的取出一个一个数据。 * * 在此次取完后，在从源中继续取一批数据进缓冲区。 * 当源中的数据取光时，用-1作为结束标记。 */public class MyBufferedReader extends Reader &#123; private Reader r; //定义一个数组作为缓冲区。 private char[] buf = new char[1024]; //定义一个指针用于操作这个数组中的元素。当操作到最后一个元素后，指针应该归零。 private int pos = 0; //定义一个计数器用于记录缓冲区中的数据个数。 当该数据减到0，就从源中继续获取数据到缓冲区中。 private int count = 0; MyBufferedReader(Reader r)&#123; this.r = r; &#125; /** * 该方法从缓冲区中一次取一个字符。 * @return * @throws IOException */ public int myRead() throws IOException&#123; if(count==0)&#123; count = r.read(buf); pos = 0; &#125; if(count&lt;0) return -1; char ch = buf[pos++]; count--; return ch; &#125; public String myReadLine() throws IOException&#123; StringBuilder sb = new StringBuilder(); int ch = 0; while((ch = myRead())!=-1)&#123; if(ch=='\r') continue; if(ch=='\n') return sb.toString(); //将从缓冲区中读到的字符，存储到缓存行数据的缓冲区中。 sb.append((char)ch); &#125; if(sb.length()!=0) return sb.toString(); return null; &#125; public void myClose() throws IOException &#123; r.close();&#125; 装饰设计模式 对一组对象的功能进行增强时，就可以使用该模式进行问题的解决。 缓冲区的设计就是基于装饰设计模式实现的 然而装饰和继承都能实现一样的特点：进行功能的扩展增强。哪个好那？ 装饰和继承对比 假设有一个继承体系 123Writer |--TextWriter：用于操作文本 |--MediaWriter：用于操作媒体。 想要对操作的动作进行效率的提高，需要加入缓冲技术。 按照面向对象，可以通过继承对具体的进行功能的扩展。 12345678Writer |--TextWriter：用于操作文本 |--BufferTextWriter：加入了缓冲技术的操作文本的对象。 |--MediaWriter：用于操作媒体。 |--BufferMediaWriter:但是这样做好像并不理想，如果这个体系进行功能扩展，又多了流对象。那么这个流要提高效率，是不是也要产生子类呢？是。这时就会发现只为提高功能，进行的继承，导致继承体系越来越臃肿。不够灵活。 既然加入的都是同一种技术–缓冲。前一种是让缓冲和具体的对象相结合。 可不可以将缓冲进行单独的封装，哪个对象需要缓冲就将哪个对象和缓冲关联。 12345678910Writer |--TextWriter：用于操作文本 |--MediaWriter：用于操作媒体。 |--BufferWriter：用于提高效率。 class BufferWriter extends Writer&#123; BufferWriter(Writer w) &#123; &#125;&#125; 装饰比继承灵活 特点：装饰类和被装饰类都必须所属同一个接口或者父类。 LineNumberReader 可以增添行号 12345678910111213public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader("IO流_2.txt"); LineNumberReader lnr = new LineNumberReader(fr); String line = null; lnr.setLineNumber(100); while((line=lnr.readLine())!=null)&#123; System.out.println(lnr.getLineNumber()+":"+line); &#125; lnr.close();&#125; 字节流12345678910111213141516171819202122232425public static void demo_read() throws IOException &#123; //1，创建一个读取流对象。和指定文件关联。 FileInputStream fis = new FileInputStream("bytedemo.txt"); //建议使用这种读取数据的方式 byte[] buf = new byte[1024]; int len = 0; while((len=fis.read(buf))!=-1)&#123; System.out.println(new String(buf,0,len)); &#125; fis.close();&#125;public static void demo_write() throws IOException &#123; //1，创建字节输出流对象。用于操作文件. FileOutputStream fos = new FileOutputStream("bytedemo.txt"); //2,写数据。直接写入到了目的地中。 fos.write("abcdefg".getBytes()); fos.close();//关闭资源动作要完成。 &#125; 练习 复制一个Mp3文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class CopyMp3Test &#123; /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; copy_2(); &#125; //fis.available()：文件的字节数 //如果文件字节数特别大，那么速度会很慢 //不建议使用 public static void copy_3() throws IOException &#123; FileInputStream fis = new FileInputStream("c:\\0.mp3"); FileOutputStream fos = new FileOutputStream("c:\\3.mp3"); byte[] buf = new byte[fis.available()]; fis.read(buf); fos.write(buf); fos.close(); fis.close(); &#125; public static void copy_2() throws IOException &#123; FileInputStream fis = new FileInputStream("c:\\0.mp3"); BufferedInputStream bufis = new BufferedInputStream(fis); FileOutputStream fos = new FileOutputStream("c:\\2.mp3"); BufferedOutputStream bufos = new BufferedOutputStream(fos); int ch = 0; while((ch=bufis.read())!=-1)&#123; bufos.write(ch); &#125; bufos.close(); bufis.close(); &#125; public static void copy_1() throws IOException &#123; FileInputStream fis = new FileInputStream("c:\\0.mp3"); FileOutputStream fos = new FileOutputStream("c:\\1.mp3"); byte[] buf = new byte[1024]; int len = 0; while((len=fis.read(buf))!=-1)&#123; fos.write(buf,0,len); &#125; fos.close(); fis.close(); &#125;&#125; 键盘录入 运行下面代码后，在控制台输入一个字母，按回车运行，是不是发现多出来一个 10 ？ 是的，这个是“ \n ”,也就是刚才的回车。 12345678910public static void readKey() throws IOException &#123; InputStream in = System.in; int ch = in.read();//阻塞式方法。 System.out.println(ch); int ch1 = in.read();//阻塞式方法。 System.out.println(ch1);&#125; 练习 获取用户键盘录入的数据，并将数据变成大写显示在控制台上 如果用户输入的是over，结束键盘录入。 12345678910111213141516171819202122232425262728public static void readKey2() throws IOException &#123; //1，创建容器。 StringBuilder sb = new StringBuilder(); //2，获取键盘读取流。 InputStream in = System.in; //3，定义变量记录读取到的字节，并循环获取。 int ch = 0; while((ch=in.read())!=-1)&#123; //在存储之前需要判断是否是换行标记 ,因为换行标记不存储。 if(ch=='\r') continue; if(ch=='\n')&#123; String temp = sb.toString(); if("over".equals(temp)) break; System.out.println(temp.toUpperCase()); sb.delete(0, sb.length()); &#125; else //将读取到的字节存储到StringBuilder中。 sb.append((char)ch); &#125;&#125; 转换流123456789101112131415161718192021222324252627/* 这是方便理解的做法//字节流InputStream in = System.in;OutputStream out = System.out;//将字节转成字符的桥梁。装换流。 InputStreamReader isr = new InputStreamReader(in);OutputStreamWriter osw = new OutputStreamWriter(out);//字符流。BufferedReader bufr = new BufferedReader(isr);BufferedWriter bufw = new BufferedWriter(osw);*///更简洁BufferReader bufr = new BufferReader(new InputStream(System.in));BufferWriter bufr = new BufferWriter(new OutputStream(System.out));String line = null;while((line=bufr.readLine())!=null)&#123; if("over".equals(line)) break; bufw.write(line.toUpperCase()); bufw.newLine(); bufw.flush();&#125; 1、需求：将键盘录入的数据写入到一个文件中。 12BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in));BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(newFileOutputStream("a.txt"))); 2、需求：将一个文本文件内容显示在控制台上。 12BufferedReader bufr = new BufferedReader(new InputStreamReader(newFileInputStream("a.txt")));BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(System.out)); 3、需求：将一个文件文件中的内容复制到的另一个文件中。 12BufferedReader bufr = new BufferedReader(new InputStreamReader(newFileInputStream("a.txt")));BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(newFileOutputStream("b.txt"))); 根据不同的需求，改变源的不同位置即可 编码解码 file 流中的read write都是默认编码，如果需要指定编码，则选择其父类 InputStreamReader 、OutputStreamWriter OutputStreamWriter接收一个字节输出流对象，既然是操作文件，那么该对象应该是FileOutputStream 12345OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("uu.txt"),"UTF-8");//BufferedWriter bufw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("uu.txt"),"UTF-8"));osw.write("你好");osw.close(); 什么时候使用转换流呢？ 1、源或者目的对应的设备是字节流，但是操作的却是文本数据，可以使用转换作为桥梁。提高对文本操作的便捷。 2、一旦操作文本涉及到具体的指定编码表时，必须使用转换流 。 流的操作规律 之所以要弄清楚这个规律，是因为流对象太多，开发时不知道用哪个对象合适。 想要知道开发时用到哪些对象。只要通过四个明确即可。 1、明确源和目的(汇) 12源：InputStream Reader目的：OutputStream Writer 2、明确数据是否是纯文本数据。 12345源：是纯文本： Reader 否： InputStream目的：是纯文本： Writer 否： OutputStream 到这里，就可以明确需求中具体要使用哪个体系。 3、明确具体的设备。 12345源设备： 硬盘： File 键盘： System.in 内存： 数组 网络： Socket流 12345目的设备： 硬盘： File 控制台：System.out 内存： 数组 网络： Socket流 4、是否需要其他额外功能。 12341、是否需要高效(缓冲区); 是，就加上buffer.2、转换。 File对象 可以将一个已存在的，或者不存在的文件或者目录封装成file对象。 123456File f1 = new File("c:\\a.txt");File f2 = new File("c:\\","a.txt");File f = new File("c:\\");File f3 = new File(f,"a.txt");File f4 = new File("c:"+File.separator+"abc"+File.separator+"a.txt");System.out.println(f4); 方法 1、获取 获取文件名称 1.2 获取文件路径 1.3 获取文件大小 1.4 获取文件修改时间 12345678910File file = new File("a.txt");String name = file.getName();String absPath = file.getAbsolutePath();//绝对路径（开头有盘符）String path = file.getPath(); //相对路径（开头无盘符）（找不到父目录）long len = file.length();long time = file.lastModified(); //毫秒值Date date = new Date(time); //Date对象格式化DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);String str_time = dateFormat.format(date); 2、创建与删除 123456789101112131415//和输出流不一样，如果文件不存在，则创建，如果文件存在，则不创建。 boolean b = file.createNewFile(); System.out.println("b="+b);boolean b = file.delete();System.out.println("b="+b);File dir = new File("abc");boolean b = dir.mkdir();//make directory System.out.println("b="+b);System.out.println(dir.delete()); //慎用，不走回收站File dir = new File("abc\\q\\e\\c\\z\\r\\w\\y\\f\\e\\g\\s");dir.mkdirs();//创建多级目录System.out.println(dir.delete()); //运行后，仅删除 S 文件夹 3、判断 123456File f = new File("aaa"); boolean b = f.exists(); //是否存在 System.out.println("b="+b);// 最好先判断是否存在。 System.out.println(f.isFile()); //是否是文件System.out.println(f.isDirectory());//是否是目录 4、重命名 123456//可以从C到D盘 重命名//即为剪切C盘的文件，复制到D盘File f1 = new File("c:\\9.mp3");File f2 = new File("d:\\aa.mp3");boolean b = f1.renameTo(f2);System.out.println("b="+b); 根目录方法12345678File[] files = File.listRoots();for(File file : files)&#123; System.out.println(file);&#125;File file = new File("d:\\");System.out.println("getFreeSpace:"+file.getFreeSpace()); //空闲容量System.out.println("getTotalSpace:"+file.getTotalSpace()); //总容量System.out.println("getUsableSpace:"+file.getUsableSpace());//可使用容量 获取目录内容 获取当前目录下的文件以及文件夹的名称，包含隐藏文件 调用list方法的File对象中封装的必须是目录,否则会发生NullPointerException 如果访问的系统级目录也会发生空指针异常。 如果目录存在但是没有内容，会返回一个数组，但是长度为0. 123456789public static void listDemo() &#123; File file = new File("c:\\"); String[] names = file.list(); System.out.println(names.length); for(String name : names)&#123; System.out.println(name); &#125;&#125; 过滤器 显示后缀.java 的文件，使用 File类的 list方法 12345678public class FilterByJava implements FilenameFilter &#123; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(".java"); &#125;&#125; 显示未隐藏的文件，使用 listFiles 方法 12345678910111213141516171819public class FilterByHidden implements FileFilter &#123; @Override public boolean accept(File pathname) &#123; return !pathname.isHidden(); &#125;&#125;public static void listDemo() &#123; File dir = new File("c:\\"); File[] files = dir.listFiles(new FilterByHidden()); for(File file : files)&#123; System.out.println(file); &#125;&#125; 如果想过滤后缀，但是每次改过滤器太复杂，可以重新设计过滤器 1234567891011121314public class SuffixFilter implements FilenameFilter &#123; private String suffix ; public SuffixFilter(String suffix) &#123; super(); this.suffix = suffix; &#125; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(suffix); &#125;&#125; 这样ListDemo 类中就可以更改想要的后缀 12String[] names = dir.list(new SuffixFilter(".txt"));String[] names = dir.list(new SuffixFilter(".java")); 练习深度遍历 需求：对指定目录进行所有内容的列出（包含子目录中的内容），也可以理解为 深度遍历。 1234567891011121314151617181920212223242526272829public class FileTest &#123; public static void main(String[] args) &#123; File dir = new File("d:\\MyBlog"); listAll(dir,0); &#125; public static void listAll(File dir, int level) &#123; System.out.println(getSpace(level)+dir.getAbsolutePath()); level++; File[] file = dir.listFiles(); for (int x = 0; x &lt; file.length; x++) &#123; if (file[x].isDirectory()) listAll(file[x], level); else System.out.println(getSpace(level)+file[x].getAbsoluteFile()); &#125; &#125; private static String getSpace(int level) &#123; StringBuilder sb = new StringBuilder(); sb.append("|-- "); for (int i = 0; i &lt; level; i++) &#123; sb.insert(0, "| "); &#125; return sb.toString(); &#125;&#125; 删除目录（含内容的） 删除一个带内容的目录。 原理：必须从最里面往外，需要进行深度遍历。 12345678910111213141516public class Remove &#123; public static void main(String[] args) &#123; File dir = new File("d:\\demodemo"); remove(dir); &#125; public static void remove(File dir)&#123; File[] files = dir.listFiles(); for (File file:files)&#123; if (file.isDirectory()) remove(file); else System.out.println( file+":"+file.delete()); &#125; System.out.println( dir+":"+dir.delete()); &#125;&#125; Properties概述 Properties 是Map 子类Hashtable 的子类 Properties集合特点： 该集合中的键和值都是字符串类型。 集合中的数据可以保存到流中，或者从流获取。 通常该集合用于操作以键值对形式存在的配置文件。 演示方法 倒数第二行注意，大多数时候用于调试 123456789101112131415161718192021222324public static void propertiesDemo()&#123; //创建一个Properties集合。 Properties prop = new Properties(); //存储元素。 prop.setProperty("zhangsan","30"); prop.setProperty("lisi","31"); prop.setProperty("wangwu","36"); prop.setProperty("zhaoliu","20"); //修改元素。 prop.setProperty("wangwu","26"); //取出所有元素。 Set&lt;String&gt; names = prop.stringPropertyNames(); for(String name : names)&#123; String value = prop.getProperty(name); System.out.println(name+":"+value); &#125; //多用于调试，在控制台显示所有信息 prop.list(System.out);&#125; 想要将这些集合中的字符串键值信息持久化存储到文件中，则需要关联输出流。（使用store方法） 12345678910111213141516public static void methodDemo_3() throws IOException &#123; Properties prop = new Properties(); //存储元素。 prop.setProperty("zhangsan","30"); prop.setProperty("lisi","31"); //关联输出流。 FileOutputStream fos = new FileOutputStream("info.txt"); //将集合中数据存储到文件中，使用store方法。 prop.store(fos, "info"); fos.close();&#125; 既然可以存在文件中，自然可以在文件中读取（使用load方法） 注意：必须要保证该文件中的数据是键值对 12345678910111213public static void methodDemo_4() throws IOException &#123; Properties prop = new Properties(); //使用到读取流。 FileInputStream fis = new FileInputStream("info.txt"); //使用load方法。 prop.load(fis); prop.list(System.out);&#125; load方法原理1234567891011121314151617181920212223public static void myLoad() throws IOException&#123; Properties prop = new Properties(); BufferedReader bufr = new BufferedReader(new FileReader("info.txt")); String line = null; while((line=bufr.readLine())!=null)&#123; if(line.startsWith("#")) continue; String[] arr = line.split("="); prop.setProperty(arr[0], arr[1]); &#125; prop.list(System.out); bufr.close();&#125; 修改配置信息 流程 读取文件 创建集合存储配置信息 将流信息存储到集合中 修改集合 将集合信息写回文件中 123456789101112131415161718192021222324public static void test(File file) throws IOException&#123; //读取这个文件。 if(!file.exists())&#123; file.createNewFile(); &#125; FileReader fr = new FileReader(file); //创建集合存储配置信息。 Properties prop = new Properties(); //将流中信息存储到集合中。 prop.load(fr); prop.setProperty("wangwu", "16"); //需要信息修改完后才能将集合与输出流相关联 FileWriter fw = new FileWriter(file); prop.store(fw,""); fw.close(); fr.close();&#125; 练习一 定义功能：获取一个应用程序运行的次数， 如果超过5次，给出使用次数已到请注册的提示，并不要在运行程序。 123456789101112131415161718思路：1、 应该有计数器。 每次程序启动都需要计数一次,并且是在原有的次数上进行计数。2、 计数器就是一个变量。 那么我们就可以，程序启动时候进行计数，计数器必须存在于内存并进行运算。 可是程序一结束，计数器消失了。那么再次启动该程序，计数器又重新被初始化了。 而我们需要多次启动同一个应用程序，使用的是同一个计数器。 这就需要计数器的生命周期变长，从内存存储到硬盘文件中。3、 如何使用这个计数器呢？ 首先，程序启动时，应该先读取这个用于记录计数器信息的配置文件。 获取上一次计数器次数。 并进行试用次数的判断。 其次，对该次数进行自增，并自增后的次数重新存储到配置文件中。 4、 文件中的信息该如何进行存储并体现。 直接存储次数值可以，但是不明确该数据的含义。 所以起名字就变得很重要。 这就有了名字和值的对应，所以可以使用键值对。 可是映射关系map集合搞定，又需要读取硬盘上的数据，所以map+io = Properties. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class PropertiesTest &#123; public static void main(String[] args) throws IOException &#123; getAppCount(); &#125; public static void getAppCount() throws IOException&#123; //将配置文件封装成File对象。 File confile = new File("count.properties"); if(!confile.exists())&#123; confile.createNewFile(); &#125; FileInputStream fis = new FileInputStream(confile); Properties prop = new Properties(); prop.load(fis); //从集合中通过键获取次数。 String value = prop.getProperty("time"); //定义计数器。记录获取到的次数。 int count =0; if(value!=null)&#123; count = Integer.parseInt(value); if(count&gt;=5)&#123; throw new RuntimeException("使用次数已到，请充值vip，给钱！"); &#125; &#125; count++; //将改变后的次数重新存储到集合中。 prop.setProperty("time", count+""); FileOutputStream fos = new FileOutputStream(confile); prop.store(fos, ""); fos.close(); fis.close(); &#125;&#125; 练习二 获取指定目录下，指定扩展名的文件(包含子目录中的)，将这些文件的绝对路径写入到一个文本文件中。 简单说，就是建立一个指定扩展名的文件的列表。 思路： 进行深度遍历 创建过滤器，将符合要求的文件绝对路径写入集合 对容器中内容遍历并将绝对路径写入文件中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//过滤器public class Filter implements FilenameFilter &#123; private String suffix; public Filter(String suffix) &#123; super(); this.suffix = suffix; &#125; @Override public boolean accept(File dir, String name) &#123; return name.endsWith(suffix); &#125;&#125;public class test &#123; public static void main(String[] args) &#123; File dir = new File("D:\\Code\\Java"); //过滤".java"结尾的文件 Filter filter = new Filter(".java"); getFileList(dir,filter); &#125; private static void getFileList(File dir, FilenameFilter filter) &#123; //判断目录是否存在，增强健壮性 if (!dir.exists()) throw new NullPointerException("该指定目录不存在"); //创建容器 List&lt;File&gt; list = new ArrayList(); getFile(dir,filter,list); //destfile：要存储到的目的文件 File destfile = new File(dir,"javaList.txt"); writeToFile(list,destfile); &#125; private static void getFile(File dir, FilenameFilter filter, List&lt;File&gt; list) &#123; File[] files = dir.listFiles(); //深度遍历 for (File file:files)&#123; //如果是文件夹，递归 if (file.isDirectory()) getFile(file, filter, list); else//过滤文件，将其添加到容器中 if (filter.accept(file, file.getName())) &#123; list.add(file); &#125; &#125; &#125; private static void writeToFile(List&lt;File&gt; list, File destfile) &#123; BufferedWriter bw = null; try &#123; bw = new BufferedWriter(new FileWriter(destfile)); for (File file:list)&#123; bw.write(file.getAbsolutePath()); bw.newLine(); bw.flush(); &#125; &#125; catch (IOException e) &#123; throw new RuntimeException("写入失败"); &#125; finally &#123; if (bw != null) &#123; try &#123; bw.close(); &#125; catch (IOException e) &#123; throw new RuntimeException("关闭失败"); &#125; &#125; &#125; &#125;&#125; 打印流PrintStream 1、提供了打印方法可以对多种数据类型值进行打印。并保持数据的表示形式。 2、它不抛IOException 构造函数，接收三种类型的值： 1、字符串路径 2、File对象 3、字节输出流 1234567891011public static void main(String[] args) throws IOException &#123; PrintStream out = new PrintStream("print.txt"); //只写最低8位，对比下面两个结果，文件中存储的值都为 b out.write(98); out.write(610); //将97先变成字符保持原样将数据打印到目的地。 out.print(97); out.close();&#125; PrintWriter 字符打印流 构造函数参数： 1、字符串路径 2、File对象 3、字节输出流 4、字符输出流 12345678910111213141516public static void main(String[] args) throws IOException &#123; BufferedReader bufr = new BufferedReader(new InputStreamReader(System.in)); //在创建输出流的时候，最后加上true，则可以自动刷新 PrintWriter out = new PrintWriter(new FileWriter("out.txt"),true); //PrintWriter out = new PrintWriter(System.out,true);//在控制台输出 String line = null; while((line=bufr.readLine())!=null)&#123; if("over".equals(line)) break; out.println(line.toUpperCase()); //out.flush; 第四行中有了true的设置，就不用手动刷新了 &#125; out.close(); bufr.close();&#125; 序列流 可以将文件合并为一个序列流，对其进行操作 需求：将1.txt 2.txt 3.txt文件中的数据合并到一个文件中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class SequenceInputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //Vector含枚举，但是太慢了 ArrayList&lt;FileInputStream&gt; al = new ArrayList&lt;FileInputStream&gt;(); for(int x=1; x&lt;=3; x++)&#123; al.add(new FileInputStream(x+".txt")); &#125; Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al); /* 这里是Collection工具类的enumeration实现原理 //利用迭代器和新建的枚举 final Iterator&lt;FileInputStream&gt; it = al.iterator(); Enumeration&lt;FileInputStream&gt; en = new Enumeration&lt;FileInputStream&gt;()&#123; @Override public boolean hasMoreElements() &#123; return it.hasNext(); &#125; @Override public FileInputStream nextElement() &#123; return it.next(); &#125; &#125;;*/ SequenceInputStream sis = new SequenceInputStream(en); FileOutputStream fos = new FileOutputStream("1234.txt"); byte[] buf = new byte[1024]; int len = 0; while((len=sis.read(buf))!=-1)&#123; fos.write(buf,0,len); &#125; fos.close(); sis.close(); &#125;&#125; 文件切割与合并切割 需求：将一个.MP3 文件按照 1M 切割 思路： 用读取流关联源文件，定义缓冲区 创建目的 将被切割文件的信息保存到prop集合中 将prop集合中的数据存储到文件中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class SplitFileDemo &#123; private static final int SIZE = 1024 * 1024; public static void main(String[] args) throws Exception &#123; File file = new File("c:\\aa.mp3"); splitFile(file); &#125; private static void splitFile(File file) throws IOException &#123; // 用读取流关联源文件。 FileInputStream fis = new FileInputStream(file); // 定义一个1M的缓冲区。 byte[] buf = new byte[SIZE]; // 创建目的。 FileOutputStream fos = null; int len = 0; int count = 1; /* * 切割文件时，必须记录住被切割文件的名称，以及切割出来碎片文件的个数。 以方便于合并。 * 这个信息为了进行描述，使用键值对的方式。用到了properties对象 * */ Properties prop = new Properties(); File dir = new File("c:\\partfiles"); if (!dir.exists()) dir.mkdirs(); while ((len = fis.read(buf)) != -1) &#123; fos = new FileOutputStream(new File(dir, (count++) + ".part")); fos.write(buf, 0, len); fos.close(); &#125; //将被切割文件的信息保存到prop集合中。 prop.setProperty("partcount", count+""); prop.setProperty("filename", file.getName()); fos = new FileOutputStream(new File(dir,count+".properties")); //将prop集合中的数据存储到文件中。 prop.store(fos, "save file info"); fos.close(); fis.close(); &#125;&#125; 合并 被切割的文件是无法被运行的，需要进行合并（以上面切割代码为示例） 思路： 获取指定目录下的配置文件对象 记录配置文件对象，获取该配置文件中的信息 获取该目录下的所有碎片文件（.part） 将碎片文件和流对象关联 并存储到集合中 将多个流合并成一个序列流，输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MergeFile &#123; public static void main(String[] args) throws IOException &#123; File dir = new File("c:\\partfiles"); mergeFile(dir); &#125; public static void mergeFile(File dir) throws IOException &#123; /* * 获取指定目录下的配置文件对象。 */ File[] files = dir.listFiles(new SuffixFilter(".properties")); if(files.length!=1) throw new RuntimeException(dir+",该目录下没有properties扩展名的文件或者不唯一"); //记录配置文件对象。 File confile = files[0]; //获取该文件中的信息 Properties prop = new Properties(); FileInputStream fis = new FileInputStream(confile); prop.load(fis); String filename = prop.getProperty("filename"); int count = Integer.parseInt(prop.getProperty("partcount")); //获取该目录下的所有碎片文件。 File[] partFiles = dir.listFiles(new SuffixFilter(".part")); if(partFiles.length!=(count-1))&#123; throw new RuntimeException(" 碎片文件不符合要求，个数不对!应该"+count+"个"); &#125; //将碎片文件和流对象关联 并存储到集合中。 ArrayList&lt;FileInputStream&gt; al = new ArrayList&lt;FileInputStream&gt;(); for(int x=0; x&lt;partFiles.length; x++)&#123; al.add(new FileInputStream(partFiles[x])); &#125; //将多个流合并成一个序列流。 Enumeration&lt;FileInputStream&gt; en = Collections.enumeration(al); SequenceInputStream sis = new SequenceInputStream(en); FileOutputStream fos = new FileOutputStream(new File(dir,filename)); byte[] buf = new byte[1024]; int len = 0; while((len=sis.read(buf))!=-1)&#123; fos.write(buf,0,len); &#125; fos.close(); sis.close(); &#125;&#125; 操作对象流 平常创建的对象都是存储在硬盘上，通过对象输出流可以将其存储在硬盘中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * Serializable：用于给被序列化的类加入ID号。 * 用于判断类和对象是否是同一个版本。 */public class Person implements Serializable/*标记接口*/ &#123; /** * transient：非静态数据不想被序列化可以使用这个关键字修饰。 * 如果不自己添加序列号，序列化后更改name为public 就会报错 */ private static final long serialVersionUID = 9527l; private String name; private int age; //构造函数 //get set函数&#125;public class ObjectStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; writeObj(); readObj(); &#125; public static void readObj() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream("obj.object")); //对象的反序列化。 Person p = (Person)ois.readObject(); System.out.println(p.getName()+":"+p.getAge()); ois.close(); &#125; public static void writeObj() throws IOException, IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("obj.object")); //对象序列化。 被序列化的对象必须实现Serializable接口。 oos.writeObject(new Person("小强",30)); oos.close(); &#125;&#125; RandomAccessFile 特点： 1、即可读取，又可以写入。 2、内部维护了一个大型的byte数组，通过对数组的操作完成读取和写入。 3、通过getFilePointer方法获取指针的位置，还可以通过seek方法设置指针的位置。 4、该对象的内容应该封装了字节输入流和字节输出流。 5、该对象只能操作文件。 注意： 通过seek方法操作指针，可以从这个数组中的任意位置上进行读和写，可以完成对数据的修改。 但是要注意：数据必须有规律。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class RandomAccessFileDemo &#123; public static void main(String[] args) throws IOException &#123; // writeFile();// readFile(); randomWrite(); &#125; public static void randomWrite() throws IOException&#123; RandomAccessFile raf = new RandomAccessFile("ranacc.txt", "rw"); //往指定位置写入数据。 raf.seek(3*8); raf.write("哈哈".getBytes()); raf.writeInt(108); raf.close(); &#125; public static void readFile() throws IOException &#123; RandomAccessFile raf = new RandomAccessFile("ranacc.txt", "r"); //通过seek设置指针的位置。 raf.seek(1*8);//随机的读取。只要指定指针的位置即可。 byte[] buf = new byte[4]; raf.read(buf); String name = new String(buf); int age = raf.readInt(); System.out.println("name="+name); System.out.println("age="+age); System.out.println("pos:"+raf.getFilePointer()); raf.close(); &#125; //使用RandomAccessFile对象写入一些人员信息，比如姓名和年龄。 public static void writeFile() throws IOException&#123; //如果文件不存在，则创建，如果文件存在，不创建 RandomAccessFile raf = new RandomAccessFile("ranacc.txt","rw"); raf.write("张三".getBytes()); raf.writeInt(97); raf.write("小强".getBytes()); raf.writeInt(99); raf.close(); &#125;&#125; 管道流 需要和多线程技术相结合的流对象 PipedOutputStream、PipedInputStream 如果想指定哪里来的数据读取哪个数据的话，需要将两个流接上，则使用管道流 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class PipedStream &#123; public static void main(String[] args) throws IOException &#123; PipedInputStream input = new PipedInputStream(); PipedOutputStream output = new PipedOutputStream(); input.connect(output); new Thread(new Input(input)).start(); new Thread(new Output(output)).start(); &#125;&#125;class Input implements Runnable&#123; private PipedInputStream in; Input(PipedInputStream in)&#123; this.in = in; &#125; public void run()&#123; try &#123; byte[] buf = new byte[1024]; int len = in.read(buf); String s = new String(buf,0,len); System.out.println("s="+s); in.close(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;&#125;class Output implements Runnable&#123; private PipedOutputStream out; Output(PipedOutputStream out)&#123; this.out = out; &#125; public void run()&#123; try &#123; Thread.sleep(5000); out.write("hi，管道来了！".getBytes()); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125;&#125; 操作基本数据类型的流 用操作基本数据类型值的对象 DataInputStream 、DataOutputStream 1234567891011121314151617public class DataSteamDemo &#123; public static void main(String[] args) throws IOException &#123;// writeData(); readData(); &#125; public static void readData() throws IOException &#123; DataInputStream dis = new DataInputStream(new FileInputStream("data.txt")); String str = dis.readUTF(); System.out.println(str); &#125; public static void writeData() throws IOException &#123; DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.txt")); dos.writeUTF("你好"); dos.close(); &#125;&#125; 操作数组的流 设备是内存的流对象。 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter StringReader StringWriter 1234567891011121314public class ByteArrayStreamDemo &#123; public static void main(String[] args) &#123; ByteArrayInputStream bis = new ByteArrayInputStream("abcedf".getBytes()); ByteArrayOutputStream bos = new ByteArrayOutputStream(); int ch = 0; while((ch=bis.read())!=-1)&#123; bos.write(ch); &#125; System.out.println(bos.toString()); &#125;&#125; 编码表常见编码表 ASCII： 美国标准信息交换码，用一个字节7位表示 ISO8859-1： 拉丁码表，用一个字节8位表示 GB2312： 中文编码表 GBK： 升级的中文编码表 Unicode： 国际标准码，融合多种文字（均用两字节表示） UTF-8： 国标码（最多三个字节表示一个字符） 简单编码解码123456789101112131415161718public static void encodeDemo(String str) throws UnsupportedEncodingException &#123; //编码 byte[] buf = str.getBytes("UTF-8"); printBytes(buf); //解码 String s1 = new String(buf,"UTF-8"); System.out.println("s1="+s1);&#125;private static void printBytes(byte[] buf) &#123; for(byte b : buf)&#123; System.out.print(b +" "); &#125;&#125; 问题1 如果编码的时候是 ” GBK“， 解码的时候是 ”iso8859-1“ 怎么解决 12345678910111213141516public static void main(String[] args) throws UnsupportedEncodingException &#123; String str = "谢谢"; encodeDemo(str); &#125;public static void encodeDemo(String str) throws UnsupportedEncodingException &#123; byte[] buf = str.getBytes("gbk"); String s1 = new String(buf,"iso8859-1"); System.out.println("s1="+s1); //用iso8859-1编码 byte[] buf2 = s1.getBytes("iso8859-1"); //用GBK解码 String s2 = new String(buf2,"GBK"); System.out.println("s2="+s2); &#125; 如果编码用GBK，解码用UTF-8，会出现什么问题 1234567891011121314151617181920public static void main(String[] args) throws UnsupportedEncodingException &#123; String str1 = "你好"; String str2 = "哈哈"; String str3 = "谢谢"; encodeDemo(str1); encodeDemo(str2); encodeDemo(str3); &#125;public static void encodeDemo(String str) throws UnsupportedEncodingException &#123; byte[] buf = str.getBytes("gbk"); String s1 = new String(buf,"utf-8"); System.out.println("s1="+s1); //用iso8859-1编码 byte[] buf2 = s1.getBytes("utf-8"); //用GBK解码 String s2 = new String(buf2,"GBK"); System.out.println("s2="+s2); &#125; 运行一下上面的代码 看看结果是什么样的？ 只有谢谢成功转回原样，其他的都是类似这样的–&gt;”锟斤拷锟�“ 我们把printBytes的注释 解掉，发现 ”-17 -65 -67“ ，重复出现，这是什么原因呢？ 因为”你好“的字节在经过 UTF-8 转义时出现了错误 ，没有能够成功识别， 返回的不是“你好”的字节，而是UTF-8特有的 未知字符 的字节 联通问题 切换到桌面，新建一个文本文档，在里面输入”联通“ 这两个字，保存后关闭，重新打开，发现什么问题？ 是否发现不是联通两个字，变成了未知字符那？ 123456789public static void main(String[] args) throws UnsupportedEncodingException &#123; String str = "联通"; byte[] buf = str.getBytes("gbk"); for (byte b : buf)&#123; System.out.print(b+" "); //System.out.println(Integer.toBinaryString(b)); System.out.println(Integer.toBinaryString(b&amp;255)); &#125; &#125; 我们试试用GBK解码”联通“，先看一下他的字节，没有发现什么，再转为二进制取后八位 123411000001101010101100110110101000 开头分别是110，10 这就导致它被记事本解码时，误以为是UTF-8，于是解码后出现未知字符 练习 在java中，字符串“abcd”与字符串“ab你好”的长度是一样，都是四个字符。 但对应的字节数不同，一个汉字占两个字节。 定义一个方法，按照最大的字节数来取子串 如：对于“ab你好”，如果取三个字节，那么子串就是ab与“你”字的半个， 那么半个就要舍弃。如果去四个字节就是“ab你”，取五个字节还是“ab你”. 思路： 我们先从GBK编码的入手，字母是一个字节，汉字是两个字节 汉字两个字节开头都是1，所以为负数，如“你”字，-60 -29 以”ab你好“为例，97 98 -60 -29 -70 -61 一次取5字节，进行判断 指针指向-70，为负数，指针前移，若指向负数，计数器每次加一，直到指针指向正数 如果计数器值%2为0，可以全部输出 如果%2为1，输出（截取字节数-1）个字节（取5字节就是这种情况） 12345678910111213141516171819202122232425public static void main(String[] args) throws IOException &#123; String str = "ab你好cd谢谢"; int len = str.getBytes("GBK").length; for(int x=0; x&lt;len; x++)&#123; System.out.println("截取"+(x+1)+"个字节结果是："+cutStringByByte(str, x+1)); &#125;&#125;public static String cutStringByByte(String str,int len) throws IOException&#123; byte[] buf = str.getBytes("gbk"); int count = 0; for(int x=len-1; x&gt;=0; x--)&#123; if(buf[x]&lt;0) count++; else break; &#125; if(count%2==0) return new String(buf,0,len,"gbk"); else return new String(buf,0,len-1,"gbk");&#125; UTF-8 1234567891011121314151617181920public static String cutStringByU8Byte(String str, int len) throws IOException &#123; byte[] buf = str.getBytes("utf-8"); int count = 0; for(int x=len-1; x&gt;=0; x--)&#123; if(buf[x]&lt;0) count++; else break; &#125; if(count%3==0) return new String(buf,0,len,"utf-8"); else if(count%3==1) return new String(buf,0,len-1,"utf-8"); else return new String(buf,0,len-2,"utf-8"); &#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-其余对象API]]></title>
    <url>%2F2018%2F05%2F15%2FJava-%E5%85%B6%E4%BD%99%E5%AF%B9%E8%B1%A1API%2F</url>
    <content type="text"><![CDATA[System类 System：类中的方法和属性都是静态的。 常用方法currentTimeMillis 获取当前时间的毫秒值。 1public static long currentTimeMillis(); 与1970.1.1午夜时间的差 Properties 获取系统的属性信息，并存储到了Properties集合中。 properties集合中存储都是String类型的键和值。 最好使用它自己的存储和取出的方法来完成元素的操作。 12345678910111213public static void demo_1()&#123; Properties prop = System.getProperties(); Set&lt;String&gt; nameSet = prop.stringPropertyNames(); for(String name : nameSet)&#123; String value = prop.getProperty(name); System.out.println(name+"::"+value); &#125;&#125; 在linux、windows上换行符号是不一样的 123456//如果这样写的话，这个换行符在哪个系统中都不会出问题System.out.println(System.getProperty("hello"+"line_separator"+"world");//如果多次调用太麻烦，就可以将他在文件中用final定义private static final String LINE_SEPARATOR = System.getProperty("line.separator");System.out.println("hello"+LINE_SEPARATOR+" world"); Runtime类 Runtime：没有构造方法摘要，说明该类不可以创建对象。 又发现还有非静态的方法。说明该类应该提供静态的返回该类对象的方法 而且只有一个，说明Runtime类使用了单例设计模式。 1234567891011public static void main(String[] args) throws IOException, InterruptedException &#123; Runtime r = Runtime.getRuntime();// execute: 执行。 xxx.exe Process p = r.exec("notepad.exe");// r.exec("D:\\abc\\asd\\xxxx.exe"); Thread.sleep(5000); //延迟 p.destroy(); //杀死进程，只能杀掉他开启的&#125; Math类 Math：提供了操作数学运算的方法。都是静态的 常用的方法： ceil()：返回大于参数的最小整数。（如18.6 返回19） floor()：返回小于参数的最大整数。（如18.6 返回18） round()：返回四舍五入的整数。 （如18.6 返回19） pow(a,b)：a的b次方。 random()：返回大于0.0且小于1.0的一个伪随机数 12345678910111213for (int i = 0; i &lt; 10; i++) &#123; double d1 = Math.ceil(Math.random()*10); //返回 1 到 10 的数值 double d2 = Math.ceil(Math.random()*10); //返回 0 到 9 的数值 double d3 = (int)(Math.random()*10+1); //返回 1 到 10 的数值 System.out.println(d1);&#125;//Random也有自己的对象Random r = new Random();for (int i = 0; i &lt; 10; i++) &#123; double d4 = (int)(r.nextDouble()*6+1); int d5 = r.nextInt(6); //限定数值大于0 小于6 System.out.println(d5);&#125; Date类 月份：0–11 （代表12个月） 日期对象、毫秒值之间的转换 毫秒值–&gt;日期对象 ： 1，通过Date对象的构造方法 new Date(timeMillis); 2，还可以通过setTime设置。 因为可以通过Date对象的方法对该日期中的各个字段(年月日等)进行操作。 日期对象–&gt;毫秒值： 2，getTime方法。 因为可以通过具体的数值进行运算。 123System.out.println(System.currentTimeMillis());Date d = new Date(1526459420372L); //因为数值太大，所以加上LSystem.out.println(d); 将日期对象进行格式化 将日期对象–&gt;日期格式的字符串 使用的是DateFormat类中的format方法 12345678910111213141516public static void methodDemo() &#123; Date date = new Date(); //获取日期格式对象。具体着默认的风格。 FULL LONG等可以指定风格。 DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.LONG); dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG,DateFormat.LONG);// System.out.println(dateFormat); //如果风格是自定义的如何解决呢？ dateFormat = new SimpleDateFormat("yyyy--MM--dd"); String str_date = dateFormat.format(date); System.out.println(str_date);&#125; 将日期格式的字符串–&gt;日期对象 使用的是Date Format类中的parse()方法。 12345678910111213public static void methodDemo_3() throws ParseException &#123; String str_date1 = "2018年5月16日"; DateFormat dateFormat1 = DateFormat.getDateInstance(DateFormat.LONG); String str_date2 = "2018---6---6"; DateFormat dateFormat2 = new SimpleDateFormat("yyyy---MM---dd"); Date date1 = dateFormat1.parse(str_date1); Date date2 = dateFormat2.parse(str_date2); System.out.println(date1); System.out.println(date2);&#125; 练习 计算2018-04-11与2018-05-16中间相差多少天 思路： 日期字符串转日期对象 日期对象转毫秒值 毫秒值相减，取绝对值 将结果转换成天数 1234567891011121314151617181920public class DateTest &#123; public static void main(String[] args) throws ParseException &#123; String str1 = "2018-04-11"; String str2 = "2018-05-16"; int day = datetest(str1, str2); System.out.println(day); &#125; public static int datetest(String str1,String str2) throws ParseException &#123; DateFormat dateFormat = DateFormat.getDateInstance(); Date date1 = dateFormat.parse(str1); Date date2 = dateFormat.parse(str2); long date = Math.abs(date2.getTime()-date1.getTime()); int day = getDay(date); return day; &#125; public static int getDay(long date)&#123; int day = (int)(date/1000/60/60/24); return day; &#125;&#125; calendar类 Date类中已经过时的类，都是在calendar中被替换 1234567891011121314public static void showDate(Calendar c) &#123; int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH)+1; //表示月份的数字是0-11 int day = c.get(Calendar.DAY_OF_MONTH); int week = c.get(Calendar.DAY_OF_WEEK); //这里的周日为美国的周一 System.out.println(year+"年"+month+"月"+day+"日"+getWeek(week));&#125;public static String getWeek(int i) &#123; String[] weeks = &#123;"","星期日","星期一","星期二","星期三","星期四","星期五","星期六"&#125;; return weeks[i];&#125; calendar中的add方法，偏移日期 123Calendar c = Calendar.getInstance();c.set(2018, 11, 20);c.add(Calendar.MONTH, 2);]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-集合框架]]></title>
    <url>%2F2018%2F05%2F10%2FJava-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[概述 集合类的由来： 对象用于封装特有数据，对象多了需要存储，如果对象的个数不确定。就使用集合容器进行存储。 集合特点： 用于存储对象的容器。 集合的长度是可变的。 集合中不可以存储基本数据类型值。 体系 集合容器因为内部的数据结构不同，有多种具体容器。不断的向上抽取，就形成了集合框架。 框架的顶层就是Collection接口： List：有序(存入和取出的顺序一致),元素都有索引(角标)，元素可以重复。 Set：元素不能重复,无序。 功能(Collection接口) 添加 12boolean add(E e);boolean addAll(Collection coll); 判断 123boolean remove(object obj):boolean removeAll(Collection coll);void clear(); 删除 123boolean contains(object obj):boolean containsAll(Colllection coll);boolean isEmpty();//判断集合中是否有元素。 获取 123456789int size():Iterator iterator():取出元素的方式：迭代器。该对象必须依赖于具体容器，因为每一个容器的数据结构都不同。所以该迭代器对象是在容器中进行内部实现的。对于使用容器者而言，具体的实现不重要，只要通过容器获取到该实现的迭代器的对象即可，也就是iterator方法。Iterator接口就是对所有的Collection容器进行元素取出的公共接口。其实就是抓娃娃游戏机中的夹子！ 其他 12boolean retainAll(Collection coll);//取交集。Object[] toArray();//将集合转成数组。 ​ 方法演示 展示一下如何使用这些方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class CollectionDemo &#123; /** * @param args */ public static void main(String[] args) &#123; Collection coll = new ArrayList(); // show(coll); Collection c1 = new ArrayList(); Collection c2 = new ArrayList(); show(c1,c2); &#125; public static void show(Collection coll)&#123; //1,添加元素。add. coll.add("abc1"); coll.add("abc2"); coll.add("abc3"); System.out.println(coll); //2，删除元素。remove coll.remove("abc2");//会改变集合的长度 //清空集合. //coll.clear(); System.out.println(coll.contains("abc3")); System.out.println(coll); &#125; public static void show(Collection c1,Collection c2)&#123; //给c1添加元素。 c1.add("abc1"); c1.add("abc2"); c1.add("abc3"); c1.add("abc4"); //给c2添加元素。 c2.add("abc1"); c2.add("abc2"); c2.add("abc3"); c2.add("abc4"); c2.add("abc5"); System.out.println("c1:"+c1); System.out.println("c2:"+c2); //演示addAll// c1.addAll(c2);//将c2中的元素添加到c1中。 //演示removeAll// boolean b = c1.removeAll(c2);//将两个集合中的相同元素从调用removeAll的集合中删除。// System.out.println("removeAll:"+b); //演示containsAll// boolean b = c1.containsAll(c2);// System.out.println("containsAll:"+b); //演示retainAll boolean b = c1.retainAll(c2);//取交集，保留和指定的集合相同的元素，而删除不同的元素。 //和removeAll功能相反 。 System.out.println("retainAll:"+b); System.out.println("c1:"+c1); &#125; &#125; ​ 迭代器 演示迭代器方法： 1234567891011121314151617181920212223public static void main(String[] args) &#123; Collection coll = new ArrayList(); coll.add("abc1"); coll.add("abc2"); coll.add("abc3"); coll.add("abc4"); // System.out.println(coll); // 使用了Collection中的iterator()方法。 调用集合中的迭代器方法，是为了获取集合中的迭代器对象。// Iterator it = coll.iterator(); // while(it.hasNext())&#123;// System.out.println(it.next());// &#125; //这样写也可以 for(Iterator it = coll.iterator(); it.hasNext(); )&#123; System.out.println(it.next()); &#125; &#125;&#125; 迭代器图解 List List：有序(存入和取出的顺序一致),元素都有索引(角标)，元素可以重复。 特有的常见方法：有一个共性特点就是都可以操作角标。 1234567891011121314151，添加 void add(index,element); void add(index,collection);2，删除； Object remove(index):3，修改： Object set(index,element);4，获取： Object get(index); int indexOf(object); int lastIndexOf(object); List subList(from,to); list集合是可以完成对元素的增删改查。 ListIterator 在迭代器过程中，不要使用集合操作元素，容易出现异常。 否则会报错（java.util.ConcurrentModificationException) 可以使用Iterator接口的子接口ListIterator来完成在迭代中对元素进行更多的操作。 它可以实现在迭代过程中完成对元素的增删改查。 注意：只有list集合具备该迭代功能 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; List list = new ArrayList(); list.add("abc1"); list.add("abc2"); list.add("abc3"); System.out.println("list:"+list); ListIterator it = list.listIterator(); while(it.hasNext())&#123; Object obj = it.next(); if(obj.equals("abc2"))&#123; it.set("abc9"); &#125; &#125; System.out.println("hasNext:"+it.hasNext()); //判断是否有上一个数据 System.out.println("hasPrevious:"+it.hasPrevious()); //反向迭代数据 while(it.hasPrevious())&#123; System.out.println("previous:"+it.previous()); &#125; System.out.println("list:"+list);&#125; List常用子类特点 Vector：内部是数组数据结构，是同步的。增删，查询都很慢！ ArrayList：内部是数组数据结构，是不同步的。替代了Vector。查询的速度快。 LinkedList：内部是链表数据结构，是不同步的。增删元素的速度很快。 Vector 的Enumeration方法和迭代器功能相同，但名字过长 LinkedList jdk1.6的方法更新 1234567891011getFirst();.//获取但不移除，如果链表为空，抛出NoSuchElementException.getLast();JDK1.6peekFirst();//获取但不移除，如果链表为空，返回null.peekLast():removeFirst();//获取并移除，如果链表为空，抛出NoSuchElementException.removeLast();JDK1.6pollFirst();//获取并移除，如果链表为空，返回null.pollLast(); 存储自定义对象12345678910111213141516171819202122public class ArrayListTest &#123; public static void main(String[] args) &#123; Person p1 = new Person("lisi1",21); ArrayList al = new ArrayList(); al.add(p1); al.add(new Person("lisi2",22)); al.add(new Person("lisi3",23)); al.add(new Person("lisi4",24)); Iterator it = al.iterator(); while(it.hasNext())&#123; //在这里进行向下转型，以使用子类特有方法 Person p = (Person) it.next(); System.out.println(p.getName()+"--"+p.getAge()); &#125; &#125; &#125; ​ 链表练习 用链表简单模拟一个堆栈及队列的输入输出过程 123456789101112131415161718192021222324252627282930313233import java.util.Iterator;import java.util.LinkedList;public class LinkedListDemo &#123; public static void main(String[] args) &#123; LinkedList link = new LinkedList(); link.addFirst("abc1"); link.addFirst("abc2"); link.addFirst("abc3"); link.addFirst("abc4");// System.out.println(link);// System.out.println(link.getFirst());//获取第一个但不删除。// System.out.println(link.getFirst()); // System.out.println(link.removeFirst());//获取元素但是会删除。// System.out.println(link.removeFirst()); while(!link.isEmpty())&#123; System.out.println(link.removeLast()); &#125; System.out.println(link);// Iterator it = link.iterator();// while(it.hasNext())&#123;// System.out.println(it.next());// &#125; &#125;&#125; Set Set:元素不可以重复，是无序。Set接口中的方法和Collection一致。 HashSet HashSet: 内部数据结构是哈希表 ，是不同步的。 如何保证该集合的元素唯一性呢？ 是通过对象的hashCode和equals方法来完成对象唯一性的！ 如果对象的hashCode值不同，那么不用判断equals方法，就直接存储到哈希表中。 如果对象的hashCode值相同，那么要再次判断对象的equals方法是否为true。 如果为true，视为相同元素，不存。如果为false，那么视为不同元素，就进行存储。 记住：如果元素要存储到HashSet集合中，必须覆盖hashCode方法和equals方法。一般情况下，如果定义的类会产生很多对象，比如人，学生，书，通常都需要覆盖equals，hashCode方法。建立对象判断是否相同的依据。 12345678910111213141516//Person类有name，年龄//重写hashCode，equalspublic int hashCode() &#123; return name.hashCode()+age*27; return 100;&#125;public boolean equals(Object obj) &#123; //判断是否是同一个对象 if(this == obj) return true; //判断是否属于Person类 if(!(obj instanceof Person)) throw new ClassCastException("类型错误"); Person p = (Person)obj; return this.name.equals(p.name) &amp;&amp; this.age == p.age;&#125; 练习 将Person类中去除相同元素 1234567891011121314151617181920//前提：Person中public static ArrayList getSingleElement(ArrayList al) &#123; //1,定义一个临时容器。 ArrayList temp = new ArrayList(); //2,迭代al集合。 Iterator it = al.iterator(); while(it.hasNext())&#123; Object obj = it.next(); //3,判断被迭代到的元素是否在临时容器存在。 if(!temp.contains(obj))&#123; temp.add(obj); &#125; &#125; return temp;&#125; LinkedHashSet 与HashSet区别就是HashSet无序，LinkedHashSet有序， TreeSet TreeSet可以对Set集合中的元素进行排序。是不同步的。 判断元素唯一性的方式：就是根据比较方法的返回结果是否是0，是0，就是相同元素，不存。 TreeSet对元素进行排序的方式一： 让元素自身具备比较功能，就需要实现Comparable接口。覆盖compareTo方法。 12345678910111213141516171819//Person中的方法public int compareTo(Object o) &#123; //向下转型前最好进行健壮性增强 Person p = (Person)o; int temp = this.age-p.age; return temp==0?this.name.compareTo(p.name):temp; /* if(this.age&gt;p.age) return 1; if(this.age&lt;p.age) return -1; else&#123; return this.name.compareTo(p.name); &#125; */&#125; 如果不要按照对象中具备的自然顺序进行排序。如果对象中不具备自然顺序。怎么办？ 可以使用TreeSet集合第二种排序方式二： 让集合自身具备比较功能，定义一个类实现Comparator接口，覆盖compare方法。 将该类对象作为参数传递给TreeSet集合的构造函数。 12345678910111213141516/** * 创建了一个根据Person类的name进行排序的比较器。 */public class ComparatorByName implements Comparator &#123; @Override public int compare(Object o1, Object o2) &#123; Person p1 = (Person)o1; Person p2 = (Person)o2; int temp = p1.getName().compareTo(p2.getName()); return temp==0?p1.getAge()-p2.getAge(): temp; //return 1; 这样写的话，注销前面的就意味着按输入顺序来 &#125;&#125; 内部实现用的二叉树，打个比方，返回正数为右子树，负数为左子树 泛型 jdk1.5出现的安全机制。 好处： 1、将运行时期的问题ClassCastException转到了编译时期。 2、避免了强制转换的麻烦。 &lt;&gt;:什么时候用？ 当操作的引用数据类型不确定的时候。就使用&lt;&gt;。将要操作的引用数据类型传入即可. 其实&lt;&gt;就是一个用于接收具体引用数据类型的参数范围。 在程序中，只要用到了带有&lt;&gt;的类或者接口，就要明确传入的具体引用数据类型 。 泛型技术是给编译器使用的技术,用于编译时期。确保了类型的安全。 擦除补偿 运行时，会将泛型去掉，生成的class文件中是不带泛型的,这个称为泛型的擦除。 为什么擦除呢？ 因为为了兼容运行的类加载器。 泛型的补偿： 在运行时，通过获取元素的类型进行转换动作。不用使用者在强制转换了。 泛型类 在jdk1.5后，使用泛型来接收类中要操作的引用数据类型。 泛型类。什么时候用？ 当类中的操作的引用数据类型不确定的时候，就使用泛型来表示。 123456789101112//主类调用此类时，需为其赋上数据类型public class Tool&lt;QQ&gt;&#123; private QQ q; public QQ getObject() &#123; return q; &#125; public void setObject(QQ object) &#123; this.q = object; &#125;&#125; 泛型方法 泛型方法的使用 1234567891011121314151617181920212223242526272829303132public class Tool&lt;QQ&gt;&#123; private QQ q; public QQ getObject() &#123; return q; &#125; public void setObject(QQ object) &#123; this.q = object; &#125; /** * 将泛型定义在方法上。 * @param str */ public &lt;W&gt; void show(W str)&#123; System.out.println("show : "+str.toString()); &#125; public void print(QQ str)&#123; System.out.println("print : "+str); &#125; /** * 当方法静态时，不能访问类上定义的泛型。如果静态方法使用泛型， * 只能将泛型定义在方法上。 * @param obj */ public static &lt;Y&gt; void method(Y obj)&#123; System.out.println("method:"+obj); &#125;&#125; 通配符 泛型的通配符：? 未知类型。 1234567891011121314151617181920212223public static void main(String[] args) &#123; ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;(); al.add(&quot;abc&quot;); al.add(&quot;hehe&quot;); ArrayList&lt;Integer&gt; al2 = new ArrayList&lt;Integer&gt;(); al2.add(5); al2.add(67); printCollection(al); printCollection(al2);&#125;/*** 迭代并打印集合中元素。* @param al*/public static void printCollection(Collection&lt;?&gt; al) &#123; Iterator&lt;?&gt; it = al.iterator(); while(it.hasNext())&#123; System.out.println(it.next().toString()); &#125;&#125; 泛型的限定 上限 ? extends E 接收E类型或者E的子类型对象 一般存储对象的时候用。比如 添加元素 addAll. 下限 ? super E 接收E类型或者E的父类型对象。 一般取出对象的时候用。比如比较器。 123456789public static void printCollection(Collection&lt;? extends Person&gt; al) &#123; Iterator&lt;? extends Person&gt; it = al.iterator(); while(it.hasNext())&#123; Person p = it.next(); System.out.println(p.getName()+":"+p.getAge()); &#125;&#125; 什么时候用上限？ 一般在存储元素的时候都是用上限，因为这样取出都是按照上限类型来运算的。不会出现类型安全隐患。 什么时候用下限呢？ 通常对集合中的元素进行取出操作时，可以使用下限。如TreeSet的比较器 集合选择技巧需要唯一吗？？ 需要：Set 需要制定顺序： 需要： TreeSet 不需要：HashSet 但是想要一个和存储一致的顺序(有序):LinkedHashSet 不需要：List 需要频繁增删吗？ 需要：LinkedList 不需要：ArrayList 如何记录各容器的结构和所属体系呢？？ List ArrayList LinkedList Set HashSet TreeSet 后缀名就是该集合所属的体系，前缀名就是该集合的数据结构。看到array：就要想到数组，就要想到查询快，有角标. 看到Link：就要想到链表，就要想到增删快，就要想要 add get remove方法及头插尾插法 看到hash：就要想到哈希表，就要想到唯一性，就要想到元素需要覆盖hashCode方法和equals方法。 看到tree：就要想到二叉树，就要想要排序，就要想到两个接口Comparable，Comparator 。 而且通常这些常用的集合容器都是不同步的。 Map 一次添加一对元素。Collection 一次添加一个元素。 Map也称为双列集合，Collection集合称为单列集合。 其实map集合中存储的就是键值对。 map集合中必须保证键的唯一性。 常用方法123456789101112131415161，添加。 value put(key,value):返回前一个和key关联的值，如果没有返回null.2，删除。 void clear():清空map集合。 value remove(key):根据指定的key删除这个键值对。 3，判断。 boolean containsKey(key): boolean containsValue(value): boolean isEmpty();4，获取。 value get(key):通过键获取值，如果没有该键返回null。 当然可以通过返回null，来判断是否包含指定键。 int size(): 获取键值对的个数。 重点方法 取出map中所有元素 12345678910111213//取出map中的所有元素。//原理，通过keySet方法获取map中所有的键所在的Set集合，在通过Set的迭代器获取到每一个键，//在对每一个键通过map集合的get方法获取其对应的值即可。public static void keySetDemo(Map&lt;Integer,String&gt; map)&#123; Set&lt;Integer&gt; keySet = map.keySet(); Iterator&lt;Integer&gt; it = keySet.iterator(); while(it.hasNext())&#123; Integer key = it.next(); String value = map.get(key); System.out.println(key+":"+value);&#125; 取出map中所有元素–&gt;第二种方法 12345678910111213141516/** 通过Map转成set就可以迭代。* 找到了另一个方法。entrySet。* 该方法将键和值的映射关系作为对象存储到了Set集合中，而这个映射关系的类型就是Map.Entry类型(结婚证)*/public static void keySetDemo(Map&lt;Integer,String&gt; map)&#123; Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet(); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = entrySet.iterator(); while(it.hasNext())&#123; Map.Entry&lt;Integer, String&gt; me = it.next(); Integer key = me.getKey(); String value = me.getValue(); System.out.println(key+"::::"+value);&#125; 常用子类 Hashtable :内部结构是哈希表，是同步的。不允许null作为键，null作为值。 Properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合 。 |–HashMap : 内部结构是哈希表，不是同步的。允许null作为键，null作为值。 |–TreeMap : 内部结构是二叉树，不是同步的。可以对Map集合中的键进行排序。 ​ 练习一 将学生对象和学生的归属地通过键与值存储到map集合中。 123456789101112131415161718192021public static void hashMapMethod()&#123; HashMap&lt;Student,String&gt; hm = new HashMap&lt;Student,String&gt;(); hm.put(new Student("lisi",38),"北京"); hm.put(new Student("zhaoliu",24),"上海"); hm.put(new Student("xiaoqiang",31),"沈阳"); hm.put(new Student("wangcai",28),"大连"); //需要对student类进行hashCode、equals方法的重写 //否则相同的student也会被传进去 hm.put(new Student("zhaoliu",24),"铁岭"); //Set&lt;Student&gt; keySet = hm.keySet(); //Iterator&lt;Student&gt; it = keySet.iterator(); Iterator&lt;Student&gt; it = hm.keySet().iterator(); while(it.hasNext())&#123; Student key = it.next(); String value = hm.get(key); System.out.println(key.getName()+":"+key.getAge()+"---"+value); &#125;&#125; 如果需要进行排序的话，使用TreeMap 12345678910111213141516171819202122public static void treeMapDemo() &#123; TreeMap&lt;Student,String&gt; tm = new TreeMap&lt;Student,String&gt;(new ComparatorByName()); tm.put(new Student("lisi",38),"北京"); tm.put(new Student("zhaoliu",24),"上海"); tm.put(new Student("xiaoqiang",31),"沈阳"); tm.put(new Student("wangcai",28),"大连"); tm.put(new Student("zhaoliu",24),"铁岭"); Iterator&lt;Map.Entry&lt;Student, String&gt;&gt; it = tm.entrySet().iterator(); while(it.hasNext())&#123; Map.Entry&lt;Student,String&gt; me = it.next(); Student key = me.getKey(); String value = me.getValue(); System.out.println(key.getName()+":"+key.getAge()+"---"+value); &#125;&#125; 如果需要按输入顺序存储的话，LinkedHashMap 练习二12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* * 练习: * "fdgavcbsacdfs" 获取该字符串中，每一个字母出现的次数。 * 要求打印结果是：a(2)b(1)...; * 思路： * 对于结果的分析发现，字母和次数之间存在着映射的关系。而且这种关系很多。 * 很多就需要存储，能存储映射关系的容器有数组和Map集合。 * 关系一方式有序编号吗？没有！ * 那就是使用Map集合。 又发现可以保证唯一性的一方具备着顺序如 a b c ... * 所以可以使用TreeMap集合。 * * 这个集合最终应该存储的是字母和次数的对应关系。 * * 1，因为操作的是字符串中的字母，所以先将字符串变成字符数组。 * 2，遍历字符数组，用每一个字母作为键去查Map集合这个表。 * 如果该字母键不存在，就将该字母作为键 1作为值存储到map集合中。 * 如果该字母键存在，就将该字母键对应值取出并+1，在将该字母和+1后的值存储到map集合中， * 键相同值会覆盖。这样就记录住了该字母的次数. * 3，遍历结束，map集合就记录所有字母的出现的次数。 * */public class MapTest &#123; public static void main(String[] args) &#123; String str = "fdg+avAdc bs5dDa9c-dfs"; String s = getCharCount(str); System.out.println(s); &#125; public static String getCharCount(String str) &#123; //将字符串变成字符数组 char[] chs = str.toCharArray(); //定义map集合表。 Map&lt;Character,Integer&gt; map = new TreeMap&lt;Character,Integer&gt;(); for (int i = 0; i &lt; chs.length; i++) &#123; if(!(chs[i]&gt;='a' &amp;&amp; chs[i]&lt;='z' || chs[i]&gt;='A' &amp;&amp; chs[i]&lt;='Z'))// if(!(Character.toLowerCase(chs[i])&gt;='a' &amp;&amp; Character.toLowerCase(chs[i])&lt;='z')) continue; //将数组中的字母作为键去查map表。 Integer value = map.get(chs[i]); int count = 1; //判断值是否为null. if(value!=null)&#123; count = value+1; &#125; map.put(chs[i], count); &#125; return mapToString(map); &#125; private static String mapToString(Map&lt;Character, Integer&gt; map) &#123; StringBuilder sb = new StringBuilder(); //取出map中所有元素，更改格式存储 Iterator&lt;Character&gt; it = map.keySet().iterator(); while(it.hasNext())&#123; Character key = it.next(); Integer value = map.get(key); sb.append(key+"("+value+")"); &#125; return sb.toString(); &#125;&#125; 工具类Collections Collections是集合框架的工具类， 里面的方法都是静态的。 对list集合进行指定顺序的排列 12345//因为这个排序方法是基于比较器Comparable的，所以使用泛型//这样继承了Comparable的类及其父类都可以使用该方法public static &lt;T extends Comparable&lt;? super T&gt;&gt; void Sort(List&lt;T&gt; list)&#123; //代码&#125; 折半查找 binarySearch 最值 max 逆序 替换 replace 全部替换 fill 将list随机洗牌 shuffle 给非同步集合加锁 同步方法怎么实现的那？ 123456789101112131415161718192021222324252627282930class MyCollections&#123; public static List synList(List list)&#123; return new MyList(list); &#125; private class MyList implements List&#123; private List list; private static final Object lock = new Object(); MyList(List list)&#123; this.list = list; &#125; public boolean add(Object obj)&#123; synchronized(lock) &#123; return list.add(obj); &#125; &#125; public boolean remove(Object obj)&#123; synchronized(lock) &#123; return list.remove(obj); &#125; &#125; &#125;&#125; 那么该如何调用这个方法那？ 123List list = new ArrayList();//非同步的。list = MyCollections.synList(list);//返回一个同步的list. ArraystoString toString 经典实现 123456789101112131415//toString的经典实现。public static String myToString(int[] a)&#123; int iMax = a.length - 1; if (iMax == -1) return "[]"; StringBuilder b = new StringBuilder(); b.append('['); for (int i = 0; ; i++) &#123;//中间省略条件判断，提高了效率。 b.append(a[i]); if (i == iMax) return b.append(']').toString(); b.append(", "); &#125;&#125; asList asList 数组转 List 集合 12345678910111213141516171819202122232425262728293031323334353637public static void demo_1() &#123; /* * 重点：List asList(数组)将数组转成集合。 * * 好处：其实可以使用集合的方法操作数组中的元素。 * * 注意：数组的长度是固定的，所以对于集合的增删方法是不可以使用的 * 否则会发生UnsupportedOperationException * */ String[] arr = &#123;"abc","haha","xixi"&#125;; boolean b = myContains(arr, "xixi"); System.out.println("contains:"+b); List&lt;String&gt; list = Arrays.asList(arr); boolean b1 = list.contains("xixi"); System.out.println("list contaisn:="+b1); //list.add("hiahia");//UnsupportedOperationException System.out.println(list);&#125;public static void demo_2() &#123; /* * 如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储。 * * 如果数组中的元素是基本类型数值，那么会将该数组作为集合中的元素进行存储。 * */ int[] arr = &#123;31,11,51,61&#125;; List&lt;int[]&gt; list = Arrays.asList(arr); System.out.println(list);&#125; toArray 集合转数组 12345678910111213141516171819202122232425 /** 集合转成数组呢？* * 使用的就是Collection接口中的toArray方法。* * 集合转成数组：可以对集合中的元素操作的方法进行限定。不允许对其进行增删。*/ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc1"); list.add("abc2"); list.add("abc3"); /* * toArray方法需要传入一个指定类型的数组。 * 长度该如何定义呢？ * 如果长度小于集合的size，那么该方法会创建一个同类型并和集合相同size的数组。 * 如果长度大于集合的size，那么该方法就会使用指定的数组，存储集合中的元素，其他位置默认为null。 * * 所以建议，最后长度就指定为，集合的size。 */ String[] arr = list.toArray(new String[list.size()]); System.out.println(Arrays.toString(arr)); JDK5 特性ForEach概述123456foreach语句：格式：for(类型 变量 ：Collection集合|数组)&#123; &#125; 代码演示 1234567891011121314151617181920212223public static void main(String[] args)&#123; List&lt;String&gt; list =new ArrayList&lt;String&gt;(); list.add(&quot;abc1&quot;); list.add(&quot;abc2&quot;); list.add(&quot;abc3&quot;); for(String s : list)&#123; //简化书写。 System.out.println(s); &#125; int[] arr = &#123;3,1,5,7,4&#125;; for(int i : arr)&#123; System.out.println(i); &#125; // Iterator&lt;String&gt; it = list.iterator(); // while(it.hasNext())&#123;// System.out.println(it.next());// &#125;&#125; 传统for、高级for区别 传统for可以完成对语句执行很多次，因为可以定义控制循环的增量和条件。 高级for是一种简化形式。 它必须有被遍历的目标。该目标要是数组，要么是Collection单列集合。 对数数组的遍历如果仅仅是获取数组中的元素，可以使用高级for。 如果要对数组的角标进行操作建议使用传统for。 注意事项 可以使用高级for遍历map集合吗？ 不能直接用，但是可以将map转成单列的set，就可以用了。 12345678910111213141516171819Map&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(); map.put(3,"zhagsan"); map.put(1,"wangyi"); map.put(7,"wagnwu"); map.put(4,"zhagsansan"); for(Integer key : map.keySet())&#123; String value = map.get(key); System.out.println(key+"::"+value); &#125; for(Map.Entry&lt;Integer,String&gt; me : map.entrySet())&#123; Integer key = me.getKey(); String value = me.getValue(); System.out.println(key+":"+value); &#125; 函数可变参数 函数的可变参数。 其实就是一个数组，但是接收的是数组的元素。 自动将这些元素封装成数组。简化了调用者的书写。 注意：可变参数类型，必须定义在参数列表的结尾。 123456789101112131415161718192021222324public static void main(String[] args) &#123; int sum = newAdd(5,1,4,7,3); System.out.println("sum="+sum); int sum1 = newAdd(5,1,2,7,3,9,8,7,6); System.out.println("sum1="+sum1);&#125;public static int newAdd(int... arr)&#123; int sum = 0; for (int i = 0; i &lt; arr.length; i++) &#123; sum+=arr[i]; &#125; return sum;&#125;注意！！！！public static int newAdd1(int... arr,int a)&#123; 会报错，因为arr吃掉了所有值&#125;public static int newAdd2(int a，int... arr)&#123; 这样就没事了&#125; 静态导入12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collections;import java.util.List;import static java.util.Collections.*;//静态导入，其实导入的是类中的静态成员。//import static java.util.Collections.max;//静态导入，其实导入的是类中的静态成员。import static java.lang.System.*;public class StaticImportDemo &#123; /** * @param args * 注意：如果两个类中有相同名字的方法，并且都会被使用 * 一定不能静态导入，否则程序会不知道用哪个方法 */ public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("abc3"); list.add("abc7"); list.add("abc1"); out.println(list); //collection.sort(list); sort(list); //静态导入后可以简写 String max = max(list); System.out.println("max="+max); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-基本数据类型包装类]]></title>
    <url>%2F2018%2F05%2F10%2FJava-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[基本数据类型对象包装类 为了方便操作基本数据类型值，将其封装成了对象，在对象中定义了属性和行为丰富了该数据的操作 用于描述该对象的类就成为基本数据类型对象包装类 12345678byte Byteshort Shortint Integerlong Longfloat Floatdouble Doublechar Characterboolean Boolean 类型转换 该包装对象主要用于基本类型和字符串之间的转换 123456789基本类型---&gt;字符串 1、基本数据类型+"" 2、用String类中的静态方法 valueOf(基本类型数值) 3、用Integer方法的 valueOf(基本数据类型)字符串--&gt;基本类型 1、使用包装类中的静态方法 xxx parseXxx("xxx类型的字符串") 注意：只有Character类型没有该方法 2、如果字符串被Integer进行对象的封装，可使用另一个非静态的方法 intValue(); 将一个Integer对象转成基本数据类型值 进制转换 整数具备不同的进制体现 十进制–&gt;其他进制 1234Integer.toBinaryString(); //转换二进制Integer.toOctalString(); //转换八进制Integer.toHexString(); //转换十六进制Integer.toString(数，进制数); //转换任意进制 其他进制–&gt;十进制 1Integer.parseInt(&quot;需要转换的数据&quot;,进制数) 观察下面代码运行结果 1234567Integer a = new Integer("3");Integer b = new Integer(3);System.out.println(a==b); //falseSystem.out.println(a.equals(b)); //trueInteger c = new Integer(100);System.out.println(a.compareTo(c)); //-1System.out.println(c.compareTo(a)); //1 自动装拆箱 简化书写 1啊 注意事项 14 14分 练习 对一个字符串中的数值进行从小到大的排序 思路： 1，排序，我很熟。可是我只熟int。 2，如何获取到这个字符串中的这些需要排序的数值？？？发现这个字符串中其实都是空格来对数值进行分隔的。所以就想到用字符串对象的切割方法将大串变成多个小串。 3，数值最终变成小字符串，怎么变成一个int数呢？？？字符串–&gt;基本类型 可以使用包装类。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class WrapperTest &#123; private static final String SPACE_SEPARATOR = " "; public static void main(String[] args) &#123; String numStr = "20 78 9 -7 88 36 29"; System.out.println(numStr); numStr = sortStringNumber(numStr); System.out.println(numStr); &#125; public static String sortStringNumber(String numStr) &#123; //1,将字符串变成字符串数组。 String[] str_arr = stringToArray(numStr); //2,将字符串数组变成int数组。 int[] num_arr = toIntArray(str_arr); //3,对int数组排序。 mySortArray(num_arr); //4,将排序后的int数组变成字符串。 String temp = arrayToString(num_arr); return temp; &#125; public static String arrayToString(int[] num_arr) &#123; StringBuilder sb = new StringBuilder(); for(int x = 0; x&lt;num_arr.length; x++)&#123; if(x!=num_arr.length-1) sb.append(num_arr[x]+SPACE_SEPARATOR); else sb.append(num_arr[x]); &#125; return sb.toString(); &#125; public static void mySortArray(int[] num_arr) &#123; Arrays.sort(num_arr); &#125; public static int[] toIntArray(String[] str_arr) &#123; int[] arr = new int[str_arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = Integer.parseInt(str_arr[i]); &#125; return arr; &#125; public static String[] stringToArray(String numStr) &#123; String[] str_arr = numStr.split(SPACE_SEPARATOR); return str_arr; &#125;&#125; ​]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-String及相关类]]></title>
    <url>%2F2018%2F05%2F08%2FJava-String%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[特点 字符串是一个初始化的对象 字符串一旦初始化就不可以被改变 12345678910111213//创建一个字符串对象在常量池中//池中没有就建立，有就使用String str = "abc";String str1 = "abc";System.out.println(str == str1); //true//str2 是在堆内存中创建的一个String对象//创建两个对象一个new一个字符串对象在堆内存中String str2 = new String("abc");System.out.println(str == str2); //falseSystem.out.println(str.equals(str2)); //true//String类中的equals方法复写了Object中的//其实就是比较字符串内容 构造函数12345678910111213String str = new String();//等价于 String str = "";//不等价于 String str = null; byte[] arr = &#123;97,66,67,68&#125;;String s1 = new String(arr);System.out.println("s1 = "+s1);//运行结果：s1 = aBCDchar[] chars = &#123;'q','w','e','r','t'&#125;;String s2 = new String(chars,1,3);System.out.println("s2 = "+s2);//运行结果：s2 = wer; 常见功能获取 获取字符串长度 1int length(); 根据位置获取字符 1char charAt(int index); 根据字符获取在字符串中第一次出现的位置 1234int indexOf(int ch);int indexOf(int ch,int fromIndex);//从指定位置查找int indexOf(String str);int indexOf(String str,int fromIndex); 根据字符获取在字符串中最后一次出现的位置 1234int lastIndexOf(int ch);int lastIndexOf(int ch,int fromIndex); //从指定位置反向搜索int lastIndexOf(String str);int lastIndexOf(String str,int fromIndex); 获取字符串的一部分，也叫子串 123注意：起始索引包括，结束索引不包括String substring(int beginIndex,int endIndex);String substring(int beginIndex);​ 转换 将字符串转换成字符串数组（字符串的切割） 1String[] split(String regex); 涉及正则表达式 将字符串转换成字符数组 1char[] toCharArray(); 将字符串转换成字节数组 12byte[] getBytes();注意：一个汉字占两个字节，且这两个字节的最高位都是1 将字符串的字母转成大小写 12String toUpperCase(); 转大写String toLowerCase(); 转小写 将字符串内容替换 12String replace(char oldch,char newch);String replace(String s1,String s2); 将字符串两端空格去除 1String trim(); 将字符串进行连接 1String concat(String); 判断 判断两个字符串内容是否相同 123boolean equals(Object obj);忽略大小写比较内容：boolean equalsIgnoreCase(String str); 字符串是否包含指定字符串 1boolean contains(String str); 字符串是否以指定字符串开头，或者结尾 12boolean startsWith(String);boolean endWith(String); ​ 比较 按字典顺序比较两个字符串 1compareTo(String); intern方法 返回字符串对象的规范化表示形式 12String s1 = new String("abc");String s2 = s1.intern(); ​ 练习题练习一 1、计算一个子串在整串中出现的次数 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Basic_1 &#123; public static void main(String[] args)&#123; String str = "nbaasdnbaanbanba"; String key = "nba"; //第一种方法会生成较多常量 int count = getKeyStringCount(str,key); //第二种方法较好 int count1 = getKeyStringCount_2(str,key ); System.out.println(count); System.out.println(count1); &#125; private static int getKeyStringCount_2(String str, String key) &#123; int count = 0; int index = 0; //从index处开始判断是否还含有子串 while((index = str.indexOf(key, index))!=-1)&#123; count++; //index加上刚才查找到的子串长度，从这里继续查 index = index + key.length(); &#125; return count; &#125; /** * 获取子串在整串中出现的个数 * @param str * @param key * @return */ private static int getKeyStringCount(String str, String key) &#123; //定义计数器 int count = 0; //记录变量key出现的位置 int index = 0; //循环判断是否还含有子串，有则加1 while((index = str.indexOf(key))!=-1) &#123; //将字符串切割掉刚才查找过的位置 str = str.substring(index+key.length()); count ++; &#125; return count; &#125;&#125; 练习二 2、模拟一个与trim功能一致的方法（去除字符串两边空白） 1234567891011121314151617181920public class Basic_4 &#123; public static void main(String[] args)&#123; String str = " as s "; System.out.println(str); str = myTrim(str); System.out.println(str); &#125; public static String myTrim(String str)&#123; int start = 0,end = str.length()-1; while (start&lt;=end &amp;&amp; str.charAt(start)==' ')&#123; start++; &#125; while (start&lt;=end &amp;&amp; str.charAt(end)==' ')&#123; end--; &#125; //注意：该方法结果包括起始索引，不包括结束索引 str = str.substring(start, end+1); return str; &#125;&#125; ​ StringBuffer类 StringBuffer：就是字符串缓冲区，用于存储数据的容器 可变数组原理：初始为16，超出后，长度翻倍至32，不够再增加 特点 1、长度可变的 2、可以存储不同类型数据 3、最终要转成字符串使用 4、可以对字符串修改 功能 1、添加 12StringBuffer append(data);StringBuffer insert(index,data); 2、删除 12StringBuffer delete(start,end);//删除头，不删除尾StringBuffer delete(index); //删除指定位置元素 3、查找 123char charAt(index);int indexOf(string);int lastOf(string); 4、修改 12StringBuffer replace(start,end,string);void setCharAt(index,chars); ​ StringBuilder类 JDK1.5后出现了功能和StringBuffer一模一样的对象，就是StringBuilder 不同的是： StringBuffer 是线程同步的，建议多线程使用 StringBuilder是线程不同步的，建议单线程使用，提高效率 JDK升级： 简化书写 增加效率 增加安全性 练习 将一个 int 数组转字符串 1234567891011public static String arrayToString(int[] arr)&#123; StringBuilder sb = new StringBuilder(); sb.append('['); for (int i = 0; i &lt; arr.length; i++) &#123; if(i!=arr.length-1) sb.append(arr[i]+','); else sb.append(arr[i]+']'); &#125; return sb.toString(); &#125; 针对本题，使用String和StringBuilder的区别？ 使用String每次变化都会产生一个新的字符串常量池中的一个成员 使用StringBuilder是不断的把字符串变成数组往容器里装]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-主题美化]]></title>
    <url>%2F2018%2F05%2F08%2FHexo-%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[博客搭建已经好久了，这段时间对next主题也根据个人的意愿进行了一些美化，就在这里记载下来 首页不显示全文 进入hexo博客项目的themes/next目录 打开_config.yml文件（主题配置文件） 搜索”auto_excerpt” 12345# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: false length: 150 将enable的值从false改为true，再 hexo g hexo d就可以了 增加搜索功能 安装 hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 编辑站点配置文件（hexo博客项目下的config_yml） 12345search: path: search.xml field: post format: html limit: 10000 博客里使用 Ctrl + F 进行搜索 添加顶部加载条 打开/themes/next/layout/_partials/head.swig文件，在maximum-scale=1”/&gt;后添加如下代码: 12&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 标签图标替换 将标签 # 更换为 修改模板 /themes/next/layout/_macro/post.swig12搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 鼠标点击小红心 将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。 找到 \themes\next\layout_layout.swing 文件， 在文件的后面， 标签之前 添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 链接文本设置为蓝色 将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。 找到文件 themes\next\source\css_custom\custom.styl ，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 访问量及阅读统计为NexT主题添加文章阅读量统计功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-多线程]]></title>
    <url>%2F2018%2F05%2F05%2FJava-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概述 进程：计算机中的程序关于某数据集合的一次运行活动，是系统进行资源分配和调度的基本单位。 线程：就是进程中的一个负责程序执行的控制单元（执行路径）。 一个进程中可以有多个执行路径，称之为多线程。 一个进程中至少要有一个线程 开启多个线程是为了同时运行多部分代码 每一个线程都有自己运行的内容，这个内容可以称为线程要执行的任务 利弊 多线程操作，可以让多个任务并行执行，a任务等待硬盘响应时，让b任务去用cpu，所以，多线程不能提高单任务的运行速度，但是可以提高多个可以并发的任务速度。 好处：解决多部分同时运行的问题 弊端：线程过多会导致效率的降低 JVM多线程分析 JVM启动时就启动了多个线程，至少有两个可以分析出来 1.执行main函数的线程 该线程的任务代码都定义在main函数中 2.负责垃圾回收的线程 创建线程创建方式一 继承 Thread 类 1、定义一个类继承 Thread 类 2、必须覆盖 Thread 类的 run 方法 3、直接创建 Thread 的子类对象创建线程 4、调用 start 方法开启线程并调用线程的任务 run 方法执行 12345678910111213141516171819202122232425262728293031323334/*创建线程的目的是开启一条执行路径，去运行指定的代码和其他代码同时运行而运行的代码就是这个执行路径的任务JVM创建的主线程的任务都定义在主函数中而自定义的线程，他的任务在哪儿？Thread类用于描述线程，线程是需要任务的，所以Thread类也对任务的描述这个任务就通过Thread类中的run方法来体现也就是说，run方法就是封装自定义线程运行任务的函数，run方法中定义就是线程要运行的任务代码*/public class Demo extends Thread&#123; private String name; public Demo(String name)&#123; this.name = name; &#125; public void run()&#123; show(); &#125; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.println(name+&quot;...i:&quot;+i); &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(&quot;小白&quot;); Demo b = new Demo(&quot;black&quot;); a.start(); b.start(); //a.run(); //b.run(); &#125;&#125; 在上述代码的结尾，调用run和start函数有什么区别？ 调用start函数是多线程的，调用run函数还是按顺序主线程进行的 线程名称 想要展示出当前运行对象线程名称需要使用Thread类的currentThread方法 123456789101112131415161718192021222324252627public class Demo extends Thread&#123; private String name; public Demo(String name)&#123; super(); this.name = name; //super(name); &#125; public void run()&#123; show(); &#125; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.print(name+&quot;...i:&quot;+i); System.out.println(&quot;ThreadName&quot;+Thread.currentThread().getName()); &#125; &#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(&quot;小白&quot;); Demo b = new Demo(&quot;black&quot;); a.start(); b.start(); System.out.println(&quot;here&quot;+&quot;...&quot;+Thread.currentThread().getName());// a.run();// b.run(); &#125;&#125; 运行后可以试着4.5行注释掉，6行解除注释试一下，发现可以自己给线程名称赋值了 图解 开启了多线程后，栈内存就和之前不一样了，以前面代码为示例 如果在上文倒数第三行加上一句代码“System.out.println(4/0);” 观察运行结果，发现main函数已经抛出异常终止了，其余两线程仍能正常进行 线程的状态 创建方式二 实现Runnable接口 1、定义类实现Runnable接口 2、覆盖接口中的run方法，将编程的任务代码封装到run方法中 3、通过Thread类创建线程对象，并将Runnable接口的子类对象作为Thread类的构造函数的参数进行传递 4、调用线程对象的start方法开启线程 第三步的原因 因为线程的任务都封装在Runnable接口子类对象的run方法中，所以要在线程对象创建时就必须明确要运行的任务 123456789101112131415161718192021222324public class Demo implements Runnable&#123; //准备扩展Demo类的功能，让其中的内容可以作为多线程执行 //通过接口的方式完成 private String name; public void show()&#123; for(int i=0; i&lt;10; i++) System.out.println(Thread.currentThread().getName()+&quot;...&quot;+i); &#125; @Override public void run() &#123; show(); &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args)&#123; Demo a = new Demo(); Demo b = new Demo(); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); System.out.println(&quot;here&quot;+&quot;...&quot;+Thread.currentThread().getName()); &#125;&#125; 方式二细节方式二优点 实现Runnable接口的好处 1、将线程的任务从线程的子类中分离出来，进行了单独的封装，按照面向对象的思想将任务封装成了对象 2、避免了Java单继承的局限性 所以创建线程的第二种方式比较常用 卖票示例 在火车站一共有100张票，4个窗口同时卖票，用多线程来描述 运行图中左侧代码后发现，并不是想象中的卖100张，而是变成了4*100张，可以选择将ticket类中的num值变成静态变量，但这不是最好的选择。 另外还有人说可以不在堆中创建那么多的对象，只创建一个对象，进行4次线程开启，这是不可取的，多次启动一个线程是非法的。 12345678910111213141516171819202122 class Ticket implements Runnable&#123; private int num = 100; public void run()&#123; while(true)&#123; if(num&gt;0) System.out.println(num--); &#125; &#125; &#125; class TicketDemo&#123; public static void main(String[] args)&#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 通过继承的方式创建没有达到我们的目的，于是就采用上述代码中接口的方式创建 线程安全隐患 以车站卖票为示例，如果当车票只剩一张时，t1进入临时堵塞状态，有执行资格不具备执行权，推给t2执行，t2也临时堵塞一下，继续往后推，然后假设t3，t4也是临时堵塞，那他们现在都具备执行资格，没有执行权，然后t1卖出一张票，票数为0，但是t2.3.4都已经进入循环，可以卖票，于是分别卖出了第0.-1.-2张票。这对于铁路局来说是不允许的，有安全隐患。 有人说为什么我运行很多次都没有出现这种错误那，因为这只是有一定可能发生的，为了看起来更清晰，可以人为的方式，使产生安全隐患概率增加 12345678910111213141516class Ticket implements Runnable&#123; private int num = 100; public void run()&#123; while(true)&#123; if(num&gt;0)&#123; try&#123; Thread.sleep(10); &#125;catch(InterruptedException)&#123; //解决异常代码 &#125; System.out.println(num--); &#125; &#125; &#125;&#125; &#125; 将ticket类改成这样，在运行主类，发现会出现之前所说的安全隐患 线程安全问题产生原因 1、多个线程在操作共享数据 2、操作共享数据的线程代码有多条 当一个线程在执行操作共享数据的多条代码过程中，其他线程参与了运算，就会导致线程安全问题的产生 解决思路（同步） 就是将多条操作共享数据的线程代码封装起来，当有线程在执行这些代码的时候，其他线程不可以参与运算的，必须要当前线程把这些代码都执行完毕后，其他线程才可以参与运算 在Java中用同步代码块就可以解决这个问题 1234同步代码块格式：synchronized(对象)&#123; 需要被同步的代码；&#125; 所以更改代码后变为这样 123456789101112131415161718class Ticket implements Runnable&#123; private int num = 100; Object obj = new Object(); public void run()&#123; while(true)&#123; synchronized(obj)&#123; if(num&gt;0)&#123; try&#123; Thread.sleep(10); &#125;catch(InterruptedException)&#123; //解决异常代码 &#125; System.out.println(num--); &#125; &#125; &#125; &#125; &#125; 这次再去运行一下发现不会有问题 这很像锁，可以比喻成火车上的卫生间，一个人进去后，门锁上，门上有提示“有人”，别人就进不来，只有里面的人出去才可以。 同步的好处：解决了线程的安全问题 同步的弊端：相对降低了效率，因为同步外的线程都会判断同步锁同步前提 同步的前提：同步中必须有多个线程并使用同一个锁 1234567891011 private int num = 100; public void run()&#123; Object obj = new Object(); //注意：上面这句代码的位置和之前不同 while(true)&#123; synchronized(obj)&#123; //代码 &#125; &#125; &#125;&#125; 运行上面的代码后发现并没有解决安全问题，是因为这样写相当于有四个锁，把二三行代码换位置即可 同步函数 需求：两个储户去银行存款，每次100，存三次 1234567891011121314151617181920212223242526272829303132333435public class Bank &#123; private int sum; //private Object obj = new Object(); public synchronized void add(int num) &#123; //synchronized(obj)&#123; sum = sum + num; try &#123; //延时，增加出错可能性 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(sum); //&#125; &#125;&#125;public class Cus implements Runnable&#123; private String name; public Bank b = new Bank(); @Override public void run() &#123; for (int i=0; i&lt;3; i++) &#123; b.add(100); &#125; &#125;&#125;public class BankDemo &#123; public static void main(String[] args)&#123; Cus a = new Cus(); Thread t1 = new Thread(a); Thread t2 = new Thread(a); t1.start(); t2.start(); &#125;&#125; “多个线程在操作共享数据（sum），操作共享数据代码有多条（不算trycatch两条）”这两点都符合，所以有线程安全隐患 像上面这种情况，可以使用同步代码块，不过还有更简洁的方式就是在函数中加上同步关键字 验证同步函数锁 同步函数锁固定是this，同步代码块锁是任意的对象 开发中建议使用同步代码块 下面是验证时的代码（以双线程卖票为示例）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Ticket implements Runnable &#123; private int num = 100; boolean flag = true; public void run() &#123; if (flag) &#123; while (true) &#123; synchronized (this) &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;..emmm..&quot; + num--); &#125; &#125; &#125; &#125; else &#123; while (true) show(); &#125; &#125; public synchronized void show() &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;......&quot; + num--); &#125; &#125;&#125;public class SynFunctionLockDemo &#123; public static void main(String[] args)&#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); t1.start(); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t.flag = false; t2.start(); &#125;&#125; 验证静态同步函数锁 静态的同步函数使用的锁是 该函数所属的字节码文件对象 可以用getClass方法获取，也可以用 当前类名.class 表示 验证的代码和上面的大同小异，将this改为this.getClass或者Ticket.class再试试 单例模式涉及的多线程问题安全隐患分析 会出现安全隐患的是懒汉式，也就是延迟加载单例模式 123456789public class Single2 &#123; private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null) s = new Single2(); return s; &#125;&#125; 仔细想一下，他符合了会出现隐患的两个因素，线程0在进行（s==null）判断后，进入临时堵塞状态，然后线程1进行null的判断，进入临时堵塞状态。这时线程0创建了s对象，返回s，线程1又创建了一个对象，现在就有两个对象，不能保证唯一了，这就出现大问题了。 解决方法 加同步代码块解决安全问题，外面再加一次判断是解决效率问题 12345678910111213public class Single2 &#123; private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null)&#123; synchronized(Single2.class)&#123; if(s==null) s = new Single2(); &#125; &#125; return s; &#125; &#125; 死锁 常见情景之一：同步的嵌套 12 run函数里拿着obj的锁想进this的锁，show函数里拿着this锁想进obj 简单死锁代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MyLock &#123; //写两个锁 public static final Object MyLockA = new Object(); public static final Object MyLockB = new Object();&#125;import static bxdDay_13.MyLock.MyLockA;import static bxdDay_13.MyLock.MyLockB;public class DeadLock implements Runnable&#123; public boolean flag; //有参构造函数，创建对象时附带flag状态 public DeadLock(boolean flag)&#123; this.flag = flag; &#125; @Override public void run() &#123; if (flag)&#123; synchronized (MyLockA)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;if LockA&quot;); synchronized (MyLockB)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;if LockB&quot;); &#125; &#125; &#125;else &#123; synchronized (MyLockB)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;else LockB&quot;); synchronized (MyLockA)&#123; System.out.println(Thread.currentThread().getName()+&quot; &quot;+&quot;else LockA&quot;); &#125; &#125; &#125; &#125;&#125;public class DeadLockTest &#123; public static void main(String[] args)&#123; DeadLock a = new DeadLock(true); DeadLock b = new DeadLock(false); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); &#125;&#125; 运行上面的代码，观察结果,线程1拿到了B锁，线程2拿到了A锁，他们都想继续，可是互不相让，死锁了 12Thread-1 else LockBThread-0 if LockA 如果试了多次都是没有成功死锁，那就在 if语句 及 else语句 后面各加一句 while(true) 线程间通信 多个线程在处理资源，但是任务却不同 同步前提：多个线程使用同一个锁 接下来用一个例子演示一下 需求：有一个资源库存放数据，一条线程在向里面输入，还有一条在向外输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//资源类public class Resource &#123; public String name; public String sex;&#125;//输入类public class Input implements Runnable &#123; Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; synchronized (r) &#123; if (x == 0) &#123; r.name = &quot;小白&quot;; r.sex = &quot;女女女&quot;; &#125; else &#123; r.name = &quot;black&quot;; r.sex = &quot;malemale&quot;; &#125; x = (++x) % 2; &#125; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; synchronized (r) &#123; System.out.println(&quot;name:&quot; + r.name + &quot;...&quot; + &quot;sex:&quot; + r.sex); &#125; &#125; &#125;&#125;//测试类public class Test &#123; public static void main(String[] args)&#123; //创建资源 Resource r = new Resource(); //创建任务 Input in = new Input(r); Output out = new Output(r); //创建线程，执行路径 Thread t1 = new Thread(in); Thread t2 = new Thread(out); //开启线程 t1.start(); t2.start(); &#125;&#125; 上面的代码中输入设置的是输入两个人名，需要注意的地方是，输入和输出类中加的锁是一样的，都是r，这个在测试类中，创建in、out对象时，要给他们传一样的参数。否则同步锁无用！ 但是这样的代码运行后还是不太好，因为输出的都是大片相同的人名，想让他们输入一个就输出一个，就需要使用线程的等待唤醒机制了。 等待唤醒机制 涉及方法 wait()：让线程处于冻结状态，被wait的线程会被存储到线程池中 notify()：唤醒线程池中的一个线程（任意） nitifyAll()：唤醒线程池中的所有线程 这些方法都必须定义在同步中，因为这些方法是用于操作线程状态的方法，必须要明确到底操作的是哪个锁上的线程 观察api文档后，为什么操作线程的方法wait、notify、notifyAll定义在Object类中那？ 因为这些方法是监视器的方法，监视器其实就是锁，锁可以是任意的对象，任意的对象调用的方式一定定义在Object类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//资源类public class Resource &#123; public String name; public String sex; public boolean flag = false;&#125;//输入类public class Input implements Runnable &#123; Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; synchronized (r) &#123; if (r.flag) &#123; try &#123; r.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (x == 0) &#123; r.name = &quot;小白&quot;; r.sex = &quot;女女女&quot;; &#125; else &#123; r.name = &quot;black&quot;; r.sex = &quot;malemale&quot;; &#125; r.flag = true; r.notify(); &#125; x = (++x) % 2; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; synchronized (r) &#123; if (!r.flag) &#123; try &#123; r.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;name:&quot; + r.name + &quot;...&quot; + &quot;sex:&quot; + r.sex); r.flag = false; r.notify(); &#125; &#125; &#125;&#125; 思路：输入数据之前判断一下是否有数据，如果有数据，控制输入的线程等待，先让控制输出的线程输出，输出数据后，将flag更改为false，意味着资源中数据为空，可以继续输入，然后再将控制输入的线程唤醒,自己（控制输出的线程）等待。这样就可以实现输入一个数据再输出一个数据了。 注意：输入输出的锁都是 r，等待唤醒中的线程池都是基于这个锁（也就是 r） 代码优化 上面的代码虽然最后实现了功能，但是封装性差,我们可以把输入，输出的方法定义在资源类中，在输入输出类中调用输入输出的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//资源类public class Resource &#123; private String name; private String sex; private boolean flag = false; //输入方法 public synchronized void set(String name,String sex)&#123; if (this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name; this.sex = sex; this.flag = true; this.notify(); &#125; //输出方法 public synchronized void out()&#123; if (!this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(&quot;name:&quot; + name + &quot;...&quot; + &quot;sex:&quot; + sex); this.flag = false; this.notify(); &#125;&#125;//输入类public class Input implements Runnable &#123; private Resource r; public Input(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; int x = 0; while(true) &#123; if (x == 0) &#123; r.set(&quot;小白&quot;,&quot;女女女&quot; ); &#125; else &#123; r.set(&quot;black&quot;, &quot;malemale&quot;); &#125; x = (++x) % 2; &#125; &#125;&#125;//输出类public class Output implements Runnable &#123; private Resource r; public Output(Resource r)&#123; this.r = r; &#125; @Override public void run() &#123; while (true) &#123; r.out(); &#125; &#125;&#125; 对共享资源修改的语句都写在了资源类中，可以给他们加同步锁，但是还是在方法中加上同步关键字看上去更简洁，这样他们加的锁还是同一个锁—&gt; this 。 生产者消费者问题 假设生产者生产产品，消费者消费产品，和上面进出资源的问题差不多 问题一 这里直接开始4个线程的，两个生产者，两个消费者，运行一下，会发现有错误，比如一个生产者生产完一件产品，消费者连着两次消费这一件产品。这类问题产生的原因是什么那？ t0、t1是生产者 t2、t3是消费者，让我们按照代码的顺序走一遍。 t0进行判断，生产产品（1），t0等待，t1进行判断，t1等待。t2进行判断，消费产品（1），t2等待，t3进行判断，t3等待。唤醒t0，t0没有进行判断，生产产品（2），t0等待。然后需要唤醒一个线程，但是这时线程池中有三个在等待，如果唤醒的是t1，t1没有进行判断直接生产产品（3），t1等待，唤醒t2，t2消费了产品（3），如果再唤醒t3，t3没有进行判断，就会再消费产品（3） 问题1产生原因：if判断标记，只有一次，会导致不该运行的线程运行了，出现了数据错误的情况 解决方法：将资源类中的输入输出方法的 if 判断改为 while 循环，这样就不会唤醒后跳过判断了，不过这样又会产生一个新的问题 问题二 问题2：4个线程都处在等待状态，没人去唤醒他们 产生原因：notify只能唤醒一个线程，如果本方唤醒本方，无意义，而且while+notify会导致死锁 解决办法：将资源类中的输入输出方法的唤醒改为全部唤醒（notifyAll）1234567891011121314151617181920212223242526272829303132333435//这里就只贴上资源类的代码了，其他类代码的写法和上面差不多//还需要有生产者类，消费者类 实现Runnable接口，和Test类//资源类public class Resource &#123; private String name; private int count = 1; private boolean flag = false; public synchronized void set(String name)&#123; while (this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); this.flag = true; this.notifyAll(); &#125; public synchronized void out()&#123; while (!this.flag) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); this.flag = false; this.notifyAll(); &#125;&#125; 问题三 解决了第二个问题后，已经不会报错了，但是还有些小弊端，使用notifyAll方法的时候会唤醒所有等待线程，但是如果唤醒了本方等待线程会降低效率，能不能只唤醒对方线程那？ 解决方法：使用jdk1.5新特性中的Lock Condition，可以创建多个监视器，该问题中，创建两个即可。关于Lock，Condition可以看该文章偏靠后的位置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;//资源类public class Resource &#123; private String name; private int count = 1; private boolean flag = false; public Lock lock = new ReentrantLock(); //通过已有的锁获取两组监视器，一组监视生产者，一组监视消费者 public Condition producer_con = lock.newCondition(); public Condition consumer_con = lock.newCondition(); public void set(String name)&#123; //生产者 t0 t1 lock.lock(); try &#123; while (flag) &#123; try &#123; //该生产者线程进入等待状态 producer_con.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; this.name = name + count; count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); flag = true; //唤醒随机一个消费者 consumer_con.signal(); &#125;finally &#123; //如果抛出异常，必须将关锁写在finally中 lock.unlock(); &#125; &#125; public void out()&#123; //消费者 t2 t3 lock.lock(); try &#123; while (!flag) &#123; try &#123; //该消费者进入等待状态 consumer_con.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); flag = false; //唤醒随机一个生产者 producer_con.signal(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; locks包Lock接口 java.util.concurrent.locks.Lock Lock替代了同步代码块或者同步函数，将同步的隐式锁操作变成显式锁操作，同时更为灵活，可以一个锁加上多个监视器。 方法： lock()：获取锁 unlock()：释放锁，通常需要定义在finally代码块中 1234567//同步代码块对于锁的操作是隐式的Object obj = new Object();void show()&#123; synchronized(obj)&#123; ...code... &#125;&#125; 12345678//同步和锁被封装成了对象，并将操作锁的隐式方式定义到了该对象中//将隐式动作变为了显式动作。Lock lock = new ReentrantLock();void show()&#123; lock.lock();//获取锁 ...code... lock.unlock();//释放锁&#125; 如果上面代码第六行位置会抛异常的话，一定要将释放锁写在finally里123456789Lock lock = new ReentrantLock(); void show()&#123; lock.lock();//获取锁 try&#123; ...code... &#125;finally&#123; lock.unlock();//释放锁 &#125; &#125; Condition接口 Condition接口出现替代Object中的wait notify notifyAll等方法，将他们单独进行了封装，变成了Condition监视器对象，可以与任意锁进行组合 方法： await()：等待 signal()：唤醒 signalAll()：全部唤醒 1234567891011121314151617//旧版功能演示//在没有Lock，Condition之前，生产消费者问题只能创建一个监视器Object obj = new Object();synchronzied(obj)&#123; obj.wait(); obj.notify(); obj.notifyAll();&#125;//新版功能演示Lock lock = new ReectrantLock();//生产者的锁Condition producter_con = lock.newCondition();//消费者的锁Condition consumer_con = lock.newCondition();producter_con.await();producter_con.signal();producter_con.signalAll(); 范例123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class BoundedBuffer &#123; final Lock lock = new ReentrantLock();//锁对象 final Condition notFull =lock.newCondition();//写线程条件 final Condition notEmpty = lock.newCondition();//读线程条件 final Object[] items = new Object[100];//缓存队列 //下面是操作上面数组的变量（前两个指针） int putptr/*写索引*/, takeptr/*读索引*/, count/*队列中存在的数据个数*/; public void put(Object x) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length)//如果队列满了 notFull.await();//阻塞写线程 items[putptr] = x;//赋值 if (++putptr == items.length) putptr = 0;//如果写索引写到队列的最后一个位置了，那么置为0 ++count;//个数++ notEmpty.signal();//唤醒读线程 &#125; finally &#123; lock.unlock(); &#125; &#125; public Object take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0)//如果队列为空 notEmpty.await();//阻塞读线程 Object x = items[takeptr];//取值 if (++takeptr == items.length) takeptr = 0;//如果读索引读到队列的最后一个位置了，那么置为0 --count;//个数-- notFull.signal();//唤醒写线程 return x; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 这是一个处于多线程工作环境下的缓存区，缓存区提供了两个方法，put和take，put是存数据，take是取数据，内部有个缓存队列，具体变量和方法说明见代码，这个缓存区类实现的功能：有多个线程往里面存数据和从里面取数据，其缓存队列(先进先出后进后出)能缓存的最大数值是100，多个线程间是互斥的，当缓存队列中存储的值达到100时，将写线程阻塞，并唤醒读线程，当缓存队列中存储的值为0时，将读线程阻塞，并唤醒写线程，这也是ArrayBlockingQueue的内部实现。 下面分析一下代码的执行过程： 1、一个写线程执行，调用put方法； 2、判断count是否为100，显然没有100； 3、继续执行，存入值； 4、判断当前写入的索引位置++后，是否和100相等，相等将写入索引值变为0，并将count+1； 5、仅唤醒读线程阻塞队列中的一个； 6、一个读线程执行，调用take方法； 7、…… 8、仅唤醒写线程阻塞队列中的一个 如果不用多个 Condition ，只有一个Condition或者使用的同步代码块的内容时，当存队列中已经存满，这个Lock不知道唤醒的是读线程还是写线程了，如果唤醒的是读线程，皆大欢喜，如果唤醒的是写线程，那么线程刚被唤醒，又被阻塞了，这时又去唤醒，这样就浪费了很多时间。 线程终止wait和sleep区别 wait可指定也可不指定时间，sleep必须指定时间 同步中时，对cpu的执行权和锁的处理不同 wait：释放执行权，释放锁 sleep：释放执行权，不释放锁 终止线程方式 停止线程： stop方法：不推荐使用 run方法结束 怎么控制线程中的任务结束那？ 任务中都会有循环结构，只要控制住循环就可以结束任务，控制循环通常就用定义标记来完成 123456789101112//通过在主函数中调用setFlag方法，即可终止线程public class StopThread implements Runnable&#123; private boolean flag = true; public void run()&#123; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; public void setFlag()&#123; flag = false; &#125;&#125; 但是使用这种方法也有一定的弊端，如果线程处于冻结状态无法读取标记，程序就不能停下来了 1234567891011//这样的程序无法终止public synchronized void run()&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; 可以使用interrupt()方法将线程从冻结状态强制恢复到运行状态中来，让线程具备cpu的执行资格，但是强制动作会发生InterruptedException异常，记得要处理 123456789101112131415161718192021222324252627282930313233343536373839public class StopThread implements Runnable&#123; private boolean flag = true; public synchronized void run()&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); //也可以选择在这里更改标记 //flag = false; &#125; while(flag)&#123; System.out.println(Thread.currentThread().getName()+&quot; run&quot;); &#125; &#125; public void setFlag()&#123; flag = false; &#125;&#125;public class StopThreadDemo &#123; public static void main(String[] args)&#123; StopThread s = new StopThread(); Thread t1 = new Thread(s); Thread t2 = new Thread(s); t1.start(); t2.start(); int num = 1; for(;;)&#123; if(++num == 50)&#123; //这里加上了interrupt方法 t1.interrupt(); t2.interrupt(); s.setFlag(); break; &#125; System.out.println(Thread.currentThread().getName()); &#125; &#125;&#125; 守护线程 setDaemon可以将线程变为守护线程（后台线程） 后台线程在运行时与前台线程无差别，前台线程终止时必须手动终止，如果前台线程都终止了，后台线程自动终止线程小方法join join方法也会抛出中断异常1234567891011121314//有线程t0、t1t0.start();t0.join();t1.start();System.out.println(&quot; &quot;);//运行结果一定是t0线程运行完，//运行main线程，再运行t1线程//情况2t0.start();t1.start();t0.join();System.out.println(&quot; &quot;); //运行结果：t0，t1互相抢占cpu，main等t0执行完再执行 线程优先值 可以给线程分配不同优先级的值，会让他们在执行中被执行几率增加 123456//t0为线程名t0.setPriority(Thread.MAX_PROIORITY);//为了方便，设置三个final值//MAX_PROIORITY = 10//MIN_PROIORITY = 0;//NORM_PROIORITY = 5; 两道多线程面试题 判断下面的程序是否能成功运行，如果不能，报错在哪一行 123456public class Test implements Runnable&#123; public void run(Thread t)&#123;&#125;&#125;//最后报错在第一行，第二行是子类的特有方法//在这个接口的实现类中没有覆盖run方法//报错解决：使用abstract修饰类或者覆盖run方法 判断下面程序，运行结果是什么？123456789101112131415public class ThreadTest &#123; public static void main(String[] main)&#123; new Thread(new Runnable() &#123; public void run() &#123; System.out.println(&quot;我是任务里面的 &quot;); &#125; &#125;)&#123; public void run() &#123; System.out.println(&quot;我是子类里面的 &quot;); &#125; &#125;.start(); &#125;&#125;//现在的运行结果是“我是子类里面的”//如果注释掉8.9.10行，结果是“我是任务里面的”]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-异常]]></title>
    <url>%2F2018%2F05%2F03%2FJava-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[概述 异常：运行时期发生的不正常情况 在java中用类的形式对不正常情况进行了描述和封装对象 描述不正常的情况的类，被称为异常类 以前正常流程代码和问题处理代码相结合，现在将正常流程代码、问题处理代码分离，提高阅读性 其实异常就是java通过面向对象的思想将问题封装为对象，用异常类对其描述 不同类用问题用不同的类进行具体的描述，比如角标越界，空指针等等。 体系 问题很多，意味着描述的类也很多，将其共性进行向上抽取，形成了异常体系 最终问题就分成了两大类 Throwable：（直译：可抛的）问题发生应该就可以抛出，让调用者知道并处理 1、一般不可处理的 Error 2、可以处理的 Exception 该体系的特点就在于 Throwable 及其所有的子类都具有可抛性 可抛性是怎么体现的那？ 通过throws throw 这两个关键字所操作的类和对象都具备可抛性 该体系特点： 子类的后缀名都是用其父类名作为后缀，阅读性很强 Error JVM抛出的严重性问题，这种问题发生一般不针对性处理，直接修改程序 123456public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[1024*1024*800]; //java.lang.OutOfMemoryError: Java heap space &#125;&#125; Exception 分为两种： 编译时受检测异常：Exception和其子类都是，除了特殊子类RuntimeExcetion 这种问题一旦出现，希望在编译时就进行检测，让这种问题有对应的处理方式。 编译不检测异常（运行时异常）：RuntimeExcetion和其子类 这种问题的发生，让功能无法继续，运算也无法进行，更多是因为调用的原因导致的，或者引发程序内部状态改变，导致的异常。这种问题一般不处理，直接编译通过，在运行时，调用者调用时引发异常从而程序强制停止，此时调用者即可对异常进行修正。 过程 运到识别的问题，对象进行封装 把问题抛给调用者 123456789101112131415161718public class Demo &#123; public int method(int[] arr,int index)&#123; if(arr == null) throw new NullPointerException(&quot;你咋空指针了&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;兄台，数组越界了，角标是：&quot;+index); return arr[index]; &#125;&#125;public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[3]; Demo d = new Demo(); d.method(arr, 30); &#125;&#125; 自定义异常 对于角标是整数不存在，可以用角标越界表示，对于负数角标的情况，准备用负数角标异常表示，但是这在Java中没有定义过，那就按照Java异常的创建思想，面向对象，将负数角标进行自定义描述，并封装成对象，这种自定义问题描述称为自定义异常。 注意：如果让一个类称为异常类，必须要继承异常体系，因为只有称为异常体系的子类才有资格具备可抛性。才可以被两个关键字所操作 throws throw 12345678910111213141516171819202122232425262728 class FuShuIndexException extends Exception&#123; FuShuIndexException()&#123;&#125; FuShuIndexException(String msg)&#123; Super(msg); &#125; &#125; class Demo&#123; public int method(int[] arr,int index) throws FuShuIndexException&#123; if(arr==null) throw new NullPointerException(&quot;数组的引用不能为空&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;数组角标越界=&quot; + index); if(index &lt; 0) throw new FuShuIndexException(); return arr[index]; &#125; &#125; public class ExceptionDemo &#123; public static void main(String[] args) throws FuShuIndexException &#123; int[] arr = new int[3]; Demo d = new Demo(); d.method(arr, -1); &#125; &#125; 自定义的异常，要么继承Exception,要么继承RuntimeException 抛出 throw throw和throws区别： throws使用在函数上，抛出的是异常类，可以跑出多个，用逗号隔开 throw使用在函数内，抛出的是异常对象 捕捉 catch 可以对异常进行针对性处理的方式 12345678具体格式： try&#123; //需要被检测异常的代码 &#125;catch(异常类 变量)&#123; //该变量用于接收发生的异常对象 //真正处理该异常的代码 &#125;finally&#123; //一定会被执行的代码 &#125; 下面是演示代码 12345678910111213141516171819202122232425262728public class Demo &#123; public int method(int[] arr,int index)&#123; if(arr == null) throw new NullPointerException(&quot;你咋空指针了&quot;); if(index &gt;= arr.length) throw new ArrayIndexOutOfBoundsException(&quot;兄台，数组越界了，角标是：&quot;+index); return arr[index]; &#125;&#125;public class ExceptionDemo &#123; public static void main(String[] args)&#123; int[] arr = new int[3]; Demo d = new Demo(); try &#123; int num = d.method(null, 30); System.out.println(num); &#125;catch (NullPointerException e)&#123; System.out.println(e.toString()); &#125;catch (ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;message:&quot;+e.getMessage()); System.out.println(&quot;String:&quot;+e.toString()); //e.printStackTrace();//Jvm默认处理机制就是调用异常这个方法 System.out.println(&quot;越界&quot;); &#125;/*catch (Exception e)&#123; //多catch，父类的catch放在最下面 &#125;*/ &#125;&#125; finally代码块 除了在catch中强制关闭JVM的情况下，finally中的语句都会被执行 123456789101112131415161718/* 情况1： 运行结果：finally*/try &#123; //需要被检测异常的代码&#125;catch (NullPointerException e)&#123; //处理异常的代码 return;&#125;finally&#123; //通常用于关闭（释放）资源 System.out.println(&quot;finally&quot;);&#125;System.out.println(&quot;Over&quot;);/* 情况2：去掉第9行的return后，运行 结果：finally Over*/ try catch finally 代码组合特点 1、try catch finally 2、try catch（多个） 没有必要资源需要释放时，可以不用定义finally 3、try finally 异常无法直接处理，但是资源需要关闭 123456try&#123; //开启资源 throw new Exception;&#125;finally&#123; //关闭资源&#125; 异常处理原则 1、函数内部如果抛出需要检测的异常，函数上必须要声明，否则必须在函数内用trycatch捕捉，否则编译失败 2、如果调用到了声明异常的函数，要么trycatch，要么throws，否则编译失败 3、什么时候catch，什么时候throws那？ 功能内容可以解决，用catch 解决不了，用throws告诉调用者，由调用者解决 4、一个功能如果抛出了多个异常，那么调用时，必须有对应多个catch进行针对性的处理，内部有几个需要检测的异常，就抛几个异常，抛出几个，就catch几个 异常应用 用Java描述老师上课，需要电脑，电脑会出现蓝屏冒烟两种故障 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class LanPingException extends Exception &#123; LanPingException(String msg)&#123; super(msg); &#125;&#125;public class MaoYanException extends Exception &#123; MaoYanException(String msg)&#123; super(msg); &#125;&#125; public class Computer &#123; private int state = 0; public void run() throws LanPingException, MaoYanException &#123; if (state == 1) throw new LanPingException(&quot;蓝屏&quot;); if (state == 2) throw new MaoYanException(&quot;冒烟&quot;); System.out.println(&quot;computer run&quot;); &#125; public void reset()&#123; state = 0; System.out.println(&quot;电脑重启&quot;); &#125;&#125;public class Teacher &#123; private String name; private Computer comp; public Teacher(String name)&#123; this.name = name; comp = new Computer(); &#125; public void prolect() throws MaoYanException&#123; try &#123; comp.run(); System.out.println(name+&quot;讲课&quot;); &#125;catch (LanPingException e)&#123; e.getMessage(); comp.reset(); prolect(); &#125;catch (MaoYanException e)&#123; System.out.println(e.toString()); practice(); throw e; &#125; &#125; public void practice()&#123; System.out.println(&quot;电脑坏了，大家练习&quot;); &#125;&#125;public class Demo &#123; public static void main(String[] args)&#123; Teacher t = new Teacher(&quot;cheng&quot;); try &#123; t.prolect(); &#125; catch (MaoYanException e) &#123; System.out.println(&quot;......&quot;); &#125; &#125;&#125; 数据库连接出现异常怎么解决那 123456789101112131415class NoAddException extends Exception&#123;&#125;void addData(Data d) throws NoAddException&#123; 连接数据库 try&#123; 添加数据，出现异常 &#125;catch(NoAddException e)&#123; //处理代码 throw new NoAddException(); &#125;finally&#123; 关闭数据库 &#125;&#125; 注意事项 1、子类在覆盖父类方法的时候，父类的方法如果抛出了异常，那么子类的方法只能抛出父类的异常，或者该异常的子类 2、如果父类抛出多个异常，子类只能抛出父类异常的子集 简而言之：子类覆盖父类方法时，只能抛出父类异常或异常子类或子集 注意：若父类方法没抛出异常，子类覆盖时绝对不能抛出异常，只能try]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java-Object类]]></title>
    <url>%2F2018%2F05%2F03%2FJava-Object%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Object类 Object ：所有类的根类 Object 是抽取而来的，具备着所有对象都具备的共性内容 常用的共性内容： equals 方法 hashCode 方法 getClass 方法 toString 方法equals方法 equals 实现对象上差别可能性最大的相等关系，即，对于任何非空引用值 x 和 y ，当且仅当 x 和 y引用同一个对象时，此方法才返回 true （x==y 具有值 true） 12345678910111213141516public class Person &#123; private int age; public Person(int age)&#123; this.age = age; &#125;&#125;public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); Person p2 = new Person(20); Person p3 = p1; System.out.println(p1==p2); System.out.println(p1.equals(p2)); System.out.println(p1.equals(p3)); &#125;&#125; equals 方法重写，比较成员变量值 123456789101112131415161718public class Person &#123; private int age; public Person(int age)&#123; this.age = age; &#125; /* 一般都会覆盖此方法，根据对象的特有内容，建立判断对象是否相同的依据 */ public boolean equals(Object obj)&#123;//会将参数中的对象进行向上转型 //为了提高程序鲁棒性，进行判断 if (!(obj instanceof Person))&#123; throw new ClassCastException(&quot;类型错误&quot;); &#125; //为了使用子类的私有方法，进行向下转型 Person p = (Person) obj; return this.age == p.age; &#125;&#125; hashCode方法 先演示一下功能，发现运行后的结果很相似，发现hashCode的结果是16进制地址值的10进制数。 1234567891011public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); System.out.println(p1); System.out.println(p1.hashCode()); System.out.println(Integer.toHexString(p1.hashCode())); //Person@1540e19d //356573597 //1540e19d &#125;&#125; hashCode可以进行重写，在person类中加入如下的代码，ObjectDemo运行的结果会发生变化 123456public int hashCode()&#123; return age; &#125; //Person@14 //20 //14 getClass方法 字节码文件是经过编译器预处理过的一种文件，是JAVA的执行文件存在形式，它本身是二进制文件，但是不可以被系统直接执行，而是需要虚拟机解释执行，由于被预处理过，所以比一般的解释代码要快，但是仍然会比系统直接执行的慢 人中抽出Person，class抽取出Class（字节码文件类名）12345678910public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); Person p2 = new Person(40); Class claz1 = p1.getClass(); Class claz2 = p2.getClass(); System.out.println(claz1.equals(claz2)); //true &#125;&#125; toString方法 这是一个改写字符串方法 1234567public class ObjectDemo &#123; public static void main(String[] args)&#123; Person p1 = new Person(20); System.out.println(p1); System.out.println(p1.getClass().getName()+&quot;@&quot;+Integer.toHexString(p1.hashCode())); &#125;&#125; 运行结果：Person@1540e19d Person@1540e19d 其实这就是没改写前方法的功能，我们也可以自己进行改写 123public String toString()&#123; return &quot;Person:&quot;+age; &#125; 这样改写后输出 p1 的结果就是 Person:20]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类]]></title>
    <url>%2F2018%2F04%2F27%2FJava%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类概述 内部类 如其名，就是类的内部定义的一个类 内部类访问特点 内部类可以直接访问外部类的成员 外部类要访问内部类，必须建立内部类的对象 一般用于类的设计 分析事物时，发现该事物描述中还有事物，而且这个事物还在访问被描述的事物，这时就把含有的事物定义成内部类来描述 修饰符 如何直接访问外部类中的内部类的成员1234567891011121314public class Outer &#123; private int num = 3; public class Inner &#123; void show()&#123; System.out.println(&quot;num = &quot;+num); &#125; &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; Outer.Inner in = new Outer().new Inner(); in.show(); &#125;&#125; static 如果内部类是静态的，该如何访问内部类方法123456789101112131415161718192021public class Outer &#123; private int num = 3; public static class Inner &#123; void show()&#123; System.out.println(&quot;num = &quot;+num); &#125; //如果内部类中定义了静态成员，该内部类必须也是静态的 static void fun()&#123; System.out.println(&quot;fun&quot;); &#125; &#125; &#125; public class Test &#123; public static void main(String[] args)&#123; //如果内部类是静态的，相当于一个外部类 Outer.Inner in = new Outer.Inner(); in.show(); //如果内部类是静态的，成员是静态的 Outer.Inner.fun(); &#125; &#125; 细节 观察如下代码判断运行结果 123456789101112131415161718192021public class Outer &#123; private int num = 3; public class Inner &#123; int num = 4; public void show()&#123; int num = 5; System.out.println(num); System.out.println(this.num); System.out.println(Inner.this.num); System.out.println(Outer.this.num); &#125; &#125; public void method()&#123; new Inner().show(); &#125; &#125;public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125; &#125; 结果是：5 4 4 3 为什么内部类能直接访问外部类中成员那？ 那是因为内部类持有了外部类的引用。 外部类名.this 局部内部类 内部类可以存放在局部位置上 内部类在局部变量位置上只能访问局部中被final修饰的局部变量12345678910111213141516171819public class Outer &#123; private int num = 3; public void method()&#123; //如果不加final，会报错 final int x = 9; public class Inner &#123; public void show()&#123; System.out.println(x); &#125; &#125; Inner in = new Inner(); in.show(); &#125; &#125; public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125; &#125; 匿名内部类 匿名内部类，就是内部类的简写格式 前提：内部类必须继承或实现一个外部类或接口 匿名用户类：其实就是一个用户匿名子对象 格式：new 父类or接口 (){ 子类内容 通常使用场景之一： 当函数参数是接口类型时，而且接口中的方法不超过三个，可以用匿名内部类作为实际参数进行传递123456789101112131415161718192021222324interface inter&#123; public void show1(); public void show1();&#125;class Outer&#123; public void method()&#123; /*可以这么写 new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125;*/ //也可以这么写 inter in = new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125; /*居然还可以这么写 new inter()&#123; public void show1()&#123;&#125; public void show1()&#123;&#125; &#125;.show1(); */ &#125;&#125; 小细节静态问题 试试能不能编译如下代码 1234567891011public class InnerClassDemo &#123; class Inner&#123; &#125; public static void main(String[] args)&#123; new Inner(); &#125; public void method()&#123; new Inner(); &#125;&#125; ‘InnerClassDemo.this’ cannot be referenced from a static context 为什么 method 也写了同样的内容却没有报错？ 因为 main 是静态的，只能直接调用静态成员 转型问题 运行如下代码，将注释1取消注释，观察结果，再注释掉1，取消掉注释2，观察结果 123456789101112131415161718192021222324public class Outer &#123; public void method()&#123; /*注释1 new Object()&#123; public void show()&#123; System.out.println(&quot;i can run&quot;); &#125; &#125;.show(); */ /*注释2 Object obj = new Object()&#123; public void show()&#123; System.out.println(&quot;i can run&quot;); &#125; &#125;; obj.show(); */ &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; new Outer.method(); &#125;&#125; 为什么第一次编译运行正确，第二次编译错误？ 因为匿名内部类这个子类对象被向上转型为 object 类型，这样就不能再使用子类特有的方法了]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多态]]></title>
    <url>%2F2018%2F04%2F27%2FJava%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[对象的多态性 以代码为示例 1234567891011121314151617public class Animals &#123; public void speak()&#123; System.out.println(&quot;i am animals&quot;); &#125;&#125;public class Cat extends Animals&#123; public void speak()&#123; System.out.println(&quot;i am cat&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; //一个对象，两种形态 Animals cat = new Cat(); cat.speak(); &#125;&#125; 运行后的结果为”i am cat” 猫这类事物既具备猫的形态，又具备动物形态，这就是对象的多样性，简单说，一个对象对应着多种类型 多态在代码中的体现 父类或者接口的引用指向了其子类的对象 多态的好处 提高了代码扩展性，前期定义的代码可以使用后期的内容。 123456789101112131415161718192021222324252627282930313233public abstract class Animals &#123; public abstract void eat();&#125;public class Cat extends Animals&#123; public void eat()&#123; System.out.println(&quot;吃鱼&quot;); &#125; public void catchMouse()&#123; System.out.println(&quot;抓老鼠&quot;); &#125;&#125;public class Dog &#123; public void eat()&#123; System.out.println(&quot;啃骨头&quot;); &#125; public void guardDoor()&#123; System.out.println(&quot;看门&quot;); &#125;&#125;public class Test &#123; public static void main(String[] args)&#123; Cat c1 = new Cat(); Dog d1 = new Dog(); Dog d2 = new Dog(); method(c1); method(d1); method(d2); &#125; public static void method(Animals a)&#123; a.eat(); &#125;&#125; 如上图所示代码，如果很多只猫，很多只狗，为了代码复用性，需要在主类中定义一个方法，可是如果动物种类很多，是否要定义不同参数的许多方法那，答案是不用的，只需要定义个参数为Animals对象的即可 多态的局限性及前提 前期定义的内容，不能调用后期子类定义的特有内容 多态的前提 必须有关系，继承，实现 要有覆盖 多态转型 123456789101112131415//自动类型提升，猫对象提升了动物类型，但特有功能无法访问//作用就是限制对猫特有功能的访问//专业讲就是 向上转型，将子类型隐藏，就不用使用子类的特有方法Animals a = new Cat();a.eat();//如果还想访问具体动物的特有功能//可以进行向下转型Cat c = (Cat)a;//向下转型目的：为了使用子类中的特有方法c.eat();c.catchMouse();//错误示例Animals a1 = new Dog();Cat c1 = (Cat)a1; //ClassCastException类型转换异常 注意：对于转型来说，自始至终都是子类对象在做着类型的变化 类型判断 还是以之前的代码为示例，如果method方法内想进行输出猫，狗的特有功能该怎么做那？123456789101112public void method(Animals a)&#123; a.eat(); if(a instanceof Cat)&#123; //instanceof：用于判断对象的具体类型，只能用于引用数据类型判断 //通常在向下转型前用于健壮性的判断 Cat c = Cat(a); c.catchMouse(); &#125;else if(a instanceof dog)&#123; Dog d = Dog(a); d.guardDoor(); &#125;&#125; 多态时成员特点成员变量 编译时：参考引用型变量所属的类中是否有调用的成员变量，有则编译通过，没有则编译失败 运行时：参考引用型变量所属的类中是否有调用的成员变量，并运行该所属类中的成员变量 编译和运行都参考左边，如 animals a = new Cat(); 成员函数（非静态） 编译时：参考引用型变量所属的类中是否有调用的函数，有则编译通过，没有则编译失败 运行时：参考对象所属的类中是否有调用的函数， 简单说：编译看左边，运行看右边 1234567891011121314public class Father &#123; public void show()&#123; System.out.println(&quot;i am father&quot;); &#125;&#125;public class Son extends Father&#123; public void show() &#123; System.out.println(&quot;i am son&quot;); &#125;&#125;public class Test()&#123; Father f = new Son(); f.show();&#125; 运行后的结果 i am son 静态函数 编译时：参考引用型变量所属的类中是否有调用的静态方法，有则编译通过，没有则编译失败 运行时：参考对象所属的类中是否有调用的静态方法 简单说：编译和运行都看左边 其实对于静态方法，是不需要对象的，直接类名调用即可 1234567891011121314public class Father &#123; public static void show()&#123; System.out.println(&quot;i am father&quot;); &#125; &#125; public class Son extends Father&#123; public static void show() &#123; System.out.println(&quot;i am son&quot;); &#125; &#125; public class Test()&#123; Father f = new Son(); f.show(); &#125; 运行结果为 i am father]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承及接口]]></title>
    <url>%2F2018%2F04%2F21%2FJava%E7%BB%A7%E6%89%BF%E5%8F%8A%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[继承 什么时候继承？ 当类中存在所属关系时，就定义继承。狗和狼都是犬科，所以他们都可以继承犬科 所属关系：is a 关系 谁是谁中的一种 优点 提高代码复用性 让类与类之间产生了联系，为多态提供了前提 缺点 打破封装性 解决方法看下面的final关键字 注意 Java中支持单继承，不直接支持多继承，但对C++中多继承进行了改良 单继承：一个子类只能有一个父类 多继承：一个子类可以有多个父类（Java不直接支持，但是改良了） 因为如果多个父类中有相同成员，会产生调用的不确定性（Java中通过”多实现”的方式） Java支持多重继承 继承体系 C继承B，B继承A，就会出现继承体系 如何使用 创建该子类中的顶层类，了解该体系的基本使用功能 创建体系中的最子类对象，完成功能的使用 子父类中成员特点 子父类中，成员的特点体现 成员变量 成员函数 构造函数 成员变量 本类中成员和局部变量同名用this区分 子父类中的成员变量用super区分 this super 用法很相似 this 代表一个本类对象的引用 super 代表一个父类空间 子类不能直接访问父类中私有的内容 成员变量内存图解 以如下代码为例123456789101112131415public class Father&#123; int num = 4;&#125;public class extends Son&#123; int num = 5; void show()&#123; System.out.println(this.num+super.num); &#125;&#125;public class Demo&#123; public static void main(Sting[] args)&#123; Son s = new Son(); s.show(); &#125;&#125; 运行Demo类，main方法进栈，执行下一句话，创建一个子类对象，因为它是继承的父类，所以方法区需要先加载父类函数及构造方法，再加载子类构造方法。接下来在堆中开辟空间，给予地址，num值在父类子类中都有体现，所以存储时num值系统会通过关键字标注好。show方法入栈，this关键字指向son的num，super关键字指向father的num。 成员函数特点（覆盖） 当子父类中出现成员函数一模一样的情况，会运行子类的函数，这种现象就是覆盖操作，这是函数在子父类中的特性。 函数两个特性 重载：同一个类中 overload 覆盖：子类中，也成为重写，复写 override 注意事项： 子类方法覆盖父类方法时，子类权限必须大于等于父类权限才可以引发覆盖 静态只能覆盖静态，或被静态覆盖 什么时候使用覆盖操作？ 当对一个类进行子类的扩展时，子类需要保留父类的功能声明，但是要定义子类中该功能的特有内容时，就使用覆盖操作完成 成员函数特点应用 观察下面的代码，Phone类拥有两个方法，现在需要在他的基础上更改增加show方法的功能，就可以采用成员函数覆盖的方法 为什么不更改原代码的函数？为了安全起见，如果出错，那样很难复原。1234567891011121314151617181920212223public class Phone&#123; public void call()&#123;&#125; public void show()&#123; System.out.println(&quot;number&quot;); &#125;&#125;public class newPhone extends Phone&#123; public void call()&#123; super.call()； &#125; public void show()&#123; super.show(); System.out.println(&quot;name&quot;); System.out.println(&quot;picture&quot;); &#125;&#125;public class Demo&#123; public static void main()&#123; newPhone p = new newPhone(); p.call(); p.show(); &#125;&#125; 子父类中的构造函数子类的实例化过程 看下图代码，运行主函数后会是怎么样的结果 123456789101112131415public class Father &#123; Father()&#123; System.out.print(&quot;Father&quot;); &#125;&#125;public class Son extends Father &#123; public Son()&#123; System.out.print(&quot;Son&quot;); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; new Student(); &#125;&#125; 运行结果FatherSon，有Son我们理解，调用的是Son类，可是为什么有Father啊 特点 在子类构造对象时，发现访问子类构造参数时，父类也运行了，Why？ 在子类的构造函数第一行有一个默认的隐式语句。super(); 子类中所有的构造函数默认都会访问父类中的空参构造函数 细节 为什么子类实例化的时候，要访问父类中的构造函数那？ 那是因为子类继承了父类，获取到了父类中的内容（属性），所以在使用父类内容之前要先看父类是如何对自己的内容进行初始化的。所以子类在构造对象时，就必须访问父类中的构造函数。为了完成这个必须的动作，就在子类的构造函数中加入了super语句。如果父类中没有定义空参数构造函数，那么子类的构造函数必须用super明确要调用父类中的那个构造函数。 super语句必须要定义子类构造函数第一行。因为父类的初始化动作要先完成 如下面代码所示，子类构造函数中如果使用this调用了本类构造函数时，那么super没有了，因为super和this都只能定义在第一行，不过可以保证的是，子类中肯定会有其他构造函数访问父类的构造函数和数据 12345678910111213141516public class Father &#123; Father()&#123; System.out.print(&quot;F&quot;); &#125; &#125;public class Son extends Father &#123; Public Son()&#123; super(); System.out.print(&quot;Son1&quot;); &#125; public Son(int x)&#123; this(); //super(); System.out.print(&quot;Son2&quot;); &#125;&#125; 所有的类在创建时其实都是继承的object类,如下图的Demo类，注释掉的内容都是自动生成的隐式 123456789class Demo //extends object()&#123; /* Demo()&#123; super(); return; &#125; */&#125; 图解 以下面代码为示,123456789101112131415161718192021222324252627282930313233public class Father &#123; Father()&#123; //super(); show(); //return; &#125; public void show()&#123; System.out.println(&quot;Father show&quot;); &#125;&#125;public class Son extends Father&#123; int num = 8; public Son()&#123; super(); //-&gt;通过super初始化父类内容时，子类的成员变量并未显示初始化。 //等super()父类初始化结束后，才对子类成员变量初始化 return; &#125; public void show() &#123; System.out.println(&quot;Son show &quot;+num); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Son s = new Son(); s.show(); &#125;&#125;/*运行结果：Son show 0 Son show 8*/ 过程 一个对象的实例化过程 1、JVM会读取指定路径下的Person.class文件，并加载进内存，并会加载Person的父类（如果有直接父类的情况下） 2、在堆内存中开辟空间，分配地址 3、并在对象空间中，对对象中的属性进行默认初始化 4、调用相应的构造函数进行初始化 5、在构造函数中，第一行会先调用父类中构造函数进行初始化 6、父类在初始化完毕后，再对子类的属性进行显示初始化 7、再进行子类函数的构造初始化 8、初始化完毕后，将地址值赋给引用变量 final关键字 1、final是一个修饰符，可以修饰类，方法，变量 2、final修饰的类不可以被继承，该类为最终类 3、final修饰的方法不可以被覆盖 4、final修饰的变量是一个常量，只能赋值一次 为什么使用final修饰变量？ 其实在程序中如果一个数据是固定的，那么直接使用这个数据就可以了，但是这样阅读性差，所以应该给这个数据起个名称。而且这个变量名称的值不能变化，所以加上final固定 final应用 如下面的圆周率想定义后不被人修改，即可加上final修饰 注：被修饰后变量即是常量，表示方法为 “所有单词都大写，如果多个单词，中间用_连接” 注：final修饰的变量必须手动进行初始化，且前面一般加上static，方便调用123456class Circle&#123; static final double PI = 3.14; void method()&#123; System.out.println(PI); &#125; &#125; 抽象类 抽象：笼统，模糊，不具体 特点 1、方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰。抽象方法必须定义在抽象类中，该类也必须被abstract修饰 2、抽象类不可以被实例化，不可以被new 创建对象。因为调用抽象方法无意义 3、抽象类必须有其子类覆盖了所有的抽象方法后，该子类才可以实例化，否则这个子类还是抽象类 细节 1、抽象类中有构造函数吗？ 有，用于给子类对象初始化 2、抽象类可以不定义抽象方法吗？ 可以，但是很少见，目的是不让该类创建对象。AWT的适配器对象就是这种类。通常这个类中的方法有方法体，但是没有内容 3、抽象关键字不可以和哪些关键字共存？ private 抽象方法需要被覆盖，加上私有不能覆盖 static 加上静态后可以用类调用方法，但是抽象方法运行无意义 final final修饰后不能被继承，抽象类或方法就没有用了 4、抽象类与一般类的异同点？ 抽象类和一般类都是用来描述事物的，都在内存定义了成员 一般类有足够信息描述事物，抽象类描述事物信息一般都不足 一般类中不能定义抽象方法，抽象类中可定义抽象方法或非抽象方法 一般类能被实例化，抽象类不可以被实例化 5、抽象类一定是父类吗？ 是的，因为需要子类覆盖其方法后，才可以对子类实例化 接口定义 当一个抽象类中的方法都是抽象类的时候，可以将该抽象类用另一种形式定义和表示，就是接口 interface。 定义接口使用的关键字不是class 是interface 接口当中常见的成员：（这些成员都有固定的修饰符，都是公共权限） 全局常量：public static final 抽象方法：public static 实现 类与类之间是继承方式，类与接口之间是实现方式 1234567891011121314151617181920public interface Demo&#123; public static final int NUM = 1; public static void show1(); public static void show2();&#125;public class DemoImpl implements Demo&#123; public void show1() &#123;&#125; public void show2() &#123;&#125;&#125;public class Test&#123; public static void main(String[] args)&#123; DemoImpl d = new DemoImpl(); //下面三行语句都正确 System.out.println(d.NUM); System.out.println(DemoImpl.NUM); System.out.println(Demo.NUM); &#125;&#125; 接口不可以实例化，只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才可以实例化，否则，这个就是一个抽象类 多实现 Java中不直接支持多继承，因为会出现调用的不确定性，所以Java将多继承机制进行改良，在Java中变成了多实现 一个类支持多个接口 一个类在继承另一个类的同时，还可以实现多个接口 123456789101112131415161718public interface A&#123; public abstract void show1();&#125;public interface B&#123; public abstract void show2();&#125;public class Q&#123; public void method() &#123;&#125;&#125;//Test类继承Q类意味着他们属于一个体系//实现A,B接口是为了扩展功能class Test extends Q implements A,B&#123; public void show1() &#123;&#125; public void show2() &#123;&#125;&#125; 接口的出现避免了单继承的局限性，一个类 注意 接口与接口之间是继承关系，而且接口之间可以多继承 Java不能多继承的原因是因为方法体导致的运行不确定性，不过接口无方法体，所以接口可以多继承 接口类型的引用，都是指向自己类型子类的对象 特点 接口是对外暴露的规则 接口是程序的功能扩展 接口的出现降低耦合性 接口可以用来多实现 类与接口之间是实现关系，而且类可以继承一个类的同时实现多个接口 接口与接口之间可以有继承关系 接口抽象类区别 相同点：都是向上不断抽取而来 不同点： 抽象类： 抽象类需要被继承，且只能单继承 抽象类可以定义抽象方法和非抽象方法，子类继承后可以直接使用抽象方法 抽象类继承是 is a 关系，是在定义该体系的基本共性内容 接口： 接口需要被实现，可以多实现 接口只能定义抽象方法，必须由子类去实现 借口实现是 like a 关系，在定义体系的额外功能]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java单例模式]]></title>
    <url>%2F2018%2F04%2F21%2FJava%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式 解决问题：可以保证一个类在对象中唯一性 必须对于多个实例使用同一个配置信息对象时，就需要保证该对象唯一性 如何保证对象唯一性？ 不允许其他程序使用new创建对象 在该类创建一个本地实例 对外提供一个方法让其他程序可以获取该对象 步骤： 私有化该类构造函数 通过new在本类中创建一个本类对象 定义一个公有的方法，将创建的对象返回 饿汉式 代码展示 12345678910111213141516//饿汉式public class Single &#123; //类加载进来时，对象就已经生成了 private static Single s = new Single(); private Single()&#123;&#125; public static Single getInstance()&#123; return s; &#125;&#125;public class Demo&#123; `public static void main(String[] args)&#123; Single s1 = Single.getInstance(); Single s2 = Single.getInstance(); System.out.println(s1 == s2); &#125;&#125; 工作中常常使用的一种单例模式，安全性好 懒汉式 代码展示 123456789101112// 懒汉式public class Single2 &#123; //类加载时没有对象生成，只有调用了getInstance方法后才会创建对象 //延迟加载程序 private static Single2 s = null; private Single2()&#123;&#125; public static Single2 getInstance()&#123; if(s==null) s = new Single2(); return s; &#125;&#125; 常见于面试中，涉及知识点较多 内存图示（饿汉式为例） main进栈，s1对象生成，方法区，single构造函数进入，静态区，single s getInstance进入，堆中开辟一块空间，赋予0x0045地址，静态区中s指向堆中地址。get方法进栈，s1地址指向0x0045，get出栈。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编写工具类及API文档]]></title>
    <url>%2F2018%2F04%2F18%2FJava%E7%BC%96%E5%86%99%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%8F%8AAPI%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[昨天学习了如何编写一个工具类，及如何给他注释再去生成专属于他的API文档。今天我将这个过程以及一些遇到的报错解决整理到博客中。 编写Java工具类（以数组工具类为例） 工具类中包含了一些简单的操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** *这是一个可以对数组进行操作的工具类，该类中提供了如最值获取，排序等功能。 * @author Orange * @version 1.0 */ public class ArrayTool &#123; // private ArrayTool()&#123;&#125; /** *获取一个整型数组中的最大值 * @param arr 接收一个 int 类型的数组 * @return 会返回一个该数组中最大值 */ public static int getMax(int[] arr)&#123; selectSort(arr); int max = arr[0]; for(int i=0 ;i&lt;arr.length; i++)&#123; if(arr[i]&gt;max) max = arr[i]; &#125; return max; &#125; /** * 给int数组进行选择排序。 * @param arr 接收一个 int 类型的数组 */ public static void selectSort(int[] arr)&#123; for(int i=0 ;i&lt;arr.length-1; i++)&#123; int number = arr[i]; int index = i; for(int j=i+1;j&lt;arr.length;j++)&#123; if(number&gt;arr[j])&#123; number = arr[j]; index = j; &#125; &#125; if(index != i) swap(arr,i,index); &#125; &#125; //因为 swap 方法是 priavte ，所以只写普通注释就可以了 //给数组中元素进行位置的置换 private static void swap(int[] arr,int a,int b)&#123; int temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; /** * 将 int 形式的数组转换成字符串形式。打印形式是[s1,s2,s3,.....] * @param arr 接收一个 int 类型的数组 * @return 返回该 int 数组的字符串表现形式 */ public static String ArrayToString(int[] arr)&#123; String str = &quot;[&quot;; int point = 0; for(int i=0 ;i&lt;arr.length ;i++)&#123; if(i != arr.length-1) str = str + arr[i] + &quot;,&quot;; else str = str + arr[i] + &quot;]&quot;; &#125; return str; &#125; &#125; 注释的添加 Java文档注释|菜鸟教程 javadoc工具软件 javadoc 语法 javadoc [ options ] [ packagenames ] [ sourcefiles ] [ @files ] DOS界面使用javadoc编写API WIN-R 运行 cmd 进入 DOS 界面 通过使用CMD的命令进入包含该java工具类的文件夹 输入：javadoc -d myhelp -author -version ArrayTool.java 效果展示 报错编码GBK的不可映射字符 解决方法 关闭编译器要编写的那个工具类 用记事本打开 Java 源文件 另存为，选择 ANSI 编码 覆盖后，在DOS界面重试 成功后，将编码改回原格式 错误2 生成错误原因：改为ANSI编码后，打开了编译器，汉字都变成了乱码 切记，记事本改完编码后，不要。立即用编辑器打开该文件]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java构造函数及关键字]]></title>
    <url>%2F2018%2F04%2F15%2FJava%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[构造函数 简单说，构造函数就是构建创造对象时调用的函数 创建对象都必须要通过构造函数初始化，一个类如果没有定义过构造过程，会有一个默认空参构造函数。若定义了指定的构造函数，那么类中默认构造函数就会消失。 特点 函数名与类类名相同 不能返回值类型 没有具体返回值 区别 构造函数 对象创建时，会掉用与之相应的构造函数，对对象进行初始化 对象创建时，会调用且仅调用一次 一般函数 对象创建后，需要使用函数功能时才调用 对象创建后，可调用多次 重载 当一个类中出现多个构造函数时，必须以重载形式体现 内存图解 接下来用下面这段代码，来演示内存变化过程12345678910111213141516public class Person &#123; private String name; private int age; Person()&#123;&#125;; Person(String name,int age)&#123; this.name = name; this.age = age; &#125; public void speak()&#123; System.out.println(name+&quot;:&quot;+age); &#125; public static void main(String[] args)&#123; Person person = new Person(&quot;jack&quot;,20); person.speak(); &#125;&#125; 左面是栈内存，右面是堆内存。首先在栈内存运行main函数，创建名字为p的对象，然后栈内存调用了有参构造函数。在堆内存中开辟一片区域，给予其地址，将构造函数中的值寻址赋给堆中变量的值，然后将构造函数弹栈。将堆内存中的地址赋给p。 然后在栈中入栈speak方法，运行后寻址输出变量值this关键字 当成员变量和局部变量重名，可用关键字this区分 this代表对象，一般当前对象，this代表其所在函数所属对象的引用12345678class Person &#123; Person(String name)&#123; this.name = name; &#125; public static void main()&#123; Person p = new Person(name); &#125;&#125; 功能 this也可用于在构造函数中调用其他构造函数 注：只能定义在构造函数第一行，因为初始化动作要先执行 12345678910class Person &#123; Person()&#123;&#125; Person(String name)&#123; this.name = name; &#125; Person(String name,int age) &#123; this(name); this.age = age; &#125;&#125; 当执行主函数中的语句时，调用有参构造函数，此时this.name就是代指对象p 简单来说，哪个对象调用this所在的函数，this就代表哪个对象注意事项 运行下面的代码失败，死循环12345678910111213class Person &#123; Person()&#123; this(jack); &#125; Person(String name)&#123; this(); this.name = name; &#125; Person(String name,int age) &#123; this(name); this.age = age; &#125;&#125; 内存图解 接下来通过下面的代码来演示更加完整的过程12345678910111213141516171819public class Person &#123; private String name; private int age; Person(String name)&#123; this.name = name; &#125; public void speak()&#123; System.out.println(name+&quot;:&quot;+age); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Person p = new Person(&quot;rose&quot;); p.speak(); Person p1 = new Person(&quot;dell&quot;); p1.speak(); &#125;&#125; 首先在栈内存运行main函数，创建名字为p的对象，然后栈内存调用了有参构造函数。在堆内存中开辟一片区域，给予其地址后初始化数值，构造函数中的this起到了作用，指向p对象的地址，将 name=”jack” 传到堆中更改值，然后将构造函数弹栈。将堆内存中的地址赋给p。speak函数入栈也是通过this寻址堆中赋值。 小练习（双人年龄比较） 思路：在Person类中写一个boolean类型方法，巧妙地利用this就可以compare方法中只带一个参数。 123public boolean compare(Person p)&#123; return this.age == p.age ; &#125; 主类中如何使用？ 123Person p1 = new Person();Person p2 = new Person();p1.compare(p2); static关键字特点 static是一个修饰符，用来修饰成员 static修饰成员被所有对象共享 static优先于对象存在（static随类的加载就已经存在了） static修饰的成员多了一种调用格式，可以直接被类名调用。如：类名.静态成员 static修饰的是共享数据 对象中存储的是特有数据成员变量、静态变量区别 区别： 生命周期不同 调用方式不同 别名不同 数据存储位置不同 成员变量： 随对象创建存在，随其回收而释放 只能被对象调用 实例变量 存在堆内存的对象中，也叫对象的特有数据 静态变量： 随着类加载而存在，随着类消失而消失 可以对象调用，也可以类调用 类变量 存放在方法区（也叫共享数据区）的静态区中，也叫对象的共享数据 静态使用注意 静态方法只能调用静态成员（非静态都可以访问） 静态方法不可使用this 或者 super关键字 主函数静态的 内存图解 内存划分 寄存器 本地方法区 方法区 栈内存 堆内存 接下来用一段代码来演示内存变化过程123456789101112131415161718192021222324public class Person &#123; private String name; private int age; static String country = &quot;CN&quot;; Person()&#123;&#125;; Person(String name,int age)&#123; this.name = name; this.age = age ; &#125; public void show()&#123; System.out.println(Person.country+&quot;:&quot;+this.name+&quot;:&quot;+this.age); &#125; public static void method()&#123; System.out.println(Person.country); &#125;&#125;public class test &#123; public static void main(String[] args)&#123; Person.method(); Person p = new Person(&quot;jack&quot;,20); p.show(); &#125;&#125; 运行程序的时候，读取StaticDemo类，在方法区存放他的名字，注意还有他的自带的构造函数，然后在他的静态区粘贴上类的名字和代码，栈内存中压栈main，根据上面代码需要调用Person类，将Person类的构造函数show方法粘在方法区，在静态区添加入静态变量和静态方法。栈内存中压栈method，弹栈。继续执行主函数的语句，创建对象在堆内存开辟空间，压栈Person的构造函数，用this指向堆中的地址，赋值给堆内存。Person构造函数弹栈，将堆中地址赋值给p对象，show方法压栈，this指向堆中的地址，弹栈 静态什么时候用静态变量 当分析对象中所具备的成员变量的值都是相同的，这是这个成员就可以被静态修饰。只要数据在对象中都不同的，就是对象的特有数据，必须存在对象中。非静态的若是有相同数据，且对象不需做修改只需要使用，，那么就不需要存储在对象中，定义成静态的就可以了 静态函数 参考一点，该函数功能是否有访问到对象中的特有数据 简单来说，从源代码看该函数功能是否需要访问非静态的成员变量，如果需要，该方法就是非静态的，如果不需要，该方法就可以定义成静态的 非静态需要被对象调用，而仅创建调用非静态但没有访问特有数据的方法，那么该对象的创建是没有意义的。 静态代码块 随类的加载而执行，且只执行一次 作用：给类初始化 构造代码块：给所有对象初始化 构造函数：给对应对象针对性初始化 执行顺序，谁先执行 有对象：静态代码块 &gt; 构造代码块 &gt; 构造函数 无对象：静态代码块 &gt; 构造函数 &gt; 构造代码块 主函数特殊处 格式固定 被JVM所识别，所调用 分析： public 权限最大 static 不需要对象，直接用主函数所属类名调用 void 没有具体返回值 main 不是关键字，只是被JVM所识别固定的名字 String[] args 主函数参数列表，一个数组类型参数，元素都是字符串 接下来我们输出代码测试一下 1234public static void main(String[] args)&#123; System.out.println(args); System.out.println(args.length);&#125; 结果：[Ljava.lang.String;@1540e19d 0]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象总结]]></title>
    <url>%2F2018%2F04%2F12%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[面向对象面向对象的特点 1.符合人们的思想习惯 2.将复杂事情简单化 3.让曾经在过程中的执行者变成指挥者举例 比如说，公司中刚刚接取了一个项目，如果这个事情全部都交给老总做的话，可能会耗时很久很久，所以他就需要去找别人来帮他做。需要去面试选人，也就是寻找几个对象替他去完成工作。这就是面向对象的一种体现。 哪个对象对动作最清楚，定义在哪里成员变量、局部变量的区别 成员变量 成员变量定义在类中，整个类都可以访问 成员变量存在于堆内存的对象中 成员变量随着对象创建而生，随对象消失而亡 成员变量都有默认初始值 局部变量 局部变量定义在函数、语句、局部代码块中，只在所属区域有效 局部变量存在于栈内存的方法中 局部变量随着所属区域的执行而存在，随着所属区域结束而释放 局部变量没有默认初始值（使用前必须进行初始化）匿名对象 1.当对象对方法仅进行一次调用的时候，就可以简化成匿名对象 2.匿名对象可以作为实际参数进行传递对象的内存体现 以下面这段代码为例 123456Car c1 = new Car();Car c2 = new Car();c1.num = 4;c1.color = red;c2.num = 5;c2.color = blue; 栈中运行主函数，创建c1对象，在堆中开辟一个新的区域，将他的地址值传回栈中，他的num初始值为0，color初始值为null 下面这段代码和上面又有什么不同那1234Car c1 = new Car();Car c2 = c1；c1.num = 4;c2.color = blue; 这里将c1赋值给c2，就是将c1地址给c2，所以c2.color = blue，通过寻址找到并更改的color值就是c1地址下的匿名对象 以下面代码，作图演示123new Car().num = 4;new Car().color = red;new Car().show(); 基本数据类型参数传递12345678910class demo&#123; public static void main(String[] args)&#123; int x; show(x); System.out.println(&quot;x=&quot;+x); &#125; public static void show(int x)&#123; x = 4; &#125;&#125; 引用数据类型参数传递123456789101112class demo&#123; int x; public static void main(String[] args)&#123; demo d = new demo(); d.x = 9; show(d); System.out.println(d.x); &#125; public static void show(demo d)&#123; d.x = 4; &#125;&#125; 封装 好处： 将变化隔离 便于使用 提高重用性 提高安全性 封装原则 将不需要对外提供的原则都隐藏起来 把属性都隐藏，提供公共方法对其访问 封装思想 封装：指隐藏对象的属性和实现细节，仅对外提供公共访问方式 private权限修饰符 私有仅仅是封装的一种体现而已，封装不仅仅有私有一种方式]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2F2018%2F04%2F10%2FJava-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-%E6%9F%A5%E8%A1%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天写一下二进制转换十六进制的程序,改良程序的过程进制转换（以10转16为例） 首先想一下十六进制是多少个二进制位，4个。那么int是多少个字节？多少个二进制位？4个字节，32个二进制位 123456789public void toHex(int num)&#123; int temp; for (int i = 0;i&lt;8 ;i++) &#123; temp = num &amp; 15; System.out.print(temp+&quot; &quot;); num = num &gt;&gt;&gt; 4; &#125; &#125; 上图的结果是12 3 0 0 0 0 0 0，先来讲讲原理，再改良 1234567891011 以 num = 60 为例 0000-0000 0000-0000 0000-0000 0011-1100&amp; 0000-0000 0000-0000 0000-0000 0000-1111------------------------------------------ 0000-0000 0000-0000 0000-0000 0000-1100 0000 0000-0000 0000-0000 0000-0000 0011 ( 1100 ）&amp; 0000-0000 0000-0000 0000-0000 0000-1111------------------------------------------ 0000-0000 0000-0000 0000-0000 0000-0011 结果分别是12 3 0 0 0 0 0 0 先和15（4个低位都是1，其余是0）进行&amp;运算，得到值后，再进行&gt;&gt;&gt;3的运算。这样得到的结果还有12的存在，应该是英文字母的，继续改进 1234567891011public void toHex2(int num)&#123; int temp; for (int i = 0;i&lt;8 ;i++) &#123; temp = num &amp; 15; if (temp&gt;=10) System.out.print((char)(temp-10+&apos;A&apos;)+&quot; &quot;); else System.out.print(temp+&quot; &quot;); num = num &gt;&gt;&gt; 4; &#125; &#125; 在中间的地方加了一个判断，使用了ASCII的知识，temp-10+’A’ 得到的不是字母，所以在前面还要加上char的强制转换 继续改进，现在这些数还是倒序，而且有许多无用位。 1234567891011121314public void toHex3(int num)&#123; char[] chars = new char[]&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;, &apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;; char[] arr = new char[8]; int point = arr.length - 1 ; int temp; while (num!=0)&#123; temp = num &amp; 15; arr[point] = chars[temp]; num = num &gt;&gt;&gt; 4; point --; &#125; System.out.print(arr); &#125; 这里使用了数组的查表法，创建两个char的数组，第一个数组是用来将所获取到的0到15的数字转换为十六进制中的字符，第二个数组用来存储最后16进制的结果 在之前的两个程序中，最后输出的值都是反向的，于是我在这里创建了一个指针point，让他的初始值指向数组最后端的角标，每次输入进一个数后，指针前移一位，这样最后输出的时候直接输出数组就可以输出一个转换正确的16进制值。 进制转换整合 上面的的程序还只能对10-&gt;16转换，可以对其略作修改，使其可以灵活转换各种进制 1234567891011121314public char[] trans(int num,int base,int offse)&#123; char[] chars = new char[]&#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;, &apos;6&apos;,&apos;7&apos;,&apos;8&apos;,&apos;9&apos;,&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;D&apos;,&apos;E&apos;,&apos;F&apos;&#125;; char[] arr = new char[32]; int point = arr.length - 1 ; int temp; while (num!=0)&#123; temp = num &amp; base; arr[point] = chars[temp]; num = num &gt;&gt;&gt; offse; point --; &#125; return arr; &#125; 添加单独方法 1234567891011public char[] toBinary(int num)&#123; //十进制转换二进制 return trans(num,1,1);&#125;public char[] toHexa(int num)&#123; //十进制转换十六进制 return trans(num,15,4);&#125;public char[] toOctal(int num)&#123; //十进制转换八进制 return trans(num,7,3);&#125; 主类测试 12345678910public class tranSystem &#123; public static void main(String[] args)&#123; int num = 854796; tranSystem tra = new tranSystem(); System.out.println(tra.toHexa(num)); System.out.println(tra.toOctal(num)); System.out.println(tra.toBinary(num)); &#125; //上面写的方法添加在这里&#125; Integer.toBinaryString()是java系统自带的转换二进制 查表法 查表法在日常学习中可以有很多应用，如输入数字，输出星期几等等]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 数组常见操作]]></title>
    <url>%2F2018%2F04%2F09%2FJava-%E6%95%B0%E7%BB%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[今天整理了一些常用的数组操作，如最大值，查找，排序等等 数组最大值值判断12345678public int maxValue(int[] a)&#123; int max = a[0]; for(int i=0;i&lt;a.length;i++)&#123; if(a[i]&gt;max) max = a[i]; &#125; return max; &#125; 下标判断12345678public int maxIndex(int[] a)&#123; int max = 0; for(int i=0; i&lt;a.length;i++)&#123; if(a[i]&gt;a[max]) max = i; &#125; return a[max]; &#125; 数组操作辅助方法交换值123456public void swap(int[] arr,int a,int b)&#123; int temp = 0; temp = arr[a]; arr[a] = arr[b]; arr[b] = temp; &#125; 输出链表12345public void printList(int[] arr)&#123; for(int i = 0;i&lt;arr.length;i++) System.out.print(arr[i]+&quot; &quot;); System.out.println(); &#125; 数组选择排序12345678910111213public void chooseSort(int[] arr)&#123; //选择排序 int temp = 0; for(int i=0;i&lt;arr.length-1;i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if(arr[j]&gt;arr[i])&#123; //swap(arr,i,j); temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; 选择排序改进版 改进版的选择排序，设置了角标值和数组值1234567891011121314public void chooseSort2(int[] arr)&#123; for(int i=0;i&lt;arr.length-1;i++) &#123; int number = arr[i]; int index = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (number &gt; arr[j]) &#123; number = arr[j]; index = j; &#125; &#125; if (index!=i) swap(arr,i,index); &#125; &#125; 数组冒泡排序 冒泡排序，五个数为例，共进行4+3+2+1 10次比较123456789101112public void ppSort(int[] arr)&#123; //便于理解 int temp = 0; for(int i = 0;i&lt;arr.length-1;i++) for (int j=0;j&lt;arr.length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; //swap(arr,j,j+1); temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] =temp; &#125; &#125; &#125; 冒泡排序改进版123456789101112public void ppsort2(int[] arr)&#123; //改进版冒泡 int temp = 0; for (int i = arr.length-1;i&gt;0;i--) for(int j=0;j&lt;i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; //swap(arr,j,j+1); temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] =temp; &#125; &#125; &#125; 查找通过值查找12345678public int findByValue(int[] arr,int key)&#123; //通过值查找 int index = -1; for (int i = 0;i&lt;arr.length;i++)&#123; if(key == arr[i]) index = i + 1; &#125; return index; &#125; 二分查找1234567891011121314151617public int findHalf(int[] arr,int key)&#123; //二分查找 list list = new list(); list.chooseSort2(arr); int max = arr.length-1; int min = 0; int mid ; while(min&lt;=max)&#123; mid = (max + min)&gt;&gt;1; if(key&gt;arr[mid]) min = mid + 1; else if(key&lt;arr[mid]) max = mid - 1; else return mid; &#125; return -1; &#125; 练习题 给定一个有序的数组，如果往该数组中存储一个元素，并保证这个数组还是有序的，那么这个元素的存储的角标该如何获取？ 1234567891011121314151617public int getJiaoBiao(int[] arr,int key)&#123; / list list = new list(); list.chooseSort2(arr); int min =0; int max =arr.length-1; int mid; while(min&lt;=max)&#123; mid = (min+max)&gt;&gt;1; if(key&gt;arr[mid]) min = mid + 1; else if (key&lt;arr[mid]) max = mid - 1; else return mid; &#125; return min; &#125; 在系统自带的Arrays类中，有这个方法，不过和我这个写的不一样，比我的更好一些，我把源码粘贴上来 123456789101112131415161718private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) &#123; int low = fromIndex; int high = toIndex - 1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;&gt; 1; int midVal = a[mid]; if (midVal &lt; key) low = mid + 1; else if (midVal &gt; key) high = mid - 1; else return mid; // key found &#125; return -(low + 1); // key not found. &#125; 不同的是返回值 比如我的答案如果是6，那么他的答案就会是-7，为什么那？ 因为要插入的这个数是不存在于数组中的，所以给他一个负数的位置，那么-7怎么来的？-6-1，因为还有1个值，就是用我的方法得到0的那个值，取了负数还是0，不好分辨，所以就整体取负后再减一 总结说：存在，返回具体的角标位置，不存在的话 返回 -插入点-1]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java数组及内存图解]]></title>
    <url>%2F2018%2F04%2F08%2FJava%E5%87%BD%E6%95%B0%E5%8F%8A%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天整理了Java函数，数组，内存加载使用的问题，在这之前我先把昨天剩下的for语句写下来。 for语句 Java for语句基础 \n 回车\t 制表符\b 退格\r 按下回车键 windows系统中回车符其实是由两个符号组成 \r \nlinux 回车符只是 \n 1System.out.println(&quot;\&quot;hello world\&quot;&quot;); 上段代码最后输出结果是 “hello world” 有引号的，\会将他下一个字符转义 break 跳出 作用范围：swich语句 or 循环语句 当break语句单独存在时，下面不要定义其他语句，因为执行不到 123456A:for(int x=0; x&lt;3; x++)&#123; B:for(int y=0; y&lt;6; y++)&#123; System.out.println(x); break A; &#125;&#125; 大家观察一下上面的语句，这就是break的特殊用法，可以将for循环定义名字，break选择性的使用。 continue 继续 作用范围：循环结构 结束本次循环，继续下次循环 continue语句单独存在时，下面不要定义其他语句，因为执行不到 12345for(int x=0; x&lt;9; x++)&#123; if(x%2 == 0) continue; System.out.println(x);&#125; 函数 函数：定义在类中具有特定功能的一段小程序，也称方法。 定义及格式 定义函数格式： 1234修饰符 返回值类型 函数（参数类型 形参1, ... ... ,）&#123; 执行语句; return 返回值;&#125; 无具体返回值时，返回值类型用void，return可以忽略不写 功能 1 定义函数可将代码封装 2 便于对该功能复用 3 函数只有被调用才能执行 两个明确 1 函数功能结果是什么？ 2 实现过程中是否需要未知内容参与运算？ 函数重载 1 同一个类中的同名函数 2 参数个数不同或者是参数类型不同 3 函数重载与返回值无关 4 Java严谨性语言，如果函数出现调用不确定性，会编译失败（比如int返回值却是double参数类型） 数组 Java数组基础 内存 内存的划分 寄存器 本地方法区 方法区 栈内存 堆内存 栈内存 存储的都是局部变量，变量所属作用域一旦结束，该变量就自动释放 堆内存 储存数组和对象（数组就是对象），new 建立的都在堆上 特点： 每个实体都有首地址值 堆内存中每个变量都有默认内存初始值，根据类型不同而不同（int -&gt; 0,double -&gt; 0.0,float -&gt; 0.0f,boolean -&gt; false,char -&gt; ‘\u0000’） 垃圾回收机制 数组运行内存图解一维数组 接下来我就通过这段代码来演示运行时的内存变化 1234567int[] x = new int[3];int[] y = new int[3];x[0] = 9;y[0] = 34;x = y;System.out.println(x[0]);y = null; 栈中运行main然后存入x数组名，堆中分配地址（16进制），找到这个地址，开辟数组大小的空间，并给予其初始值。然后将数组地址传回栈中。 给x[0],y[0]赋值时，就是直接在堆内存中更改数据 x=y 语句的执行实质上就是将y的地址赋给x，下次再调用x的时候，即直接找到y的地址 当y = null; 就是将堆内存 和栈内存的指向关系删去， 12int[] x = new int[3];System.out.println(x[]); 如果直接运行上段代码，所得到的结果是一串字符 [I@1540e19d （我运行后的值） [: 代表数组I：int 实体类型1540e19d：16进制的哈希值（地址） 二维数组 直接来是二维数组的图解123int[][] arr = new int[3][2];arr[1][1] = 89;arr[2][2] = 89; //error 大家看下图，以上图为例，所谓二维数组就是栈内存中存下指向堆内存的地址，这个地址是大小为3的数组，初始值为空，然后再创建3个小的数组，每个小数组还有一个地址，将这些地址对应存到之前大小为3的数组中。 1234int[][] arr = new int[3][2];System.out.println(arr);System.out.println(arr[0]);System.out.println(arr[0][0]); 输出的结果 123[[I@1540e19d[I@677327b60 再来看看另一种定义下的情况 1234int[][] arr = new int[3][];System.out.println(arr);System.out.println(arr[0]);System.out.println(arr[0][0]); 结果如下 123[[I@1540e19dnullException in thread &quot;main&quot; java.lang.NullPointerException]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java运算符基础]]></title>
    <url>%2F2018%2F04%2F07%2FJava%E8%BF%90%E7%AE%97%E7%AC%A6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[今天重温的主要是Java运算符，在这里我把之前已经遗忘的一些点记录下来，以后回顾的时候可以翻阅。 比较运算符^异或： 符号两边的结果相同为False，不同则为True1234True ^ True = False ;False ^ True = True ;True ^ False = True ;False ^ False = False ; ！非： 两次非运算就是原数12!true = false ;!!true = true ; 逻辑运算符&amp;和&amp;&amp;的区别： 让我们先来看一段代码 123int x = 1;if(x&gt;2 &amp;&amp; x&lt;5) System.out.println(); 在上面的情况中，在对 &amp;&amp; 左边的式子进行判断后，得出左边的式子值是false，因为两数相与，只要有一个flase，整体式子的结果就是false。所以停止运算右侧式子，直接给出false的结果。 但是使用 &amp; 运算符的时候，无论左边式子是什么，右边都参与运算。 &amp;&amp; 和 &amp; 运算结果一样，过程有一些小区别&amp; ：无论左边式子是什么，右边都参与运算&amp;&amp; ：当式子左边为false时，右边不参与运算，结果为false |和||的区别 上面我们说了 &amp; 和 &amp;&amp; 的区别，其实原理是一样的 || 和 | 运算结果一样，过程有一些小区别| ：无论左边式子是什么，右边都参与运算|| ：当式子左边为true时，右边不参与运算，结果为true 位运算&amp; 位运算 下面我用一个小例子来演示 12345676 &amp; 3 = ?内存中 0000-0000 0000-0000 0000-0000 0000-0110&amp; 0000-0000 0000-0000 0000-0000 0000-0011----------------------------------------- 0000-0000 0000-0000 0000-0000 0000-0010∴ 6 &amp; 3 = 2 6 &amp; 3 在内存中变化的实质是，转换为2进制，各位相对应的进行 &amp; 运算 应用场景： 取0100 0000 1100 0101的后四位，如何进行操作？ 答 ：用0000 0000 0000 1111与其进行 &amp; 运算。 | 位运算 原理同上 例如 6 | 3 = 7 ^ 位运算 原理同上 1234567891011126 ^ 3 = ?内存中(简化) 0110 ^ 0011 ------ 0101∴ 6 ^ 3 = 5继续 ^ 35 ^ 3 = ?演算后 5 ^ 3 = 6 不知道大家发没发现这个运算的一些小秘密，那就是一个数连续两次与相同的数进行异或运算后，结果会是最初的数。用公式写就是： a ^ b ^ b = a 那么这个究竟可以用作干什么那？可以用于文件的加密！ ~ 反码 大家可以在自己的电脑上试一下下面的代码，看看是不是自己猜测的值 12int a = 2;System.out.println(~a); 结果是 -3 ，很多人可能都以为反码的意思就是将a的二进制10取反为01，猜测结果是1 为什么不是这样的运算过程那？ 原理这就要从计算机常用的几个码说起了。首先，java存储的是有符号数，在计算机中，有符号数通常是使用补码存储的，java也不例外。先来看看什么叫原码，反码，补码。 原码原码就是符号位加上真值的绝对值,即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:1[+1]原 = 0000 0001 反码正数的反码是其本身负数的反码是在其原码的基础上,符号位不变，其余各个位取反.例如：1[+1] = [00000001]原 = [00000001]反 补码正数的补码就是其本身负数的补码是在反码的基础上+1。例如:1[+1] = [00000001]原 = [00000001]反 = [00000001]补 分析所以回到一开始的问题，int a = 2 a在计算机中是以补码存储的。 对于2这个正数来说，补码、反码、原码都是相同的，又由于是数值型，在这里我先用八位bit来表示一下：12原码:0000 0010反码:0000 0010 补码:0000 0010 取反取反过程是在补码的基础上进行的，由于是按位取反，无论符号位还是数值位都要取反，所以结果如下: 1取反后的补码: 1111 1101 换算为值那么取反后的补码的实际值是多少呢？我们需要先把他转化为原码，过程如下: 1反码 = 1111 1101 - 1 = 1111 1100 原码 = 反码符号位不变，其余取反 = 1000 0011 所以，最后的值-3 &lt;&lt; 左移 这个符号之前并没有听说过，在这次学习中进行了掌握（开始我还以为是C++的cout那） 1234563 &lt;&lt; 2 = ?内存中0000-0000 0000-0000 0000-0000 0000-0011结果0000-0000 0000-0000 0000-0000 0000-1100∴ 3 &lt;&lt; 2 = 12 上面的运算实质是 3的2进制 整题左移两位，多余的舍弃，空位用0补 一个数进行左移运算时，左移n位，即是该数乘以2的n次幂 &gt;&gt; 右移 原理几乎一样，只有略微的不同原来最高位是什么，用什么补空位（因为最高位为1时是负数） 右移n位，即是该数除以2的n次幂1234-12 &gt;&gt; 2 = ?答： -3 12 &gt;&gt; 2 = ?答： 3 &gt;&gt;&gt; 无符号右移 高位空位，全部填0，用0补位1234-12 &gt;&gt;&gt; 2 = ?答： 3 12 &gt;&gt;&gt; 2 = ?答： 3 应用 请用效率最高的方法求出 2*8 的值。 1System.out.println(2&lt;&lt;3); 两个整数值互换（不使用第三方变量） 1234567891011方法1：（不建议使用，如果数值过大，可能丢失精度）int a = 3, b = 5;a = a + b;b = a - b;a = a - b方法2：（利用异或位运算）int a = 3, b = 5;a = a ^ b;b = a ^ b;a = a ^ b; 三元运算符 （条件表达式）？表达式1：表达式2 若条件为true ，结果为表达式1若条件为false，结果为表达式21234练习：在x , y中取 值较大的整数int x = 3, y = 4;int max = ( x&gt;y )? x : y;System.out.println(max); swich 和 if else 与 三元运算符 三元运算符必须有结果，if else可有，可不有结果。当if else有具体运算结果时，可以使用三元运算符。 1234567891011121314151617swich使用示范： int x = 3; swich(x) &#123; case 1: System.out.println(x); break; case 2: System.out.println(x); break; case 3: System.out.println(x); break; case default: System.out.println(x); break; &#125; if： 对几个具体值进行判断 对区间判断 对运算结果boolean类型表达式判断 swich： 对几个具体值进行判断 值的个数通常是固定的 对几个固定值判断，建议使用swich，swich将答案存在内存中，效率高]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 链表实现]]></title>
    <url>%2F2018%2F04%2F06%2FJava-%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[分享一下我用java实现的链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public class LinkList&lt;T&gt; &#123; private Node&lt;T&gt; head; //头节点 private Node&lt;T&gt; tail; //尾节点 /** * 构造空链表 */ public LinkList()&#123; head = tail = null; &#125; /** * 链表内部的节点类 */ private static class Node&lt;T&gt;&#123; T data; //节点的数据 Node&lt;T&gt; next; //该节点指向下一个节点的指针 Node(T data)&#123; this.data = data; this.next = null; &#125; &#125; /** * 为空链表增加头节点 */ public void addHead(T point)&#123; this.head = new Node&lt;T&gt;(point); if(tail == null)&#123; tail = head; &#125; &#125; /** * 为链表增加尾节点 */ public void addTail(T point)&#123; tail = new Node&lt;T&gt;(point); head.next = tail; &#125; /** * 插入节点（头插法） */ public void addNode(T point)&#123; if(this.head==null) //添加头节点 addHead(point); else if(this.tail==this.head) //在头节点后添加尾节点 addTail(point); else&#123; Node&lt;T&gt; newNode = new Node&lt;T&gt;(point); newNode.next = head.next; head.next = newNode; &#125; &#125; /** * 删除节点（通过数据值） */ public void deleteNode(T data)&#123; Node&lt;T&gt; curr = head ,pre = null; boolean flag = false; //判断要删除的节点是否存在 while(curr != null)&#123; if(curr.data.equals(data))&#123; if (curr==head)&#123; //删除头节点 System.out.println(&quot;delete the head Node&quot;); head = curr.next; flag = true; &#125;else if (curr==tail)&#123; //删除尾节点 System.out.println(&quot;delete the tail Node&quot;); tail = pre; pre.next = null; flag = true; &#125;else &#123; //删除中间节点 System.out.println(&quot;delete the center Node&quot;); pre.next = curr.next; flag = true; &#125; &#125; pre = curr; curr = curr.next; &#125; if (flag == false) System.out.println(&quot;链表中不存在该数据&quot;); &#125; /** * 查找链表中的元素（通过位置） */ public void findKth(T point)&#123; Node&lt;T&gt; curr = head , pre = null; int k = 1; boolean flag = false; while (curr != null)&#123; if(point.equals(k))&#123; System.out.println(&quot;第&quot;+k+&quot;位的值是&quot;+curr.data); flag = true; &#125; pre = curr; curr = curr.next; k++; &#125; if(flag==false) System.out.println(&quot;查找的位置在链表中不存在&quot;); &#125; /** * 查找链表中的元素（通过值） */ public void findByValue(T data)&#123; Node&lt;T&gt; curr = head ; int k = 1; boolean flag = false; while(curr!=null)&#123; if(curr.data==data)&#123; System.out.println(&quot;查找的值在链表中的第&quot;+k+&quot;位&quot;); flag = true; &#125; curr = curr.next; k++; &#125; if(flag==false) System.out.println(&quot;查找的值在链表中不存在&quot;); &#125; /** * 输出链表 */ public void printlnLink()&#123; Node&lt;T&gt; curr = this.head; if(curr==null)&#123; System.out.println(&quot;linklist is null&quot;); &#125;else&#123; while(curr!=null)&#123; System.out.print(curr.data+&quot; &quot;); curr = curr.next; &#125;System.out.println(); &#125; &#125; public static void main(String[] args)&#123; LinkList linkList = new LinkList&lt;Integer&gt;(); linkList.addNode(5); linkList.addNode(8); linkList.addNode(10); linkList.addNode(6); linkList.addNode(9); System.out.println(&quot;TailNode: &quot;+linkList.tail.data); linkList.deleteNode(8); linkList.printlnLink(); linkList.findByValue(5); linkList.findKth(10); System.out.print(&quot;&quot;); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java易错知识点]]></title>
    <url>%2F2018%2F04%2F06%2FJava%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[最近在看Java基础知识的视频，因为距离大二学习基础知识的时光有些久远了，并且当时也并没有进行总结，所以写下这个博客权当做笔记，方便温故而知新。 强制转换1234567891011第一种情况 byte a = 1; a = 3 + 4; System.out.println(a); 第二种情况 byte a = 1; byte b = 3; byte c = 4; a = b + c; System.out.println(a); 在这两种情况下，最后运行的值有什么不同那？ 第一个的值最后为7；第二个运行后运行错误，显示可能损失精度。 第一种情况下，因为3和4是int值，a是byte值，当a=3+4时，运算符对左右两边进行了一个判断，如果右边的数在byte的范围内，则自动将其强制转换，赋值给a。 第二种情况下，b、c都是变量，系统不可以自动将其强制转换，因为他们可能是一个大于byte范围的数。 算数运算符12345678910111213141516第一种情况 int x = 3, y; y = x++; System.out.println(x); System.out.println(y); 第二种情况 int x = 3, y; y = ++x; System.out.println(x); System.out.println(y); 第三种情况 int a = 3; a = a++; System.out.println(a); 运行结果分别是什么？ 123x = 4 y = 3x = 4 y = 4a = 3 第一种情况涉及到了运算符的原理，系统是如何对 y=x++ 这个式子进行处理的那，先将 x 原先的值3存储起来，再对x进行++运算，最后进行=运算的时候将预存的x的值赋给y。 第二种情况主要式子是 y=++x ，这次是直接进行 ++x 的运算，再将他赋给y。 第三种情况和第一种情况大致相同，为了方便理解，我将 a = a++ 在内存中的处理过程写成程序。通过下面的代码就能够了解为什么最后的结果是3了。 1234int a = 3;temp = a;a++;a = temp; +=运算问题123short s = 3;s += 4;s = s + 4; 第二个式子和第三个式子有什么不同？ 第二个式子可以运行成功，第三个式子不可以。在这里4是int值，+=是一个运算符，他会对右边的数进行判断，是否在short的范围内再自动进行强制转换，赋值给s。而第三个式子=的右面面对的是变量s，必须手动进行强制转换。 %运算问题12a = -5 % 2;b = 5 % -2; a和b的值分别是多少？ a = -1，b = 1 取模运算只有 %左边是负数的情况下对结果有影响]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建hexo博客]]></title>
    <url>%2F2018%2F03%2F28%2F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[经过了好一段时间的折腾，终于成功搭建好了博客。我就在这里分享一些使用Hexo+Github搭建的心得。既是为了分享，也是为了防止自己遗忘，备份之用。 搭建前准备工作 1.安装node.js 2.安装git 3.安装hexo （右键git bash 运行$ npm install -g hexo） 本地搭建静态博客 1.新建一个文件夹 如MyBlog 2.生成git模板 在MyBlog文件夹内，右键git bash输入$ hexo init 3.运行npm install 4.运行npm server 5.http://localhost:4000 可以看到本地搭建的博客 将博客关联github 在github上创建名字为XXX.github.io项目(XXX为用户名) 打开本地MyBlog文件夹内的_config.yml配置文件 ,拉到最底下，更改为 1234deploy: type: git repository: https://github.com/OrangeTop/OrangeTop.github.io.git branch: master 第一次使用git需要配置ssh,引号处填写自己的邮箱 1git bash $ ssh-keygen -t rsa -C "your_email@youremail.com" 然后一路回车即可成功生成.ssh文件 在C:\users\用户名.ssh文件夹中，打开id_rsa.pub，全部复制。然后回到github网站，进入setting选择SSH and GPG–&gt;New SSh Keytitle随意填，Key粘贴 1验证:git bash $ ssh -T git@github.com 上传本地仓库， 右键git bash。 (引号处注意填写自己的信息) 12$ git config --global user.name &quot;your name&quot; $ git config --global user.email &quot;your_email@youremail.com&quot; 继续部署，中途需要输入用户名密码 123$ npm install hexo-deployer-git --save$ hexo g$ hexo d 最后在浏览器输入OrangeTop.github.io 即可看见博客 The First Blog 进入MyBlog文件夹右键git bash123456789101112//创建新的博客，文件在source-&gt;_posts文件夹下hexo new &quot;新的文件名&quot;//运行hexo，访问本地localhost:4000可预览hexo s//进入MyBlog文件夹下的public文件夹cd public//本地生成静态文件hexo g//返回MyBlog文件夹cd ..//将本地静态文件推送至githubhexo d 报错解决 下载hexo报错 12345$ npm install -g hexonpm ERR! Unexpected end of JSON input while parsing near &apos;...&quot;commander&quot;:&quot;*&quot;&#125;,&quot;opt&apos;npm ERR! A complete log of this run can be found in:npm ERR! C:\Users\75173\AppData\Roaming\npm-cache\_logs\2018-03-27T13_25_30_385Z-debug.log 解决方法 1234更换为淘宝镜像npm --registry https://registry.npm.taobao.org install express 检验是否更换成功npm config get registry 若不成功，继续 1234清理缓存npm cache clean –force重新安装npm install -g hexo 使用一段时间后，hexo d上传失败，ssh连接github失败 1234打开C:\Windows\System32\drivers\etc目录下的hosts文件再最后面加上下面两行192.30.253.112 github.com192.30.253.113 github.com 参考文章 教你搭一个博客 Hexo博客搭建教程]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇文章]]></title>
    <url>%2F2018%2F03%2F28%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[尼采说： Was mich nicht umbringt, macht mich stärker.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
